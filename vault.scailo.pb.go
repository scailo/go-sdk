// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.8
// 	protoc        (unknown)
// source: vault.scailo.proto

package sdk

import (
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"

	_ "buf.build/gen/go/bufbuild/protovalidate/protocolbuffers/go/buf/validate"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Describes the message consisting of the list of vault resources
type VaultResourcesList struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// List of files
	Files []*VaultFile `protobuf:"bytes,1,rep,name=files,proto3" json:"files,omitempty"`
	// List of folders
	Folders       []*VaultFolder `protobuf:"bytes,2,rep,name=folders,proto3" json:"folders,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *VaultResourcesList) Reset() {
	*x = VaultResourcesList{}
	mi := &file_vault_scailo_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VaultResourcesList) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VaultResourcesList) ProtoMessage() {}

func (x *VaultResourcesList) ProtoReflect() protoreflect.Message {
	mi := &file_vault_scailo_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VaultResourcesList.ProtoReflect.Descriptor instead.
func (*VaultResourcesList) Descriptor() ([]byte, []int) {
	return file_vault_scailo_proto_rawDescGZIP(), []int{0}
}

func (x *VaultResourcesList) GetFiles() []*VaultFile {
	if x != nil {
		return x.Files
	}
	return nil
}

func (x *VaultResourcesList) GetFolders() []*VaultFolder {
	if x != nil {
		return x.Folders
	}
	return nil
}

// Describes the message that stores the headers necessary for performing the RELAY request
type GiXRelayHeader struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The name of the header
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// The value of the header
	Value         string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GiXRelayHeader) Reset() {
	*x = GiXRelayHeader{}
	mi := &file_vault_scailo_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GiXRelayHeader) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GiXRelayHeader) ProtoMessage() {}

func (x *GiXRelayHeader) ProtoReflect() protoreflect.Message {
	mi := &file_vault_scailo_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GiXRelayHeader.ProtoReflect.Descriptor instead.
func (*GiXRelayHeader) Descriptor() ([]byte, []int) {
	return file_vault_scailo_proto_rawDescGZIP(), []int{1}
}

func (x *GiXRelayHeader) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *GiXRelayHeader) GetValue() string {
	if x != nil {
		return x.Value
	}
	return ""
}

// Describes the message that is required to execute a RELAY instruction for GET, DELETE and HEAD requests (without payload body)
type GiXRelayReqWithoutBody struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The UUID of the app execution
	Uuid string `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	// The content type header of the relay request (e.g., 'application/json', 'text/html')
	RelayContentTypeHeader string `protobuf:"bytes,4,opt,name=relay_content_type_header,json=relayContentTypeHeader,proto3" json:"relay_content_type_header,omitempty"`
	// The accept header of the relay request (e.g., 'application/json', 'text/html')
	RelayAcceptHeader string `protobuf:"bytes,5,opt,name=relay_accept_header,json=relayAcceptHeader,proto3" json:"relay_accept_header,omitempty"`
	// The list of additional headers that will be relayed to the remote URL
	RelayHeaders []*GiXRelayHeader `protobuf:"bytes,10,rep,name=relay_headers,json=relayHeaders,proto3" json:"relay_headers,omitempty"`
	// The remote URL that needs to be accessed
	Url           string `protobuf:"bytes,20,opt,name=url,proto3" json:"url,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GiXRelayReqWithoutBody) Reset() {
	*x = GiXRelayReqWithoutBody{}
	mi := &file_vault_scailo_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GiXRelayReqWithoutBody) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GiXRelayReqWithoutBody) ProtoMessage() {}

func (x *GiXRelayReqWithoutBody) ProtoReflect() protoreflect.Message {
	mi := &file_vault_scailo_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GiXRelayReqWithoutBody.ProtoReflect.Descriptor instead.
func (*GiXRelayReqWithoutBody) Descriptor() ([]byte, []int) {
	return file_vault_scailo_proto_rawDescGZIP(), []int{2}
}

func (x *GiXRelayReqWithoutBody) GetUuid() string {
	if x != nil {
		return x.Uuid
	}
	return ""
}

func (x *GiXRelayReqWithoutBody) GetRelayContentTypeHeader() string {
	if x != nil {
		return x.RelayContentTypeHeader
	}
	return ""
}

func (x *GiXRelayReqWithoutBody) GetRelayAcceptHeader() string {
	if x != nil {
		return x.RelayAcceptHeader
	}
	return ""
}

func (x *GiXRelayReqWithoutBody) GetRelayHeaders() []*GiXRelayHeader {
	if x != nil {
		return x.RelayHeaders
	}
	return nil
}

func (x *GiXRelayReqWithoutBody) GetUrl() string {
	if x != nil {
		return x.Url
	}
	return ""
}

// Describes the message that is required to execute a RELAY instruction for POST, PUT and PATCH requests (with payload)
type GiXRelayReqWithBody struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The UUID of the app execution
	Uuid string `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	// The content type header of the relay request (e.g., 'application/json', 'text/html')
	RelayContentTypeHeader string `protobuf:"bytes,4,opt,name=relay_content_type_header,json=relayContentTypeHeader,proto3" json:"relay_content_type_header,omitempty"`
	// The accept header of the relay request (e.g., 'application/json', 'text/html')
	RelayAcceptHeader string `protobuf:"bytes,5,opt,name=relay_accept_header,json=relayAcceptHeader,proto3" json:"relay_accept_header,omitempty"`
	// The list of additional headers that will be relayed to the remote URL
	RelayHeaders []*GiXRelayHeader `protobuf:"bytes,10,rep,name=relay_headers,json=relayHeaders,proto3" json:"relay_headers,omitempty"`
	// The remote URL that needs to be accessed
	Url string `protobuf:"bytes,20,opt,name=url,proto3" json:"url,omitempty"`
	// The body that needs to be relayed
	Body          []byte `protobuf:"bytes,30,opt,name=body,proto3" json:"body,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GiXRelayReqWithBody) Reset() {
	*x = GiXRelayReqWithBody{}
	mi := &file_vault_scailo_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GiXRelayReqWithBody) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GiXRelayReqWithBody) ProtoMessage() {}

func (x *GiXRelayReqWithBody) ProtoReflect() protoreflect.Message {
	mi := &file_vault_scailo_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GiXRelayReqWithBody.ProtoReflect.Descriptor instead.
func (*GiXRelayReqWithBody) Descriptor() ([]byte, []int) {
	return file_vault_scailo_proto_rawDescGZIP(), []int{3}
}

func (x *GiXRelayReqWithBody) GetUuid() string {
	if x != nil {
		return x.Uuid
	}
	return ""
}

func (x *GiXRelayReqWithBody) GetRelayContentTypeHeader() string {
	if x != nil {
		return x.RelayContentTypeHeader
	}
	return ""
}

func (x *GiXRelayReqWithBody) GetRelayAcceptHeader() string {
	if x != nil {
		return x.RelayAcceptHeader
	}
	return ""
}

func (x *GiXRelayReqWithBody) GetRelayHeaders() []*GiXRelayHeader {
	if x != nil {
		return x.RelayHeaders
	}
	return nil
}

func (x *GiXRelayReqWithBody) GetUrl() string {
	if x != nil {
		return x.Url
	}
	return ""
}

func (x *GiXRelayReqWithBody) GetBody() []byte {
	if x != nil {
		return x.Body
	}
	return nil
}

// Describes the payload that will be returned to the GiX Relay RPC
type GiXRelayResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The UUID of the app execution
	Uuid string `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	// The response from the remote URL
	Body          []byte `protobuf:"bytes,10,opt,name=body,proto3" json:"body,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GiXRelayResponse) Reset() {
	*x = GiXRelayResponse{}
	mi := &file_vault_scailo_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GiXRelayResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GiXRelayResponse) ProtoMessage() {}

func (x *GiXRelayResponse) ProtoReflect() protoreflect.Message {
	mi := &file_vault_scailo_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GiXRelayResponse.ProtoReflect.Descriptor instead.
func (*GiXRelayResponse) Descriptor() ([]byte, []int) {
	return file_vault_scailo_proto_rawDescGZIP(), []int{4}
}

func (x *GiXRelayResponse) GetUuid() string {
	if x != nil {
		return x.Uuid
	}
	return ""
}

func (x *GiXRelayResponse) GetBody() []byte {
	if x != nil {
		return x.Body
	}
	return nil
}

var File_vault_scailo_proto protoreflect.FileDescriptor

const file_vault_scailo_proto_rawDesc = "" +
	"\n" +
	"\x12vault.scailo.proto\x12\x06Scailo\x1a\x11base.scailo.proto\x1a\x1bbuf/validate/validate.proto\x1a\x12roles.scailo.proto\x1a\x1avault_commons.scailo.proto\x1a\x18vault_files.scailo.proto\x1a\x1avault_folders.scailo.proto\"l\n" +
	"\x12VaultResourcesList\x12'\n" +
	"\x05files\x18\x01 \x03(\v2\x11.Scailo.VaultFileR\x05files\x12-\n" +
	"\afolders\x18\x02 \x03(\v2\x13.Scailo.VaultFolderR\afolders\"L\n" +
	"\x0eGiXRelayHeader\x12\x1b\n" +
	"\x04name\x18\x01 \x01(\tB\a\xbaH\x04r\x02\x10\x01R\x04name\x12\x1d\n" +
	"\x05value\x18\x02 \x01(\tB\a\xbaH\x04r\x02\x10\x01R\x05value\"\xc2\x02\n" +
	"\x16GiXRelayReqWithoutBody\x12\x1c\n" +
	"\x04uuid\x18\x01 \x01(\tB\b\xbaH\x05r\x03\xb0\x01\x01R\x04uuid\x12]\n" +
	"\x19relay_content_type_header\x18\x04 \x01(\tB\"\xbaH\x1fr\x1dR\x10application/jsonR\ttext/htmlR\x16relayContentTypeHeader\x12R\n" +
	"\x13relay_accept_header\x18\x05 \x01(\tB\"\xbaH\x1fr\x1dR\x10application/jsonR\ttext/htmlR\x11relayAcceptHeader\x12;\n" +
	"\rrelay_headers\x18\n" +
	" \x03(\v2\x16.Scailo.GiXRelayHeaderR\frelayHeaders\x12\x1a\n" +
	"\x03url\x18\x14 \x01(\tB\b\xbaH\x05r\x03\x88\x01\x01R\x03url\"\xd3\x02\n" +
	"\x13GiXRelayReqWithBody\x12\x1c\n" +
	"\x04uuid\x18\x01 \x01(\tB\b\xbaH\x05r\x03\xb0\x01\x01R\x04uuid\x12]\n" +
	"\x19relay_content_type_header\x18\x04 \x01(\tB\"\xbaH\x1fr\x1dR\x10application/jsonR\ttext/htmlR\x16relayContentTypeHeader\x12R\n" +
	"\x13relay_accept_header\x18\x05 \x01(\tB\"\xbaH\x1fr\x1dR\x10application/jsonR\ttext/htmlR\x11relayAcceptHeader\x12;\n" +
	"\rrelay_headers\x18\n" +
	" \x03(\v2\x16.Scailo.GiXRelayHeaderR\frelayHeaders\x12\x1a\n" +
	"\x03url\x18\x14 \x01(\tB\b\xbaH\x05r\x03\x88\x01\x01R\x03url\x12\x12\n" +
	"\x04body\x18\x1e \x01(\fR\x04body\"D\n" +
	"\x10GiXRelayResponse\x12\x1c\n" +
	"\x04uuid\x18\x01 \x01(\tB\b\xbaH\x05r\x03\xb0\x01\x01R\x04uuid\x12\x12\n" +
	"\x04body\x18\n" +
	" \x01(\fR\x04body2\xe3\x1c\n" +
	"\fVaultService\x12[\n" +
	"\fInitiateFile\x12$.Scailo.VaultFileInitiateFileRequest\x1a%.Scailo.VaultFileInitiateFileResponse\x12H\n" +
	"\fAddFileChunk\x12 .Scailo.VaultFileAddChunkRequest\x1a\x16.Scailo.IdentifierUUID\x12>\n" +
	"\fCompleteFile\x12\x16.Scailo.IdentifierUUID\x1a\x16.Scailo.IdentifierUUID\x12H\n" +
	"\n" +
	"RenameFile\x12\".Scailo.VaultFileRenameFileRequest\x1a\x16.Scailo.IdentifierUUID\x12B\n" +
	"\tUnzipFile\x12\x1d.Scailo.VaultFileUnzipRequest\x1a\x16.Scailo.IdentifierUUID\x12=\n" +
	"\vPersistFile\x12\x16.Scailo.IdentifierUUID\x1a\x16.Scailo.IdentifierUUID\x12D\n" +
	"\bMoveFile\x12 .Scailo.VaultFileMoveFileRequest\x1a\x16.Scailo.IdentifierUUID\x12<\n" +
	"\n" +
	"DeleteFile\x12\x16.Scailo.IdentifierUUID\x1a\x16.Scailo.IdentifierUUID\x12N\n" +
	"\x11AddFilePermission\x12!.Scailo.VaultPermissionAddRequest\x1a\x16.Scailo.IdentifierUUID\x12T\n" +
	"\x14ModifyFilePermission\x12$.Scailo.VaultPermissionModifyRequest\x1a\x16.Scailo.IdentifierUUID\x12F\n" +
	"\x14DeleteFilePermission\x12\x16.Scailo.IdentifierUUID\x1a\x16.Scailo.IdentifierUUID\x12<\n" +
	"\fDownloadFile\x12\x16.Scailo.IdentifierUUID\x1a\x14.Scailo.StandardFile\x12C\n" +
	"\x13DownloadFileVersion\x12\x16.Scailo.IdentifierUUID\x1a\x14.Scailo.StandardFile\x12<\n" +
	"\fViewFileLogo\x12\x16.Scailo.IdentifierUUID\x1a\x14.Scailo.StandardFile\x12;\n" +
	"\x0eViewFileByUUID\x12\x16.Scailo.IdentifierUUID\x1a\x11.Scailo.VaultFile\x125\n" +
	"\fViewFileByID\x12\x12.Scailo.Identifier\x1a\x11.Scailo.VaultFile\x12F\n" +
	"\rViewFileChunk\x12\x16.Scailo.IdentifierUUID\x1a\x1d.Scailo.VaultFileVersionChunk\x12N\n" +
	"\x15ViewFileChunkMetadata\x12\x16.Scailo.IdentifierUUID\x1a\x1d.Scailo.VaultFileVersionChunk\x12E\n" +
	"\x12ViewFilePermission\x12\x16.Scailo.IdentifierUUID\x1a\x17.Scailo.VaultPermission\x12H\n" +
	"\rDoesFileExist\x12\x1e.Scailo.VaultDuplicateCheckReq\x1a\x17.Scailo.BooleanResponse\x12I\n" +
	"\x10ViewFileVersions\x12\x16.Scailo.IdentifierUUID\x1a\x1d.Scailo.VaultFileVersionsList\x12I\n" +
	"\x12ViewFileAccessLogs\x12\x16.Scailo.IdentifierUUID\x1a\x1b.Scailo.VaultAccessLogsList\x12B\n" +
	"\tAddFolder\x12\x1d.Scailo.VaultFolderAddRequest\x1a\x16.Scailo.IdentifierUUID\x12J\n" +
	"\n" +
	"MoveFolder\x12$.Scailo.VaultFolderMoveFolderRequest\x1a\x16.Scailo.IdentifierUUID\x12N\n" +
	"\fRenameFolder\x12&.Scailo.VaultFolderRenameFolderRequest\x1a\x16.Scailo.IdentifierUUID\x12>\n" +
	"\fDeleteFolder\x12\x16.Scailo.IdentifierUUID\x1a\x16.Scailo.IdentifierUUID\x12;\n" +
	"\tZipFolder\x12\x16.Scailo.IdentifierUUID\x1a\x16.Scailo.IdentifierUUID\x12P\n" +
	"\x13AddFolderPermission\x12!.Scailo.VaultPermissionAddRequest\x1a\x16.Scailo.IdentifierUUID\x12V\n" +
	"\x16ModifyFolderPermission\x12$.Scailo.VaultPermissionModifyRequest\x1a\x16.Scailo.IdentifierUUID\x12H\n" +
	"\x16DeleteFolderPermission\x12\x16.Scailo.IdentifierUUID\x1a\x16.Scailo.IdentifierUUID\x12A\n" +
	"\x0eViewFolderByID\x12\x1a.Scailo.IdentifierZeroable\x1a\x13.Scailo.VaultFolder\x12?\n" +
	"\x10ViewFolderByUUID\x12\x16.Scailo.IdentifierUUID\x1a\x13.Scailo.VaultFolder\x12O\n" +
	"\x18ViewFolderDownloadStatus\x12\x16.Scailo.IdentifierUUID\x1a\x1b.Scailo.VaultFolderDownload\x12>\n" +
	"\x0eDownloadFolder\x12\x16.Scailo.IdentifierUUID\x1a\x14.Scailo.StandardFile\x12M\n" +
	"\x1bViewAccessibleFilesInFolder\x12\x16.Scailo.IdentifierUUID\x1a\x16.Scailo.VaultFilesList\x12Q\n" +
	"\x1dViewAccessibleFoldersInFolder\x12\x16.Scailo.IdentifierUUID\x1a\x18.Scailo.VaultFoldersList\x12U\n" +
	"\x1fViewAccessibleResourcesInFolder\x12\x16.Scailo.IdentifierUUID\x1a\x1a.Scailo.VaultResourcesList\x12G\n" +
	"\x14ViewFolderPermission\x12\x16.Scailo.IdentifierUUID\x1a\x17.Scailo.VaultPermission\x12J\n" +
	"\x0fDoesFolderExist\x12\x1e.Scailo.VaultDuplicateCheckReq\x1a\x17.Scailo.BooleanResponse\x12K\n" +
	"\x14ViewFolderAccessLogs\x12\x16.Scailo.IdentifierUUID\x1a\x1b.Scailo.VaultAccessLogsList\x12J\n" +
	"\x1dViewPassthroughRolesForFolder\x12\x16.Scailo.IdentifierUUID\x1a\x11.Scailo.RolesList\x12B\n" +
	"\x06Search\x12\x16.Scailo.VaultSearchReq\x1a .Scailo.VaultSearchResponsesList\x125\n" +
	"\bSetupGiX\x12\x16.Scailo.IdentifierUUID\x1a\x11.Scailo.GiXAppRun\x12J\n" +
	"\x0eGiXRelayDELETE\x12\x1e.Scailo.GiXRelayReqWithoutBody\x1a\x18.Scailo.GiXRelayResponse\x12G\n" +
	"\vGiXRelayGET\x12\x1e.Scailo.GiXRelayReqWithoutBody\x1a\x18.Scailo.GiXRelayResponse\x12H\n" +
	"\fGiXRelayHEAD\x12\x1e.Scailo.GiXRelayReqWithoutBody\x1a\x18.Scailo.GiXRelayResponse\x12F\n" +
	"\rGiXRelayPATCH\x12\x1b.Scailo.GiXRelayReqWithBody\x1a\x18.Scailo.GiXRelayResponse\x12E\n" +
	"\fGiXRelayPOST\x12\x1b.Scailo.GiXRelayReqWithBody\x1a\x18.Scailo.GiXRelayResponse\x12D\n" +
	"\vGiXRelayPUT\x12\x1b.Scailo.GiXRelayReqWithBody\x1a\x18.Scailo.GiXRelayResponse\x12?\n" +
	"\tGiXFilter\x12\x1a.Scailo.GiXAppRunFilterReq\x1a\x16.Scailo.GiXAppRunsList\x12<\n" +
	"\bGiXCount\x12\x19.Scailo.GiXAppRunCountReq\x1a\x15.Scailo.CountResponseBb\n" +
	"\n" +
	"com.ScailoB\x10VaultScailoProtoP\x01Z\n" +
	"Scailo/sdk\xa2\x02\x03SXX\xaa\x02\x06Scailo\xca\x02\x06Scailo\xe2\x02\x12Scailo\\GPBMetadata\xea\x02\x06Scailob\x06proto3"

var (
	file_vault_scailo_proto_rawDescOnce sync.Once
	file_vault_scailo_proto_rawDescData []byte
)

func file_vault_scailo_proto_rawDescGZIP() []byte {
	file_vault_scailo_proto_rawDescOnce.Do(func() {
		file_vault_scailo_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_vault_scailo_proto_rawDesc), len(file_vault_scailo_proto_rawDesc)))
	})
	return file_vault_scailo_proto_rawDescData
}

var file_vault_scailo_proto_msgTypes = make([]protoimpl.MessageInfo, 5)
var file_vault_scailo_proto_goTypes = []any{
	(*VaultResourcesList)(nil),             // 0: Scailo.VaultResourcesList
	(*GiXRelayHeader)(nil),                 // 1: Scailo.GiXRelayHeader
	(*GiXRelayReqWithoutBody)(nil),         // 2: Scailo.GiXRelayReqWithoutBody
	(*GiXRelayReqWithBody)(nil),            // 3: Scailo.GiXRelayReqWithBody
	(*GiXRelayResponse)(nil),               // 4: Scailo.GiXRelayResponse
	(*VaultFile)(nil),                      // 5: Scailo.VaultFile
	(*VaultFolder)(nil),                    // 6: Scailo.VaultFolder
	(*VaultFileInitiateFileRequest)(nil),   // 7: Scailo.VaultFileInitiateFileRequest
	(*VaultFileAddChunkRequest)(nil),       // 8: Scailo.VaultFileAddChunkRequest
	(*IdentifierUUID)(nil),                 // 9: Scailo.IdentifierUUID
	(*VaultFileRenameFileRequest)(nil),     // 10: Scailo.VaultFileRenameFileRequest
	(*VaultFileUnzipRequest)(nil),          // 11: Scailo.VaultFileUnzipRequest
	(*VaultFileMoveFileRequest)(nil),       // 12: Scailo.VaultFileMoveFileRequest
	(*VaultPermissionAddRequest)(nil),      // 13: Scailo.VaultPermissionAddRequest
	(*VaultPermissionModifyRequest)(nil),   // 14: Scailo.VaultPermissionModifyRequest
	(*Identifier)(nil),                     // 15: Scailo.Identifier
	(*VaultDuplicateCheckReq)(nil),         // 16: Scailo.VaultDuplicateCheckReq
	(*VaultFolderAddRequest)(nil),          // 17: Scailo.VaultFolderAddRequest
	(*VaultFolderMoveFolderRequest)(nil),   // 18: Scailo.VaultFolderMoveFolderRequest
	(*VaultFolderRenameFolderRequest)(nil), // 19: Scailo.VaultFolderRenameFolderRequest
	(*IdentifierZeroable)(nil),             // 20: Scailo.IdentifierZeroable
	(*VaultSearchReq)(nil),                 // 21: Scailo.VaultSearchReq
	(*GiXAppRunFilterReq)(nil),             // 22: Scailo.GiXAppRunFilterReq
	(*GiXAppRunCountReq)(nil),              // 23: Scailo.GiXAppRunCountReq
	(*VaultFileInitiateFileResponse)(nil),  // 24: Scailo.VaultFileInitiateFileResponse
	(*StandardFile)(nil),                   // 25: Scailo.StandardFile
	(*VaultFileVersionChunk)(nil),          // 26: Scailo.VaultFileVersionChunk
	(*VaultPermission)(nil),                // 27: Scailo.VaultPermission
	(*BooleanResponse)(nil),                // 28: Scailo.BooleanResponse
	(*VaultFileVersionsList)(nil),          // 29: Scailo.VaultFileVersionsList
	(*VaultAccessLogsList)(nil),            // 30: Scailo.VaultAccessLogsList
	(*VaultFolderDownload)(nil),            // 31: Scailo.VaultFolderDownload
	(*VaultFilesList)(nil),                 // 32: Scailo.VaultFilesList
	(*VaultFoldersList)(nil),               // 33: Scailo.VaultFoldersList
	(*RolesList)(nil),                      // 34: Scailo.RolesList
	(*VaultSearchResponsesList)(nil),       // 35: Scailo.VaultSearchResponsesList
	(*GiXAppRun)(nil),                      // 36: Scailo.GiXAppRun
	(*GiXAppRunsList)(nil),                 // 37: Scailo.GiXAppRunsList
	(*CountResponse)(nil),                  // 38: Scailo.CountResponse
}
var file_vault_scailo_proto_depIdxs = []int32{
	5,  // 0: Scailo.VaultResourcesList.files:type_name -> Scailo.VaultFile
	6,  // 1: Scailo.VaultResourcesList.folders:type_name -> Scailo.VaultFolder
	1,  // 2: Scailo.GiXRelayReqWithoutBody.relay_headers:type_name -> Scailo.GiXRelayHeader
	1,  // 3: Scailo.GiXRelayReqWithBody.relay_headers:type_name -> Scailo.GiXRelayHeader
	7,  // 4: Scailo.VaultService.InitiateFile:input_type -> Scailo.VaultFileInitiateFileRequest
	8,  // 5: Scailo.VaultService.AddFileChunk:input_type -> Scailo.VaultFileAddChunkRequest
	9,  // 6: Scailo.VaultService.CompleteFile:input_type -> Scailo.IdentifierUUID
	10, // 7: Scailo.VaultService.RenameFile:input_type -> Scailo.VaultFileRenameFileRequest
	11, // 8: Scailo.VaultService.UnzipFile:input_type -> Scailo.VaultFileUnzipRequest
	9,  // 9: Scailo.VaultService.PersistFile:input_type -> Scailo.IdentifierUUID
	12, // 10: Scailo.VaultService.MoveFile:input_type -> Scailo.VaultFileMoveFileRequest
	9,  // 11: Scailo.VaultService.DeleteFile:input_type -> Scailo.IdentifierUUID
	13, // 12: Scailo.VaultService.AddFilePermission:input_type -> Scailo.VaultPermissionAddRequest
	14, // 13: Scailo.VaultService.ModifyFilePermission:input_type -> Scailo.VaultPermissionModifyRequest
	9,  // 14: Scailo.VaultService.DeleteFilePermission:input_type -> Scailo.IdentifierUUID
	9,  // 15: Scailo.VaultService.DownloadFile:input_type -> Scailo.IdentifierUUID
	9,  // 16: Scailo.VaultService.DownloadFileVersion:input_type -> Scailo.IdentifierUUID
	9,  // 17: Scailo.VaultService.ViewFileLogo:input_type -> Scailo.IdentifierUUID
	9,  // 18: Scailo.VaultService.ViewFileByUUID:input_type -> Scailo.IdentifierUUID
	15, // 19: Scailo.VaultService.ViewFileByID:input_type -> Scailo.Identifier
	9,  // 20: Scailo.VaultService.ViewFileChunk:input_type -> Scailo.IdentifierUUID
	9,  // 21: Scailo.VaultService.ViewFileChunkMetadata:input_type -> Scailo.IdentifierUUID
	9,  // 22: Scailo.VaultService.ViewFilePermission:input_type -> Scailo.IdentifierUUID
	16, // 23: Scailo.VaultService.DoesFileExist:input_type -> Scailo.VaultDuplicateCheckReq
	9,  // 24: Scailo.VaultService.ViewFileVersions:input_type -> Scailo.IdentifierUUID
	9,  // 25: Scailo.VaultService.ViewFileAccessLogs:input_type -> Scailo.IdentifierUUID
	17, // 26: Scailo.VaultService.AddFolder:input_type -> Scailo.VaultFolderAddRequest
	18, // 27: Scailo.VaultService.MoveFolder:input_type -> Scailo.VaultFolderMoveFolderRequest
	19, // 28: Scailo.VaultService.RenameFolder:input_type -> Scailo.VaultFolderRenameFolderRequest
	9,  // 29: Scailo.VaultService.DeleteFolder:input_type -> Scailo.IdentifierUUID
	9,  // 30: Scailo.VaultService.ZipFolder:input_type -> Scailo.IdentifierUUID
	13, // 31: Scailo.VaultService.AddFolderPermission:input_type -> Scailo.VaultPermissionAddRequest
	14, // 32: Scailo.VaultService.ModifyFolderPermission:input_type -> Scailo.VaultPermissionModifyRequest
	9,  // 33: Scailo.VaultService.DeleteFolderPermission:input_type -> Scailo.IdentifierUUID
	20, // 34: Scailo.VaultService.ViewFolderByID:input_type -> Scailo.IdentifierZeroable
	9,  // 35: Scailo.VaultService.ViewFolderByUUID:input_type -> Scailo.IdentifierUUID
	9,  // 36: Scailo.VaultService.ViewFolderDownloadStatus:input_type -> Scailo.IdentifierUUID
	9,  // 37: Scailo.VaultService.DownloadFolder:input_type -> Scailo.IdentifierUUID
	9,  // 38: Scailo.VaultService.ViewAccessibleFilesInFolder:input_type -> Scailo.IdentifierUUID
	9,  // 39: Scailo.VaultService.ViewAccessibleFoldersInFolder:input_type -> Scailo.IdentifierUUID
	9,  // 40: Scailo.VaultService.ViewAccessibleResourcesInFolder:input_type -> Scailo.IdentifierUUID
	9,  // 41: Scailo.VaultService.ViewFolderPermission:input_type -> Scailo.IdentifierUUID
	16, // 42: Scailo.VaultService.DoesFolderExist:input_type -> Scailo.VaultDuplicateCheckReq
	9,  // 43: Scailo.VaultService.ViewFolderAccessLogs:input_type -> Scailo.IdentifierUUID
	9,  // 44: Scailo.VaultService.ViewPassthroughRolesForFolder:input_type -> Scailo.IdentifierUUID
	21, // 45: Scailo.VaultService.Search:input_type -> Scailo.VaultSearchReq
	9,  // 46: Scailo.VaultService.SetupGiX:input_type -> Scailo.IdentifierUUID
	2,  // 47: Scailo.VaultService.GiXRelayDELETE:input_type -> Scailo.GiXRelayReqWithoutBody
	2,  // 48: Scailo.VaultService.GiXRelayGET:input_type -> Scailo.GiXRelayReqWithoutBody
	2,  // 49: Scailo.VaultService.GiXRelayHEAD:input_type -> Scailo.GiXRelayReqWithoutBody
	3,  // 50: Scailo.VaultService.GiXRelayPATCH:input_type -> Scailo.GiXRelayReqWithBody
	3,  // 51: Scailo.VaultService.GiXRelayPOST:input_type -> Scailo.GiXRelayReqWithBody
	3,  // 52: Scailo.VaultService.GiXRelayPUT:input_type -> Scailo.GiXRelayReqWithBody
	22, // 53: Scailo.VaultService.GiXFilter:input_type -> Scailo.GiXAppRunFilterReq
	23, // 54: Scailo.VaultService.GiXCount:input_type -> Scailo.GiXAppRunCountReq
	24, // 55: Scailo.VaultService.InitiateFile:output_type -> Scailo.VaultFileInitiateFileResponse
	9,  // 56: Scailo.VaultService.AddFileChunk:output_type -> Scailo.IdentifierUUID
	9,  // 57: Scailo.VaultService.CompleteFile:output_type -> Scailo.IdentifierUUID
	9,  // 58: Scailo.VaultService.RenameFile:output_type -> Scailo.IdentifierUUID
	9,  // 59: Scailo.VaultService.UnzipFile:output_type -> Scailo.IdentifierUUID
	9,  // 60: Scailo.VaultService.PersistFile:output_type -> Scailo.IdentifierUUID
	9,  // 61: Scailo.VaultService.MoveFile:output_type -> Scailo.IdentifierUUID
	9,  // 62: Scailo.VaultService.DeleteFile:output_type -> Scailo.IdentifierUUID
	9,  // 63: Scailo.VaultService.AddFilePermission:output_type -> Scailo.IdentifierUUID
	9,  // 64: Scailo.VaultService.ModifyFilePermission:output_type -> Scailo.IdentifierUUID
	9,  // 65: Scailo.VaultService.DeleteFilePermission:output_type -> Scailo.IdentifierUUID
	25, // 66: Scailo.VaultService.DownloadFile:output_type -> Scailo.StandardFile
	25, // 67: Scailo.VaultService.DownloadFileVersion:output_type -> Scailo.StandardFile
	25, // 68: Scailo.VaultService.ViewFileLogo:output_type -> Scailo.StandardFile
	5,  // 69: Scailo.VaultService.ViewFileByUUID:output_type -> Scailo.VaultFile
	5,  // 70: Scailo.VaultService.ViewFileByID:output_type -> Scailo.VaultFile
	26, // 71: Scailo.VaultService.ViewFileChunk:output_type -> Scailo.VaultFileVersionChunk
	26, // 72: Scailo.VaultService.ViewFileChunkMetadata:output_type -> Scailo.VaultFileVersionChunk
	27, // 73: Scailo.VaultService.ViewFilePermission:output_type -> Scailo.VaultPermission
	28, // 74: Scailo.VaultService.DoesFileExist:output_type -> Scailo.BooleanResponse
	29, // 75: Scailo.VaultService.ViewFileVersions:output_type -> Scailo.VaultFileVersionsList
	30, // 76: Scailo.VaultService.ViewFileAccessLogs:output_type -> Scailo.VaultAccessLogsList
	9,  // 77: Scailo.VaultService.AddFolder:output_type -> Scailo.IdentifierUUID
	9,  // 78: Scailo.VaultService.MoveFolder:output_type -> Scailo.IdentifierUUID
	9,  // 79: Scailo.VaultService.RenameFolder:output_type -> Scailo.IdentifierUUID
	9,  // 80: Scailo.VaultService.DeleteFolder:output_type -> Scailo.IdentifierUUID
	9,  // 81: Scailo.VaultService.ZipFolder:output_type -> Scailo.IdentifierUUID
	9,  // 82: Scailo.VaultService.AddFolderPermission:output_type -> Scailo.IdentifierUUID
	9,  // 83: Scailo.VaultService.ModifyFolderPermission:output_type -> Scailo.IdentifierUUID
	9,  // 84: Scailo.VaultService.DeleteFolderPermission:output_type -> Scailo.IdentifierUUID
	6,  // 85: Scailo.VaultService.ViewFolderByID:output_type -> Scailo.VaultFolder
	6,  // 86: Scailo.VaultService.ViewFolderByUUID:output_type -> Scailo.VaultFolder
	31, // 87: Scailo.VaultService.ViewFolderDownloadStatus:output_type -> Scailo.VaultFolderDownload
	25, // 88: Scailo.VaultService.DownloadFolder:output_type -> Scailo.StandardFile
	32, // 89: Scailo.VaultService.ViewAccessibleFilesInFolder:output_type -> Scailo.VaultFilesList
	33, // 90: Scailo.VaultService.ViewAccessibleFoldersInFolder:output_type -> Scailo.VaultFoldersList
	0,  // 91: Scailo.VaultService.ViewAccessibleResourcesInFolder:output_type -> Scailo.VaultResourcesList
	27, // 92: Scailo.VaultService.ViewFolderPermission:output_type -> Scailo.VaultPermission
	28, // 93: Scailo.VaultService.DoesFolderExist:output_type -> Scailo.BooleanResponse
	30, // 94: Scailo.VaultService.ViewFolderAccessLogs:output_type -> Scailo.VaultAccessLogsList
	34, // 95: Scailo.VaultService.ViewPassthroughRolesForFolder:output_type -> Scailo.RolesList
	35, // 96: Scailo.VaultService.Search:output_type -> Scailo.VaultSearchResponsesList
	36, // 97: Scailo.VaultService.SetupGiX:output_type -> Scailo.GiXAppRun
	4,  // 98: Scailo.VaultService.GiXRelayDELETE:output_type -> Scailo.GiXRelayResponse
	4,  // 99: Scailo.VaultService.GiXRelayGET:output_type -> Scailo.GiXRelayResponse
	4,  // 100: Scailo.VaultService.GiXRelayHEAD:output_type -> Scailo.GiXRelayResponse
	4,  // 101: Scailo.VaultService.GiXRelayPATCH:output_type -> Scailo.GiXRelayResponse
	4,  // 102: Scailo.VaultService.GiXRelayPOST:output_type -> Scailo.GiXRelayResponse
	4,  // 103: Scailo.VaultService.GiXRelayPUT:output_type -> Scailo.GiXRelayResponse
	37, // 104: Scailo.VaultService.GiXFilter:output_type -> Scailo.GiXAppRunsList
	38, // 105: Scailo.VaultService.GiXCount:output_type -> Scailo.CountResponse
	55, // [55:106] is the sub-list for method output_type
	4,  // [4:55] is the sub-list for method input_type
	4,  // [4:4] is the sub-list for extension type_name
	4,  // [4:4] is the sub-list for extension extendee
	0,  // [0:4] is the sub-list for field type_name
}

func init() { file_vault_scailo_proto_init() }
func file_vault_scailo_proto_init() {
	if File_vault_scailo_proto != nil {
		return
	}
	file_base_scailo_proto_init()
	file_roles_scailo_proto_init()
	file_vault_commons_scailo_proto_init()
	file_vault_files_scailo_proto_init()
	file_vault_folders_scailo_proto_init()
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_vault_scailo_proto_rawDesc), len(file_vault_scailo_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   5,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_vault_scailo_proto_goTypes,
		DependencyIndexes: file_vault_scailo_proto_depIdxs,
		MessageInfos:      file_vault_scailo_proto_msgTypes,
	}.Build()
	File_vault_scailo_proto = out.File
	file_vault_scailo_proto_goTypes = nil
	file_vault_scailo_proto_depIdxs = nil
}
