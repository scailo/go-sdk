// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.8
// 	protoc        (unknown)
// source: vault_commons.scailo.proto

package sdk

import (
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"

	_ "buf.build/gen/go/bufbuild/protovalidate/protocolbuffers/go/buf/validate"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Describes the available references for permissions
type VAULT_REF_FOR int32

const (
	// Ignore ref for (can only be used during search APIs)
	VAULT_REF_FOR_VAULT_REF_FOR_ANY_UNSPECIFIED VAULT_REF_FOR = 0
	// Permission refers to a file
	VAULT_REF_FOR_VAULT_REF_FOR_FILE VAULT_REF_FOR = 1
	// Permission refers to a folder
	VAULT_REF_FOR_VAULT_REF_FOR_FOLDER VAULT_REF_FOR = 2
)

// Enum value maps for VAULT_REF_FOR.
var (
	VAULT_REF_FOR_name = map[int32]string{
		0: "VAULT_REF_FOR_ANY_UNSPECIFIED",
		1: "VAULT_REF_FOR_FILE",
		2: "VAULT_REF_FOR_FOLDER",
	}
	VAULT_REF_FOR_value = map[string]int32{
		"VAULT_REF_FOR_ANY_UNSPECIFIED": 0,
		"VAULT_REF_FOR_FILE":            1,
		"VAULT_REF_FOR_FOLDER":          2,
	}
)

func (x VAULT_REF_FOR) Enum() *VAULT_REF_FOR {
	p := new(VAULT_REF_FOR)
	*p = x
	return p
}

func (x VAULT_REF_FOR) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (VAULT_REF_FOR) Descriptor() protoreflect.EnumDescriptor {
	return file_vault_commons_scailo_proto_enumTypes[0].Descriptor()
}

func (VAULT_REF_FOR) Type() protoreflect.EnumType {
	return &file_vault_commons_scailo_proto_enumTypes[0]
}

func (x VAULT_REF_FOR) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use VAULT_REF_FOR.Descriptor instead.
func (VAULT_REF_FOR) EnumDescriptor() ([]byte, []int) {
	return file_vault_commons_scailo_proto_rawDescGZIP(), []int{0}
}

// Describes the available permission codes
type VAULT_PERMISSION_CODE int32

const (
	// Stores the default value
	VAULT_PERMISSION_CODE_VAULT_PERMISSION_CODE_UNSPECIFIED VAULT_PERMISSION_CODE = 0
	// Stores the bit weight of the view permission (value is 2^0 = 1)
	VAULT_PERMISSION_CODE_VAULT_PERMISSION_CODE_VIEW VAULT_PERMISSION_CODE = 1
	// Stores the bit weight of the meta permission (value is 2^1 = 2)
	VAULT_PERMISSION_CODE_VAULT_PERMISSION_CODE_META VAULT_PERMISSION_CODE = 2
	// Stores the bit weight of the download permission (value is 2^2 = 4)
	VAULT_PERMISSION_CODE_VAULT_PERMISSION_CODE_DOWNLOAD VAULT_PERMISSION_CODE = 4
	// Stores the bit weight of the add permission (value is 2^3 = 8)
	VAULT_PERMISSION_CODE_VAULT_PERMISSION_CODE_ADD VAULT_PERMISSION_CODE = 8
	// Stores the bit weight of the delete permission (value is 2^4 = 16)
	VAULT_PERMISSION_CODE_VAULT_PERMISSION_CODE_DELETE VAULT_PERMISSION_CODE = 16
	// Stores the bit weight of the execute permission (value is 2^5 = 32)
	VAULT_PERMISSION_CODE_VAULT_PERMISSION_CODE_EXECUTE VAULT_PERMISSION_CODE = 32
	// Stores the bit weight of all the available permissions (value is 2^6 = 64 - 1)
	VAULT_PERMISSION_CODE_VAULT_PERMISSION_CODE_ALL VAULT_PERMISSION_CODE = 63
)

// Enum value maps for VAULT_PERMISSION_CODE.
var (
	VAULT_PERMISSION_CODE_name = map[int32]string{
		0:  "VAULT_PERMISSION_CODE_UNSPECIFIED",
		1:  "VAULT_PERMISSION_CODE_VIEW",
		2:  "VAULT_PERMISSION_CODE_META",
		4:  "VAULT_PERMISSION_CODE_DOWNLOAD",
		8:  "VAULT_PERMISSION_CODE_ADD",
		16: "VAULT_PERMISSION_CODE_DELETE",
		32: "VAULT_PERMISSION_CODE_EXECUTE",
		63: "VAULT_PERMISSION_CODE_ALL",
	}
	VAULT_PERMISSION_CODE_value = map[string]int32{
		"VAULT_PERMISSION_CODE_UNSPECIFIED": 0,
		"VAULT_PERMISSION_CODE_VIEW":        1,
		"VAULT_PERMISSION_CODE_META":        2,
		"VAULT_PERMISSION_CODE_DOWNLOAD":    4,
		"VAULT_PERMISSION_CODE_ADD":         8,
		"VAULT_PERMISSION_CODE_DELETE":      16,
		"VAULT_PERMISSION_CODE_EXECUTE":     32,
		"VAULT_PERMISSION_CODE_ALL":         63,
	}
)

func (x VAULT_PERMISSION_CODE) Enum() *VAULT_PERMISSION_CODE {
	p := new(VAULT_PERMISSION_CODE)
	*p = x
	return p
}

func (x VAULT_PERMISSION_CODE) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (VAULT_PERMISSION_CODE) Descriptor() protoreflect.EnumDescriptor {
	return file_vault_commons_scailo_proto_enumTypes[1].Descriptor()
}

func (VAULT_PERMISSION_CODE) Type() protoreflect.EnumType {
	return &file_vault_commons_scailo_proto_enumTypes[1]
}

func (x VAULT_PERMISSION_CODE) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use VAULT_PERMISSION_CODE.Descriptor instead.
func (VAULT_PERMISSION_CODE) EnumDescriptor() ([]byte, []int) {
	return file_vault_commons_scailo_proto_rawDescGZIP(), []int{1}
}

// Describes the available sort keys for enclave domains
type ENCLAVE_DOMAIN_SORT_KEY int32

const (
	// Fetch ordered results by id
	ENCLAVE_DOMAIN_SORT_KEY_ENCLAVE_DOMAIN_SORT_KEY_ID_UNSPECIFIED ENCLAVE_DOMAIN_SORT_KEY = 0
	// Fetch ordered results by the creation timestamp
	ENCLAVE_DOMAIN_SORT_KEY_ENCLAVE_DOMAIN_SORT_KEY_CREATED_AT ENCLAVE_DOMAIN_SORT_KEY = 1
	// Fetch ordered results by the domain
	ENCLAVE_DOMAIN_SORT_KEY_ENCLAVE_DOMAIN_SORT_KEY_DOMAIN ENCLAVE_DOMAIN_SORT_KEY = 10
)

// Enum value maps for ENCLAVE_DOMAIN_SORT_KEY.
var (
	ENCLAVE_DOMAIN_SORT_KEY_name = map[int32]string{
		0:  "ENCLAVE_DOMAIN_SORT_KEY_ID_UNSPECIFIED",
		1:  "ENCLAVE_DOMAIN_SORT_KEY_CREATED_AT",
		10: "ENCLAVE_DOMAIN_SORT_KEY_DOMAIN",
	}
	ENCLAVE_DOMAIN_SORT_KEY_value = map[string]int32{
		"ENCLAVE_DOMAIN_SORT_KEY_ID_UNSPECIFIED": 0,
		"ENCLAVE_DOMAIN_SORT_KEY_CREATED_AT":     1,
		"ENCLAVE_DOMAIN_SORT_KEY_DOMAIN":         10,
	}
)

func (x ENCLAVE_DOMAIN_SORT_KEY) Enum() *ENCLAVE_DOMAIN_SORT_KEY {
	p := new(ENCLAVE_DOMAIN_SORT_KEY)
	*p = x
	return p
}

func (x ENCLAVE_DOMAIN_SORT_KEY) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ENCLAVE_DOMAIN_SORT_KEY) Descriptor() protoreflect.EnumDescriptor {
	return file_vault_commons_scailo_proto_enumTypes[2].Descriptor()
}

func (ENCLAVE_DOMAIN_SORT_KEY) Type() protoreflect.EnumType {
	return &file_vault_commons_scailo_proto_enumTypes[2]
}

func (x ENCLAVE_DOMAIN_SORT_KEY) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ENCLAVE_DOMAIN_SORT_KEY.Descriptor instead.
func (ENCLAVE_DOMAIN_SORT_KEY) EnumDescriptor() ([]byte, []int) {
	return file_vault_commons_scailo_proto_rawDescGZIP(), []int{2}
}

// Describes the available sort keys
type VAULT_SORT_KEY int32

const (
	// Fetch ordered results by id
	VAULT_SORT_KEY_VAULT_SORT_KEY_ID_UNSPECIFIED VAULT_SORT_KEY = 0
	// Fetch ordered results by the creation timestamp
	VAULT_SORT_KEY_VAULT_SORT_KEY_CREATED_AT VAULT_SORT_KEY = 1
	// Fetch ordered results by the modified timestamp
	VAULT_SORT_KEY_VAULT_SORT_KEY_MODIFIED_AT VAULT_SORT_KEY = 2
	// Fetch ordered results by the name
	VAULT_SORT_KEY_VAULT_SORT_KEY_NAME VAULT_SORT_KEY = 10
)

// Enum value maps for VAULT_SORT_KEY.
var (
	VAULT_SORT_KEY_name = map[int32]string{
		0:  "VAULT_SORT_KEY_ID_UNSPECIFIED",
		1:  "VAULT_SORT_KEY_CREATED_AT",
		2:  "VAULT_SORT_KEY_MODIFIED_AT",
		10: "VAULT_SORT_KEY_NAME",
	}
	VAULT_SORT_KEY_value = map[string]int32{
		"VAULT_SORT_KEY_ID_UNSPECIFIED": 0,
		"VAULT_SORT_KEY_CREATED_AT":     1,
		"VAULT_SORT_KEY_MODIFIED_AT":    2,
		"VAULT_SORT_KEY_NAME":           10,
	}
)

func (x VAULT_SORT_KEY) Enum() *VAULT_SORT_KEY {
	p := new(VAULT_SORT_KEY)
	*p = x
	return p
}

func (x VAULT_SORT_KEY) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (VAULT_SORT_KEY) Descriptor() protoreflect.EnumDescriptor {
	return file_vault_commons_scailo_proto_enumTypes[3].Descriptor()
}

func (VAULT_SORT_KEY) Type() protoreflect.EnumType {
	return &file_vault_commons_scailo_proto_enumTypes[3]
}

func (x VAULT_SORT_KEY) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use VAULT_SORT_KEY.Descriptor instead.
func (VAULT_SORT_KEY) EnumDescriptor() ([]byte, []int) {
	return file_vault_commons_scailo_proto_rawDescGZIP(), []int{3}
}

// Describes the available access log operations
type VAULT_ACCESS_LOG_OPERATION int32

const (
	// Ignore operation (useful only for search APIs)
	VAULT_ACCESS_LOG_OPERATION_VAULT_ACCESS_LOG_OPERATION_ANY_UNSPECIFIED VAULT_ACCESS_LOG_OPERATION = 0
	// Denotes that the user has created the resource
	VAULT_ACCESS_LOG_OPERATION_VAULT_ACCESS_LOG_OPERATION_CREATE VAULT_ACCESS_LOG_OPERATION = 1
	// Denotes that the user has moved the resource
	VAULT_ACCESS_LOG_OPERATION_VAULT_ACCESS_LOG_OPERATION_MOVE VAULT_ACCESS_LOG_OPERATION = 2
	// Denotes that the user has renamed the resource
	VAULT_ACCESS_LOG_OPERATION_VAULT_ACCESS_LOG_OPERATION_RENAME VAULT_ACCESS_LOG_OPERATION = 3
	// Denotes that the user has deleted the resource
	VAULT_ACCESS_LOG_OPERATION_VAULT_ACCESS_LOG_OPERATION_DELETE VAULT_ACCESS_LOG_OPERATION = 4
	// Denotes that the user has downloaded the resource
	VAULT_ACCESS_LOG_OPERATION_VAULT_ACCESS_LOG_OPERATION_DOWNLOAD VAULT_ACCESS_LOG_OPERATION = 5
	// Denotes that the user has uploaded the resource
	VAULT_ACCESS_LOG_OPERATION_VAULT_ACCESS_LOG_OPERATION_UPLOAD VAULT_ACCESS_LOG_OPERATION = 6
	// Denotes that the user has begun unzipping the resource
	VAULT_ACCESS_LOG_OPERATION_VAULT_ACCESS_LOG_OPERATION_UNZIP VAULT_ACCESS_LOG_OPERATION = 7
	// Denotes that the user has marked the resource as persistent
	VAULT_ACCESS_LOG_OPERATION_VAULT_ACCESS_LOG_OPERATION_PERSISTENT VAULT_ACCESS_LOG_OPERATION = 8
	// Denotes that the user is updating the permissions to a resource
	VAULT_ACCESS_LOG_OPERATION_VAULT_ACCESS_LOG_OPERATION_PERMISSIONS VAULT_ACCESS_LOG_OPERATION = 9
	// Denotes that the user is executing the resource (most likely a GiX app)
	VAULT_ACCESS_LOG_OPERATION_VAULT_ACCESS_LOG_OPERATION_EXECUTE VAULT_ACCESS_LOG_OPERATION = 10
)

// Enum value maps for VAULT_ACCESS_LOG_OPERATION.
var (
	VAULT_ACCESS_LOG_OPERATION_name = map[int32]string{
		0:  "VAULT_ACCESS_LOG_OPERATION_ANY_UNSPECIFIED",
		1:  "VAULT_ACCESS_LOG_OPERATION_CREATE",
		2:  "VAULT_ACCESS_LOG_OPERATION_MOVE",
		3:  "VAULT_ACCESS_LOG_OPERATION_RENAME",
		4:  "VAULT_ACCESS_LOG_OPERATION_DELETE",
		5:  "VAULT_ACCESS_LOG_OPERATION_DOWNLOAD",
		6:  "VAULT_ACCESS_LOG_OPERATION_UPLOAD",
		7:  "VAULT_ACCESS_LOG_OPERATION_UNZIP",
		8:  "VAULT_ACCESS_LOG_OPERATION_PERSISTENT",
		9:  "VAULT_ACCESS_LOG_OPERATION_PERMISSIONS",
		10: "VAULT_ACCESS_LOG_OPERATION_EXECUTE",
	}
	VAULT_ACCESS_LOG_OPERATION_value = map[string]int32{
		"VAULT_ACCESS_LOG_OPERATION_ANY_UNSPECIFIED": 0,
		"VAULT_ACCESS_LOG_OPERATION_CREATE":          1,
		"VAULT_ACCESS_LOG_OPERATION_MOVE":            2,
		"VAULT_ACCESS_LOG_OPERATION_RENAME":          3,
		"VAULT_ACCESS_LOG_OPERATION_DELETE":          4,
		"VAULT_ACCESS_LOG_OPERATION_DOWNLOAD":        5,
		"VAULT_ACCESS_LOG_OPERATION_UPLOAD":          6,
		"VAULT_ACCESS_LOG_OPERATION_UNZIP":           7,
		"VAULT_ACCESS_LOG_OPERATION_PERSISTENT":      8,
		"VAULT_ACCESS_LOG_OPERATION_PERMISSIONS":     9,
		"VAULT_ACCESS_LOG_OPERATION_EXECUTE":         10,
	}
)

func (x VAULT_ACCESS_LOG_OPERATION) Enum() *VAULT_ACCESS_LOG_OPERATION {
	p := new(VAULT_ACCESS_LOG_OPERATION)
	*p = x
	return p
}

func (x VAULT_ACCESS_LOG_OPERATION) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (VAULT_ACCESS_LOG_OPERATION) Descriptor() protoreflect.EnumDescriptor {
	return file_vault_commons_scailo_proto_enumTypes[4].Descriptor()
}

func (VAULT_ACCESS_LOG_OPERATION) Type() protoreflect.EnumType {
	return &file_vault_commons_scailo_proto_enumTypes[4]
}

func (x VAULT_ACCESS_LOG_OPERATION) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use VAULT_ACCESS_LOG_OPERATION.Descriptor instead.
func (VAULT_ACCESS_LOG_OPERATION) EnumDescriptor() ([]byte, []int) {
	return file_vault_commons_scailo_proto_rawDescGZIP(), []int{4}
}

// Describes the parameters of a permission related to a vault file or folder
type VaultPermission struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Stores a globally unique entity UUID. This will be set at the organization level
	EntityUuid string `protobuf:"bytes,1,opt,name=entity_uuid,json=entityUuid,proto3" json:"entity_uuid,omitempty"`
	// Stores the metadata of this user
	Metadata *EmployeeMetadata `protobuf:"bytes,2,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// Stores the reference for which this permission is applicable
	RefFor VAULT_REF_FOR `protobuf:"varint,10,opt,name=ref_for,json=refFor,proto3,enum=Scailo.VAULT_REF_FOR" json:"ref_for,omitempty"`
	// Stores the ID of the underlying file or folder that this permission if applicable for
	RefId uint64 `protobuf:"varint,11,opt,name=ref_id,json=refId,proto3" json:"ref_id,omitempty"`
	// Stores the ID of the role
	RoleId uint64 `protobuf:"varint,12,opt,name=role_id,json=roleId,proto3" json:"role_id,omitempty"`
	// Stores the applicable permissions
	PermissionCode uint64 `protobuf:"varint,13,opt,name=permission_code,json=permissionCode,proto3" json:"permission_code,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *VaultPermission) Reset() {
	*x = VaultPermission{}
	mi := &file_vault_commons_scailo_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VaultPermission) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VaultPermission) ProtoMessage() {}

func (x *VaultPermission) ProtoReflect() protoreflect.Message {
	mi := &file_vault_commons_scailo_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VaultPermission.ProtoReflect.Descriptor instead.
func (*VaultPermission) Descriptor() ([]byte, []int) {
	return file_vault_commons_scailo_proto_rawDescGZIP(), []int{0}
}

func (x *VaultPermission) GetEntityUuid() string {
	if x != nil {
		return x.EntityUuid
	}
	return ""
}

func (x *VaultPermission) GetMetadata() *EmployeeMetadata {
	if x != nil {
		return x.Metadata
	}
	return nil
}

func (x *VaultPermission) GetRefFor() VAULT_REF_FOR {
	if x != nil {
		return x.RefFor
	}
	return VAULT_REF_FOR_VAULT_REF_FOR_ANY_UNSPECIFIED
}

func (x *VaultPermission) GetRefId() uint64 {
	if x != nil {
		return x.RefId
	}
	return 0
}

func (x *VaultPermission) GetRoleId() uint64 {
	if x != nil {
		return x.RoleId
	}
	return 0
}

func (x *VaultPermission) GetPermissionCode() uint64 {
	if x != nil {
		return x.PermissionCode
	}
	return 0
}

// Describes the parameters required to create a vault permission
type VaultPermissionAddRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Stores a globally unique entity UUID. This will be set at the organization level
	EntityUuid string `protobuf:"bytes,1,opt,name=entity_uuid,json=entityUuid,proto3" json:"entity_uuid,omitempty"`
	// Stores any comment that the user might add during this operation
	UserComment string `protobuf:"bytes,2,opt,name=user_comment,json=userComment,proto3" json:"user_comment,omitempty"`
	// Stores the UUID of the underlying file or folder that this permission if applicable for
	RefUuid string `protobuf:"bytes,11,opt,name=ref_uuid,json=refUuid,proto3" json:"ref_uuid,omitempty"`
	// Stores the ID of the role
	RoleId uint64 `protobuf:"varint,12,opt,name=role_id,json=roleId,proto3" json:"role_id,omitempty"`
	// Stores the applicable permissions
	PermissionCode uint64 `protobuf:"varint,13,opt,name=permission_code,json=permissionCode,proto3" json:"permission_code,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *VaultPermissionAddRequest) Reset() {
	*x = VaultPermissionAddRequest{}
	mi := &file_vault_commons_scailo_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VaultPermissionAddRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VaultPermissionAddRequest) ProtoMessage() {}

func (x *VaultPermissionAddRequest) ProtoReflect() protoreflect.Message {
	mi := &file_vault_commons_scailo_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VaultPermissionAddRequest.ProtoReflect.Descriptor instead.
func (*VaultPermissionAddRequest) Descriptor() ([]byte, []int) {
	return file_vault_commons_scailo_proto_rawDescGZIP(), []int{1}
}

func (x *VaultPermissionAddRequest) GetEntityUuid() string {
	if x != nil {
		return x.EntityUuid
	}
	return ""
}

func (x *VaultPermissionAddRequest) GetUserComment() string {
	if x != nil {
		return x.UserComment
	}
	return ""
}

func (x *VaultPermissionAddRequest) GetRefUuid() string {
	if x != nil {
		return x.RefUuid
	}
	return ""
}

func (x *VaultPermissionAddRequest) GetRoleId() uint64 {
	if x != nil {
		return x.RoleId
	}
	return 0
}

func (x *VaultPermissionAddRequest) GetPermissionCode() uint64 {
	if x != nil {
		return x.PermissionCode
	}
	return 0
}

// Describes the parameters required to modify a vault permission
type VaultPermissionModifyRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The UUID of the permission
	Uuid string `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	// Stores any comment that the user might add during this operation
	UserComment string `protobuf:"bytes,2,opt,name=user_comment,json=userComment,proto3" json:"user_comment,omitempty"`
	// Stores the applicable permissions
	PermissionCode uint64 `protobuf:"varint,13,opt,name=permission_code,json=permissionCode,proto3" json:"permission_code,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *VaultPermissionModifyRequest) Reset() {
	*x = VaultPermissionModifyRequest{}
	mi := &file_vault_commons_scailo_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VaultPermissionModifyRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VaultPermissionModifyRequest) ProtoMessage() {}

func (x *VaultPermissionModifyRequest) ProtoReflect() protoreflect.Message {
	mi := &file_vault_commons_scailo_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VaultPermissionModifyRequest.ProtoReflect.Descriptor instead.
func (*VaultPermissionModifyRequest) Descriptor() ([]byte, []int) {
	return file_vault_commons_scailo_proto_rawDescGZIP(), []int{2}
}

func (x *VaultPermissionModifyRequest) GetUuid() string {
	if x != nil {
		return x.Uuid
	}
	return ""
}

func (x *VaultPermissionModifyRequest) GetUserComment() string {
	if x != nil {
		return x.UserComment
	}
	return ""
}

func (x *VaultPermissionModifyRequest) GetPermissionCode() uint64 {
	if x != nil {
		return x.PermissionCode
	}
	return 0
}

// Describes the resources section of a GiX app
type GixResources struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Stores the entry point of the GiX app
	HtmlEntry string `protobuf:"bytes,1,opt,name=html_entry,proto3" json:"html_entry,omitempty"`
	// Stores the list of logos that are available
	Logos []string `protobuf:"bytes,2,rep,name=logos,proto3" json:"logos,omitempty"`
	// Stores the list of external APIs that need to be accessible by the GiX app
	ExternalApis  []string `protobuf:"bytes,3,rep,name=external_apis,proto3" json:"external_apis,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GixResources) Reset() {
	*x = GixResources{}
	mi := &file_vault_commons_scailo_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GixResources) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GixResources) ProtoMessage() {}

func (x *GixResources) ProtoReflect() protoreflect.Message {
	mi := &file_vault_commons_scailo_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GixResources.ProtoReflect.Descriptor instead.
func (*GixResources) Descriptor() ([]byte, []int) {
	return file_vault_commons_scailo_proto_rawDescGZIP(), []int{3}
}

func (x *GixResources) GetHtmlEntry() string {
	if x != nil {
		return x.HtmlEntry
	}
	return ""
}

func (x *GixResources) GetLogos() []string {
	if x != nil {
		return x.Logos
	}
	return nil
}

func (x *GixResources) GetExternalApis() []string {
	if x != nil {
		return x.ExternalApis
	}
	return nil
}

// Describes the manifest file of a GiX app. Stores the attributes that can be a part of the MANIFEST.yaml file, that is present in the root folder of a GiX app
type GiXManifest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Stores the manifest version
	ManifestVersion string `protobuf:"bytes,1,opt,name=manifest_version,proto3" json:"manifest_version,omitempty"`
	// Stores the application version
	AppVersion string `protobuf:"bytes,2,opt,name=app_version,proto3" json:"app_version,omitempty"`
	// Stores the name of the application
	AppName string `protobuf:"bytes,3,opt,name=app_name,proto3" json:"app_name,omitempty"`
	// Stores the unique identifier for the application
	AppUniqueIdentifier string `protobuf:"bytes,4,opt,name=app_unique_identifier,proto3" json:"app_unique_identifier,omitempty"`
	// Stores the minimum version of Scailo that the application supports
	MinGenesisVersion string `protobuf:"bytes,5,opt,name=min_genesis_version,proto3" json:"min_genesis_version,omitempty"`
	// Stores the manimum version of Scailo that the application supports
	MaxGenesisVersion string `protobuf:"bytes,6,opt,name=max_genesis_version,proto3" json:"max_genesis_version,omitempty"`
	// Stores the resources of the GiX application
	Resources     *GixResources `protobuf:"bytes,7,opt,name=resources,proto3" json:"resources,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GiXManifest) Reset() {
	*x = GiXManifest{}
	mi := &file_vault_commons_scailo_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GiXManifest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GiXManifest) ProtoMessage() {}

func (x *GiXManifest) ProtoReflect() protoreflect.Message {
	mi := &file_vault_commons_scailo_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GiXManifest.ProtoReflect.Descriptor instead.
func (*GiXManifest) Descriptor() ([]byte, []int) {
	return file_vault_commons_scailo_proto_rawDescGZIP(), []int{4}
}

func (x *GiXManifest) GetManifestVersion() string {
	if x != nil {
		return x.ManifestVersion
	}
	return ""
}

func (x *GiXManifest) GetAppVersion() string {
	if x != nil {
		return x.AppVersion
	}
	return ""
}

func (x *GiXManifest) GetAppName() string {
	if x != nil {
		return x.AppName
	}
	return ""
}

func (x *GiXManifest) GetAppUniqueIdentifier() string {
	if x != nil {
		return x.AppUniqueIdentifier
	}
	return ""
}

func (x *GiXManifest) GetMinGenesisVersion() string {
	if x != nil {
		return x.MinGenesisVersion
	}
	return ""
}

func (x *GiXManifest) GetMaxGenesisVersion() string {
	if x != nil {
		return x.MaxGenesisVersion
	}
	return ""
}

func (x *GiXManifest) GetResources() *GixResources {
	if x != nil {
		return x.Resources
	}
	return nil
}

// Describes the parameters that are a part of each vault app execution (GiX app execution)
type GiXAppRun struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Stores a globally unique entity UUID. This will be set at the organization level
	EntityUuid string `protobuf:"bytes,1,opt,name=entity_uuid,json=entityUuid,proto3" json:"entity_uuid,omitempty"`
	// Stores the metadata of this user
	Metadata *EmployeeMetadata `protobuf:"bytes,2,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// Stores the ID of the file that is being executed
	VaultFileId uint64 `protobuf:"varint,10,opt,name=vault_file_id,json=vaultFileId,proto3" json:"vault_file_id,omitempty"`
	// Stores the ID of the version of the file that is being executed
	VaultFileVersionId uint64 `protobuf:"varint,11,opt,name=vault_file_version_id,json=vaultFileVersionId,proto3" json:"vault_file_version_id,omitempty"`
	// Stores the unique identifier of the application
	AppUniqueIdentifier string `protobuf:"bytes,12,opt,name=app_unique_identifier,json=appUniqueIdentifier,proto3" json:"app_unique_identifier,omitempty"`
	// Stores the path of the extracted file on disk, from where static files will be served
	ExtractedPath string `protobuf:"bytes,13,opt,name=extracted_path,json=extractedPath,proto3" json:"extracted_path,omitempty"`
	// Stores the IP address from where the app was executed
	IpAddr string `protobuf:"bytes,14,opt,name=ip_addr,json=ipAddr,proto3" json:"ip_addr,omitempty"`
	// Stores the manifest of the GiX app
	Manifest *GiXManifest `protobuf:"bytes,15,opt,name=manifest,proto3" json:"manifest,omitempty"`
	// Stores the username of the user who is running the app
	RunBy string `protobuf:"bytes,16,opt,name=run_by,json=runBy,proto3" json:"run_by,omitempty"`
	// Stores the application version
	AppVersion string `protobuf:"bytes,30,opt,name=app_version,json=appVersion,proto3" json:"app_version,omitempty"`
	// Stores the name of the application
	AppName string `protobuf:"bytes,31,opt,name=app_name,json=appName,proto3" json:"app_name,omitempty"`
	// Stores the endpoint of the application execution
	AppEndpoint   string `protobuf:"bytes,40,opt,name=app_endpoint,json=appEndpoint,proto3" json:"app_endpoint,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GiXAppRun) Reset() {
	*x = GiXAppRun{}
	mi := &file_vault_commons_scailo_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GiXAppRun) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GiXAppRun) ProtoMessage() {}

func (x *GiXAppRun) ProtoReflect() protoreflect.Message {
	mi := &file_vault_commons_scailo_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GiXAppRun.ProtoReflect.Descriptor instead.
func (*GiXAppRun) Descriptor() ([]byte, []int) {
	return file_vault_commons_scailo_proto_rawDescGZIP(), []int{5}
}

func (x *GiXAppRun) GetEntityUuid() string {
	if x != nil {
		return x.EntityUuid
	}
	return ""
}

func (x *GiXAppRun) GetMetadata() *EmployeeMetadata {
	if x != nil {
		return x.Metadata
	}
	return nil
}

func (x *GiXAppRun) GetVaultFileId() uint64 {
	if x != nil {
		return x.VaultFileId
	}
	return 0
}

func (x *GiXAppRun) GetVaultFileVersionId() uint64 {
	if x != nil {
		return x.VaultFileVersionId
	}
	return 0
}

func (x *GiXAppRun) GetAppUniqueIdentifier() string {
	if x != nil {
		return x.AppUniqueIdentifier
	}
	return ""
}

func (x *GiXAppRun) GetExtractedPath() string {
	if x != nil {
		return x.ExtractedPath
	}
	return ""
}

func (x *GiXAppRun) GetIpAddr() string {
	if x != nil {
		return x.IpAddr
	}
	return ""
}

func (x *GiXAppRun) GetManifest() *GiXManifest {
	if x != nil {
		return x.Manifest
	}
	return nil
}

func (x *GiXAppRun) GetRunBy() string {
	if x != nil {
		return x.RunBy
	}
	return ""
}

func (x *GiXAppRun) GetAppVersion() string {
	if x != nil {
		return x.AppVersion
	}
	return ""
}

func (x *GiXAppRun) GetAppName() string {
	if x != nil {
		return x.AppName
	}
	return ""
}

func (x *GiXAppRun) GetAppEndpoint() string {
	if x != nil {
		return x.AppEndpoint
	}
	return ""
}

// Describes the message consisting of the list of gix app runs
type GiXAppRunsList struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// List of runs
	List          []*GiXAppRun `protobuf:"bytes,1,rep,name=list,proto3" json:"list,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GiXAppRunsList) Reset() {
	*x = GiXAppRunsList{}
	mi := &file_vault_commons_scailo_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GiXAppRunsList) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GiXAppRunsList) ProtoMessage() {}

func (x *GiXAppRunsList) ProtoReflect() protoreflect.Message {
	mi := &file_vault_commons_scailo_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GiXAppRunsList.ProtoReflect.Descriptor instead.
func (*GiXAppRunsList) Descriptor() ([]byte, []int) {
	return file_vault_commons_scailo_proto_rawDescGZIP(), []int{6}
}

func (x *GiXAppRunsList) GetList() []*GiXAppRun {
	if x != nil {
		return x.List
	}
	return nil
}

// Describes the request payload of a count filter for app runs
type GiXAppRunCountReq struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// If true, then returns only active records. If false, then returns only inactive records
	IsActive BOOL_FILTER `protobuf:"varint,1,opt,name=is_active,json=isActive,proto3,enum=Scailo.BOOL_FILTER" json:"is_active,omitempty"`
	// The minimum timestamp that needs to be considered to filter by creation
	CreationTimestampStart uint64 `protobuf:"varint,101,opt,name=creation_timestamp_start,json=creationTimestampStart,proto3" json:"creation_timestamp_start,omitempty"`
	// The maximum timestamp that needs to be considered to filter by creation
	CreationTimestampEnd uint64 `protobuf:"varint,102,opt,name=creation_timestamp_end,json=creationTimestampEnd,proto3" json:"creation_timestamp_end,omitempty"`
	// The minimum timestamp that needs to be considered to filter by modification
	ModificationTimestampStart uint64 `protobuf:"varint,103,opt,name=modification_timestamp_start,json=modificationTimestampStart,proto3" json:"modification_timestamp_start,omitempty"`
	// The maximum timestamp that needs to be considered to filter by modification
	ModificationTimestampEnd uint64 `protobuf:"varint,104,opt,name=modification_timestamp_end,json=modificationTimestampEnd,proto3" json:"modification_timestamp_end,omitempty"`
	// The UUID of the file
	VaultFileUuid string `protobuf:"bytes,20,opt,name=vault_file_uuid,json=vaultFileUuid,proto3" json:"vault_file_uuid,omitempty"`
	// The UUID of the version
	VaultFileVersionUuid string `protobuf:"bytes,21,opt,name=vault_file_version_uuid,json=vaultFileVersionUuid,proto3" json:"vault_file_version_uuid,omitempty"` // --------------------------------------------------------
	// The username of the user who executed the app
	RunBy         string `protobuf:"bytes,30,opt,name=run_by,json=runBy,proto3" json:"run_by,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GiXAppRunCountReq) Reset() {
	*x = GiXAppRunCountReq{}
	mi := &file_vault_commons_scailo_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GiXAppRunCountReq) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GiXAppRunCountReq) ProtoMessage() {}

func (x *GiXAppRunCountReq) ProtoReflect() protoreflect.Message {
	mi := &file_vault_commons_scailo_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GiXAppRunCountReq.ProtoReflect.Descriptor instead.
func (*GiXAppRunCountReq) Descriptor() ([]byte, []int) {
	return file_vault_commons_scailo_proto_rawDescGZIP(), []int{7}
}

func (x *GiXAppRunCountReq) GetIsActive() BOOL_FILTER {
	if x != nil {
		return x.IsActive
	}
	return BOOL_FILTER_BOOL_FILTER_ANY_UNSPECIFIED
}

func (x *GiXAppRunCountReq) GetCreationTimestampStart() uint64 {
	if x != nil {
		return x.CreationTimestampStart
	}
	return 0
}

func (x *GiXAppRunCountReq) GetCreationTimestampEnd() uint64 {
	if x != nil {
		return x.CreationTimestampEnd
	}
	return 0
}

func (x *GiXAppRunCountReq) GetModificationTimestampStart() uint64 {
	if x != nil {
		return x.ModificationTimestampStart
	}
	return 0
}

func (x *GiXAppRunCountReq) GetModificationTimestampEnd() uint64 {
	if x != nil {
		return x.ModificationTimestampEnd
	}
	return 0
}

func (x *GiXAppRunCountReq) GetVaultFileUuid() string {
	if x != nil {
		return x.VaultFileUuid
	}
	return ""
}

func (x *GiXAppRunCountReq) GetVaultFileVersionUuid() string {
	if x != nil {
		return x.VaultFileVersionUuid
	}
	return ""
}

func (x *GiXAppRunCountReq) GetRunBy() string {
	if x != nil {
		return x.RunBy
	}
	return ""
}

// Describes the base request payload of a filter search for gix app runs
type GiXAppRunFilterReq struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// If true, then returns only active records. If false, then returns only inactive records
	IsActive BOOL_FILTER `protobuf:"varint,1,opt,name=is_active,json=isActive,proto3,enum=Scailo.BOOL_FILTER" json:"is_active,omitempty"`
	// The number of records that need to be sent in the response. Returns all records if it is set to -1
	Count int64 `protobuf:"varint,2,opt,name=count,proto3" json:"count,omitempty"`
	// The number that need to be offset by before fetching the records
	Offset uint64 `protobuf:"varint,3,opt,name=offset,proto3" json:"offset,omitempty"`
	// The minimum timestamp that needs to be considered to filter by creation
	CreationTimestampStart uint64 `protobuf:"varint,101,opt,name=creation_timestamp_start,json=creationTimestampStart,proto3" json:"creation_timestamp_start,omitempty"`
	// The maximum timestamp that needs to be considered to filter by creation
	CreationTimestampEnd uint64 `protobuf:"varint,102,opt,name=creation_timestamp_end,json=creationTimestampEnd,proto3" json:"creation_timestamp_end,omitempty"`
	// The minimum timestamp that needs to be considered to filter by modification
	ModificationTimestampStart uint64 `protobuf:"varint,103,opt,name=modification_timestamp_start,json=modificationTimestampStart,proto3" json:"modification_timestamp_start,omitempty"`
	// The maximum timestamp that needs to be considered to filter by modification
	ModificationTimestampEnd uint64 `protobuf:"varint,104,opt,name=modification_timestamp_end,json=modificationTimestampEnd,proto3" json:"modification_timestamp_end,omitempty"`
	// The UUID of the file
	VaultFileUuid string `protobuf:"bytes,20,opt,name=vault_file_uuid,json=vaultFileUuid,proto3" json:"vault_file_uuid,omitempty"`
	// The UUID of the version
	VaultFileVersionUuid string `protobuf:"bytes,21,opt,name=vault_file_version_uuid,json=vaultFileVersionUuid,proto3" json:"vault_file_version_uuid,omitempty"` // --------------------------------------------------------
	// The username of the user who executed the app
	RunBy         string `protobuf:"bytes,30,opt,name=run_by,json=runBy,proto3" json:"run_by,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GiXAppRunFilterReq) Reset() {
	*x = GiXAppRunFilterReq{}
	mi := &file_vault_commons_scailo_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GiXAppRunFilterReq) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GiXAppRunFilterReq) ProtoMessage() {}

func (x *GiXAppRunFilterReq) ProtoReflect() protoreflect.Message {
	mi := &file_vault_commons_scailo_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GiXAppRunFilterReq.ProtoReflect.Descriptor instead.
func (*GiXAppRunFilterReq) Descriptor() ([]byte, []int) {
	return file_vault_commons_scailo_proto_rawDescGZIP(), []int{8}
}

func (x *GiXAppRunFilterReq) GetIsActive() BOOL_FILTER {
	if x != nil {
		return x.IsActive
	}
	return BOOL_FILTER_BOOL_FILTER_ANY_UNSPECIFIED
}

func (x *GiXAppRunFilterReq) GetCount() int64 {
	if x != nil {
		return x.Count
	}
	return 0
}

func (x *GiXAppRunFilterReq) GetOffset() uint64 {
	if x != nil {
		return x.Offset
	}
	return 0
}

func (x *GiXAppRunFilterReq) GetCreationTimestampStart() uint64 {
	if x != nil {
		return x.CreationTimestampStart
	}
	return 0
}

func (x *GiXAppRunFilterReq) GetCreationTimestampEnd() uint64 {
	if x != nil {
		return x.CreationTimestampEnd
	}
	return 0
}

func (x *GiXAppRunFilterReq) GetModificationTimestampStart() uint64 {
	if x != nil {
		return x.ModificationTimestampStart
	}
	return 0
}

func (x *GiXAppRunFilterReq) GetModificationTimestampEnd() uint64 {
	if x != nil {
		return x.ModificationTimestampEnd
	}
	return 0
}

func (x *GiXAppRunFilterReq) GetVaultFileUuid() string {
	if x != nil {
		return x.VaultFileUuid
	}
	return ""
}

func (x *GiXAppRunFilterReq) GetVaultFileVersionUuid() string {
	if x != nil {
		return x.VaultFileVersionUuid
	}
	return ""
}

func (x *GiXAppRunFilterReq) GetRunBy() string {
	if x != nil {
		return x.RunBy
	}
	return ""
}

// Describes the resources section of an Enclave
type EnclaveResources struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Stores the list of logos that are available
	Logos []string `protobuf:"bytes,1,rep,name=logos,proto3" json:"logos,omitempty"`
	// Stores the list of folders that need to be accessible by the Enclave
	Folders []string `protobuf:"bytes,2,rep,name=folders,proto3" json:"folders,omitempty"`
	// Stores the list of files that need to be accessible by the Enclave
	Files         []string `protobuf:"bytes,3,rep,name=files,proto3" json:"files,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EnclaveResources) Reset() {
	*x = EnclaveResources{}
	mi := &file_vault_commons_scailo_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EnclaveResources) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EnclaveResources) ProtoMessage() {}

func (x *EnclaveResources) ProtoReflect() protoreflect.Message {
	mi := &file_vault_commons_scailo_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EnclaveResources.ProtoReflect.Descriptor instead.
func (*EnclaveResources) Descriptor() ([]byte, []int) {
	return file_vault_commons_scailo_proto_rawDescGZIP(), []int{9}
}

func (x *EnclaveResources) GetLogos() []string {
	if x != nil {
		return x.Logos
	}
	return nil
}

func (x *EnclaveResources) GetFolders() []string {
	if x != nil {
		return x.Folders
	}
	return nil
}

func (x *EnclaveResources) GetFiles() []string {
	if x != nil {
		return x.Files
	}
	return nil
}

// Describes each environment variable that is defined in the Manifest of an Enclave
type EnclaveManifestEnvVariable struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Stores the name of the environment variable
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Stores the default value of the environment variable
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	// Stores if the variable is a secret
	IsSecret      bool `protobuf:"varint,3,opt,name=is_secret,proto3" json:"is_secret,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EnclaveManifestEnvVariable) Reset() {
	*x = EnclaveManifestEnvVariable{}
	mi := &file_vault_commons_scailo_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EnclaveManifestEnvVariable) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EnclaveManifestEnvVariable) ProtoMessage() {}

func (x *EnclaveManifestEnvVariable) ProtoReflect() protoreflect.Message {
	mi := &file_vault_commons_scailo_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EnclaveManifestEnvVariable.ProtoReflect.Descriptor instead.
func (*EnclaveManifestEnvVariable) Descriptor() ([]byte, []int) {
	return file_vault_commons_scailo_proto_rawDescGZIP(), []int{10}
}

func (x *EnclaveManifestEnvVariable) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *EnclaveManifestEnvVariable) GetValue() string {
	if x != nil {
		return x.Value
	}
	return ""
}

func (x *EnclaveManifestEnvVariable) GetIsSecret() bool {
	if x != nil {
		return x.IsSecret
	}
	return false
}

// Describes the manifest file of an Enclave. Stores the attributes that can be a part of the MANIFEST.yaml file, that is present in the root folder of an Enclave
type EnclaveManifest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Stores the manifest version
	ManifestVersion string `protobuf:"bytes,1,opt,name=manifest_version,proto3" json:"manifest_version,omitempty"`
	// Stores the enclave runtime (valid options are node, golang, python)
	EnclaveRuntime string `protobuf:"bytes,2,opt,name=enclave_runtime,proto3" json:"enclave_runtime,omitempty"`
	// Stores the application version
	AppVersion string `protobuf:"bytes,3,opt,name=app_version,proto3" json:"app_version,omitempty"`
	// Stores the name of the application
	AppName string `protobuf:"bytes,4,opt,name=app_name,proto3" json:"app_name,omitempty"`
	// Stores the name of the enclave
	EnclaveName string `protobuf:"bytes,5,opt,name=enclave_name,proto3" json:"enclave_name,omitempty"`
	// Stores the unique identifier for the application
	AppUniqueIdentifier string `protobuf:"bytes,6,opt,name=app_unique_identifier,proto3" json:"app_unique_identifier,omitempty"`
	// Stores the command that starts the enclave
	StartExec string `protobuf:"bytes,7,opt,name=start_exec,proto3" json:"start_exec,omitempty"`
	// Stores how the entry to the application is to be handled
	EntryPointManagement string `protobuf:"bytes,8,opt,name=entry_point_management,proto3" json:"entry_point_management,omitempty"`
	// Stores the list of default environment variables
	EnvVariables []*EnclaveManifestEnvVariable `protobuf:"bytes,9,rep,name=env_variables,proto3" json:"env_variables,omitempty"`
	// Stores the resources of the Enclave
	Resources     *EnclaveResources `protobuf:"bytes,10,opt,name=resources,proto3" json:"resources,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EnclaveManifest) Reset() {
	*x = EnclaveManifest{}
	mi := &file_vault_commons_scailo_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EnclaveManifest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EnclaveManifest) ProtoMessage() {}

func (x *EnclaveManifest) ProtoReflect() protoreflect.Message {
	mi := &file_vault_commons_scailo_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EnclaveManifest.ProtoReflect.Descriptor instead.
func (*EnclaveManifest) Descriptor() ([]byte, []int) {
	return file_vault_commons_scailo_proto_rawDescGZIP(), []int{11}
}

func (x *EnclaveManifest) GetManifestVersion() string {
	if x != nil {
		return x.ManifestVersion
	}
	return ""
}

func (x *EnclaveManifest) GetEnclaveRuntime() string {
	if x != nil {
		return x.EnclaveRuntime
	}
	return ""
}

func (x *EnclaveManifest) GetAppVersion() string {
	if x != nil {
		return x.AppVersion
	}
	return ""
}

func (x *EnclaveManifest) GetAppName() string {
	if x != nil {
		return x.AppName
	}
	return ""
}

func (x *EnclaveManifest) GetEnclaveName() string {
	if x != nil {
		return x.EnclaveName
	}
	return ""
}

func (x *EnclaveManifest) GetAppUniqueIdentifier() string {
	if x != nil {
		return x.AppUniqueIdentifier
	}
	return ""
}

func (x *EnclaveManifest) GetStartExec() string {
	if x != nil {
		return x.StartExec
	}
	return ""
}

func (x *EnclaveManifest) GetEntryPointManagement() string {
	if x != nil {
		return x.EntryPointManagement
	}
	return ""
}

func (x *EnclaveManifest) GetEnvVariables() []*EnclaveManifestEnvVariable {
	if x != nil {
		return x.EnvVariables
	}
	return nil
}

func (x *EnclaveManifest) GetResources() *EnclaveResources {
	if x != nil {
		return x.Resources
	}
	return nil
}

// Describes the parameters that are a part of each enclave ingress
type EnclaveIngress struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Stores a globally unique entity UUID. This will be set at the organization level
	EntityUuid string `protobuf:"bytes,1,opt,name=entity_uuid,json=entityUuid,proto3" json:"entity_uuid,omitempty"`
	// Stores the metadata of this user
	Metadata *EmployeeMetadata `protobuf:"bytes,2,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// Stores the unique token that can be used to identify the user who executed this enclave
	Token string `protobuf:"bytes,10,opt,name=token,proto3" json:"token,omitempty"`
	// Stores the expiry timestamp of the ingress token
	ExpiresAt uint64 `protobuf:"varint,11,opt,name=expires_at,json=expiresAt,proto3" json:"expires_at,omitempty"`
	// Stores the ID of the file that is being executed
	VaultFileId uint64 `protobuf:"varint,20,opt,name=vault_file_id,json=vaultFileId,proto3" json:"vault_file_id,omitempty"`
	// Stores the ID of the version of the file that is being executed
	VaultFileVersionId uint64 `protobuf:"varint,21,opt,name=vault_file_version_id,json=vaultFileVersionId,proto3" json:"vault_file_version_id,omitempty"`
	// Stores the unique identifier of the application
	EnclaveName string `protobuf:"bytes,22,opt,name=enclave_name,json=enclaveName,proto3" json:"enclave_name,omitempty"`
	// Stores the IP address from where the app was executed
	IpAddr string `protobuf:"bytes,24,opt,name=ip_addr,json=ipAddr,proto3" json:"ip_addr,omitempty"`
	// Stores the ID of the user who executed this enclave
	RunnerUserId uint64 `protobuf:"varint,30,opt,name=runner_user_id,json=runnerUserId,proto3" json:"runner_user_id,omitempty"`
	// Stores the ID of the user when this enclave was executed
	RunnerRoleId uint64 `protobuf:"varint,31,opt,name=runner_role_id,json=runnerRoleId,proto3" json:"runner_role_id,omitempty"`
	// Stores the endpoint of the application execution
	AppEndpoint   string `protobuf:"bytes,60,opt,name=app_endpoint,json=appEndpoint,proto3" json:"app_endpoint,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EnclaveIngress) Reset() {
	*x = EnclaveIngress{}
	mi := &file_vault_commons_scailo_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EnclaveIngress) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EnclaveIngress) ProtoMessage() {}

func (x *EnclaveIngress) ProtoReflect() protoreflect.Message {
	mi := &file_vault_commons_scailo_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EnclaveIngress.ProtoReflect.Descriptor instead.
func (*EnclaveIngress) Descriptor() ([]byte, []int) {
	return file_vault_commons_scailo_proto_rawDescGZIP(), []int{12}
}

func (x *EnclaveIngress) GetEntityUuid() string {
	if x != nil {
		return x.EntityUuid
	}
	return ""
}

func (x *EnclaveIngress) GetMetadata() *EmployeeMetadata {
	if x != nil {
		return x.Metadata
	}
	return nil
}

func (x *EnclaveIngress) GetToken() string {
	if x != nil {
		return x.Token
	}
	return ""
}

func (x *EnclaveIngress) GetExpiresAt() uint64 {
	if x != nil {
		return x.ExpiresAt
	}
	return 0
}

func (x *EnclaveIngress) GetVaultFileId() uint64 {
	if x != nil {
		return x.VaultFileId
	}
	return 0
}

func (x *EnclaveIngress) GetVaultFileVersionId() uint64 {
	if x != nil {
		return x.VaultFileVersionId
	}
	return 0
}

func (x *EnclaveIngress) GetEnclaveName() string {
	if x != nil {
		return x.EnclaveName
	}
	return ""
}

func (x *EnclaveIngress) GetIpAddr() string {
	if x != nil {
		return x.IpAddr
	}
	return ""
}

func (x *EnclaveIngress) GetRunnerUserId() uint64 {
	if x != nil {
		return x.RunnerUserId
	}
	return 0
}

func (x *EnclaveIngress) GetRunnerRoleId() uint64 {
	if x != nil {
		return x.RunnerRoleId
	}
	return 0
}

func (x *EnclaveIngress) GetAppEndpoint() string {
	if x != nil {
		return x.AppEndpoint
	}
	return ""
}

// Describes the message consisting of the list of enclave ingresses
type EnclaveIngressesList struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// List of runs
	List          []*EnclaveIngress `protobuf:"bytes,1,rep,name=list,proto3" json:"list,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EnclaveIngressesList) Reset() {
	*x = EnclaveIngressesList{}
	mi := &file_vault_commons_scailo_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EnclaveIngressesList) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EnclaveIngressesList) ProtoMessage() {}

func (x *EnclaveIngressesList) ProtoReflect() protoreflect.Message {
	mi := &file_vault_commons_scailo_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EnclaveIngressesList.ProtoReflect.Descriptor instead.
func (*EnclaveIngressesList) Descriptor() ([]byte, []int) {
	return file_vault_commons_scailo_proto_rawDescGZIP(), []int{13}
}

func (x *EnclaveIngressesList) GetList() []*EnclaveIngress {
	if x != nil {
		return x.List
	}
	return nil
}

// Describes the request payload of a count filter for enclave runs
type EnclaveIngressCountReq struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// If true, then returns only active records. If false, then returns only inactive records
	IsActive BOOL_FILTER `protobuf:"varint,1,opt,name=is_active,json=isActive,proto3,enum=Scailo.BOOL_FILTER" json:"is_active,omitempty"`
	// The minimum timestamp that needs to be considered to filter by creation
	CreationTimestampStart uint64 `protobuf:"varint,101,opt,name=creation_timestamp_start,json=creationTimestampStart,proto3" json:"creation_timestamp_start,omitempty"`
	// The maximum timestamp that needs to be considered to filter by creation
	CreationTimestampEnd uint64 `protobuf:"varint,102,opt,name=creation_timestamp_end,json=creationTimestampEnd,proto3" json:"creation_timestamp_end,omitempty"`
	// The minimum timestamp that needs to be considered to filter by modification
	ModificationTimestampStart uint64 `protobuf:"varint,103,opt,name=modification_timestamp_start,json=modificationTimestampStart,proto3" json:"modification_timestamp_start,omitempty"`
	// The maximum timestamp that needs to be considered to filter by modification
	ModificationTimestampEnd uint64 `protobuf:"varint,104,opt,name=modification_timestamp_end,json=modificationTimestampEnd,proto3" json:"modification_timestamp_end,omitempty"`
	// The UUID of the file
	VaultFileUuid string `protobuf:"bytes,20,opt,name=vault_file_uuid,json=vaultFileUuid,proto3" json:"vault_file_uuid,omitempty"`
	// The UUID of the version
	VaultFileVersionUuid string `protobuf:"bytes,21,opt,name=vault_file_version_uuid,json=vaultFileVersionUuid,proto3" json:"vault_file_version_uuid,omitempty"` // --------------------------------------------------------
	// Stores the ID of the user who executed this enclave
	RunnerUserId uint64 `protobuf:"varint,30,opt,name=runner_user_id,json=runnerUserId,proto3" json:"runner_user_id,omitempty"`
	// Stores the ID of the user when this enclave was executed
	RunnerRoleId  uint64 `protobuf:"varint,31,opt,name=runner_role_id,json=runnerRoleId,proto3" json:"runner_role_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EnclaveIngressCountReq) Reset() {
	*x = EnclaveIngressCountReq{}
	mi := &file_vault_commons_scailo_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EnclaveIngressCountReq) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EnclaveIngressCountReq) ProtoMessage() {}

func (x *EnclaveIngressCountReq) ProtoReflect() protoreflect.Message {
	mi := &file_vault_commons_scailo_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EnclaveIngressCountReq.ProtoReflect.Descriptor instead.
func (*EnclaveIngressCountReq) Descriptor() ([]byte, []int) {
	return file_vault_commons_scailo_proto_rawDescGZIP(), []int{14}
}

func (x *EnclaveIngressCountReq) GetIsActive() BOOL_FILTER {
	if x != nil {
		return x.IsActive
	}
	return BOOL_FILTER_BOOL_FILTER_ANY_UNSPECIFIED
}

func (x *EnclaveIngressCountReq) GetCreationTimestampStart() uint64 {
	if x != nil {
		return x.CreationTimestampStart
	}
	return 0
}

func (x *EnclaveIngressCountReq) GetCreationTimestampEnd() uint64 {
	if x != nil {
		return x.CreationTimestampEnd
	}
	return 0
}

func (x *EnclaveIngressCountReq) GetModificationTimestampStart() uint64 {
	if x != nil {
		return x.ModificationTimestampStart
	}
	return 0
}

func (x *EnclaveIngressCountReq) GetModificationTimestampEnd() uint64 {
	if x != nil {
		return x.ModificationTimestampEnd
	}
	return 0
}

func (x *EnclaveIngressCountReq) GetVaultFileUuid() string {
	if x != nil {
		return x.VaultFileUuid
	}
	return ""
}

func (x *EnclaveIngressCountReq) GetVaultFileVersionUuid() string {
	if x != nil {
		return x.VaultFileVersionUuid
	}
	return ""
}

func (x *EnclaveIngressCountReq) GetRunnerUserId() uint64 {
	if x != nil {
		return x.RunnerUserId
	}
	return 0
}

func (x *EnclaveIngressCountReq) GetRunnerRoleId() uint64 {
	if x != nil {
		return x.RunnerRoleId
	}
	return 0
}

// Describes the base request payload of a filter search for enclave runs
type EnclaveIngressFilterReq struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// If true, then returns only active records. If false, then returns only inactive records
	IsActive BOOL_FILTER `protobuf:"varint,1,opt,name=is_active,json=isActive,proto3,enum=Scailo.BOOL_FILTER" json:"is_active,omitempty"`
	// The number of records that need to be sent in the response. Returns all records if it is set to -1
	Count int64 `protobuf:"varint,2,opt,name=count,proto3" json:"count,omitempty"`
	// The number that need to be offset by before fetching the records
	Offset uint64 `protobuf:"varint,3,opt,name=offset,proto3" json:"offset,omitempty"`
	// The minimum timestamp that needs to be considered to filter by creation
	CreationTimestampStart uint64 `protobuf:"varint,101,opt,name=creation_timestamp_start,json=creationTimestampStart,proto3" json:"creation_timestamp_start,omitempty"`
	// The maximum timestamp that needs to be considered to filter by creation
	CreationTimestampEnd uint64 `protobuf:"varint,102,opt,name=creation_timestamp_end,json=creationTimestampEnd,proto3" json:"creation_timestamp_end,omitempty"`
	// The minimum timestamp that needs to be considered to filter by modification
	ModificationTimestampStart uint64 `protobuf:"varint,103,opt,name=modification_timestamp_start,json=modificationTimestampStart,proto3" json:"modification_timestamp_start,omitempty"`
	// The maximum timestamp that needs to be considered to filter by modification
	ModificationTimestampEnd uint64 `protobuf:"varint,104,opt,name=modification_timestamp_end,json=modificationTimestampEnd,proto3" json:"modification_timestamp_end,omitempty"`
	// The UUID of the file
	VaultFileUuid string `protobuf:"bytes,20,opt,name=vault_file_uuid,json=vaultFileUuid,proto3" json:"vault_file_uuid,omitempty"`
	// The UUID of the version
	VaultFileVersionUuid string `protobuf:"bytes,21,opt,name=vault_file_version_uuid,json=vaultFileVersionUuid,proto3" json:"vault_file_version_uuid,omitempty"` // --------------------------------------------------------
	// Stores the ID of the user who executed this enclave
	RunnerUserId uint64 `protobuf:"varint,30,opt,name=runner_user_id,json=runnerUserId,proto3" json:"runner_user_id,omitempty"`
	// Stores the ID of the user when this enclave was executed
	RunnerRoleId  uint64 `protobuf:"varint,31,opt,name=runner_role_id,json=runnerRoleId,proto3" json:"runner_role_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EnclaveIngressFilterReq) Reset() {
	*x = EnclaveIngressFilterReq{}
	mi := &file_vault_commons_scailo_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EnclaveIngressFilterReq) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EnclaveIngressFilterReq) ProtoMessage() {}

func (x *EnclaveIngressFilterReq) ProtoReflect() protoreflect.Message {
	mi := &file_vault_commons_scailo_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EnclaveIngressFilterReq.ProtoReflect.Descriptor instead.
func (*EnclaveIngressFilterReq) Descriptor() ([]byte, []int) {
	return file_vault_commons_scailo_proto_rawDescGZIP(), []int{15}
}

func (x *EnclaveIngressFilterReq) GetIsActive() BOOL_FILTER {
	if x != nil {
		return x.IsActive
	}
	return BOOL_FILTER_BOOL_FILTER_ANY_UNSPECIFIED
}

func (x *EnclaveIngressFilterReq) GetCount() int64 {
	if x != nil {
		return x.Count
	}
	return 0
}

func (x *EnclaveIngressFilterReq) GetOffset() uint64 {
	if x != nil {
		return x.Offset
	}
	return 0
}

func (x *EnclaveIngressFilterReq) GetCreationTimestampStart() uint64 {
	if x != nil {
		return x.CreationTimestampStart
	}
	return 0
}

func (x *EnclaveIngressFilterReq) GetCreationTimestampEnd() uint64 {
	if x != nil {
		return x.CreationTimestampEnd
	}
	return 0
}

func (x *EnclaveIngressFilterReq) GetModificationTimestampStart() uint64 {
	if x != nil {
		return x.ModificationTimestampStart
	}
	return 0
}

func (x *EnclaveIngressFilterReq) GetModificationTimestampEnd() uint64 {
	if x != nil {
		return x.ModificationTimestampEnd
	}
	return 0
}

func (x *EnclaveIngressFilterReq) GetVaultFileUuid() string {
	if x != nil {
		return x.VaultFileUuid
	}
	return ""
}

func (x *EnclaveIngressFilterReq) GetVaultFileVersionUuid() string {
	if x != nil {
		return x.VaultFileVersionUuid
	}
	return ""
}

func (x *EnclaveIngressFilterReq) GetRunnerUserId() uint64 {
	if x != nil {
		return x.RunnerUserId
	}
	return 0
}

func (x *EnclaveIngressFilterReq) GetRunnerRoleId() uint64 {
	if x != nil {
		return x.RunnerRoleId
	}
	return 0
}

// The request payload to verify an enclave ingress
type VerifyEnclaveIngressRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The token that needs to be verified
	Token         string `protobuf:"bytes,1,opt,name=token,proto3" json:"token,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *VerifyEnclaveIngressRequest) Reset() {
	*x = VerifyEnclaveIngressRequest{}
	mi := &file_vault_commons_scailo_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VerifyEnclaveIngressRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VerifyEnclaveIngressRequest) ProtoMessage() {}

func (x *VerifyEnclaveIngressRequest) ProtoReflect() protoreflect.Message {
	mi := &file_vault_commons_scailo_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VerifyEnclaveIngressRequest.ProtoReflect.Descriptor instead.
func (*VerifyEnclaveIngressRequest) Descriptor() ([]byte, []int) {
	return file_vault_commons_scailo_proto_rawDescGZIP(), []int{16}
}

func (x *VerifyEnclaveIngressRequest) GetToken() string {
	if x != nil {
		return x.Token
	}
	return ""
}

// The response payload to verify an enclave ingress
type VerifyEnclaveIngressResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The name of the enclave
	EnclaveName string `protobuf:"bytes,1,opt,name=enclave_name,json=enclaveName,proto3" json:"enclave_name,omitempty"`
	// The UUID of the user who is running the enclave
	UserUuid string `protobuf:"bytes,2,opt,name=user_uuid,json=userUuid,proto3" json:"user_uuid,omitempty"`
	// The UUID of the user's role
	RoleUuid string `protobuf:"bytes,3,opt,name=role_uuid,json=roleUuid,proto3" json:"role_uuid,omitempty"`
	// The auth token of the user that can be used for subsequent requests
	AuthToken string `protobuf:"bytes,4,opt,name=auth_token,json=authToken,proto3" json:"auth_token,omitempty"`
	// The timestamp after which the auth token expires
	ExpiresAt     uint64 `protobuf:"varint,5,opt,name=expires_at,json=expiresAt,proto3" json:"expires_at,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *VerifyEnclaveIngressResponse) Reset() {
	*x = VerifyEnclaveIngressResponse{}
	mi := &file_vault_commons_scailo_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VerifyEnclaveIngressResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VerifyEnclaveIngressResponse) ProtoMessage() {}

func (x *VerifyEnclaveIngressResponse) ProtoReflect() protoreflect.Message {
	mi := &file_vault_commons_scailo_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VerifyEnclaveIngressResponse.ProtoReflect.Descriptor instead.
func (*VerifyEnclaveIngressResponse) Descriptor() ([]byte, []int) {
	return file_vault_commons_scailo_proto_rawDescGZIP(), []int{17}
}

func (x *VerifyEnclaveIngressResponse) GetEnclaveName() string {
	if x != nil {
		return x.EnclaveName
	}
	return ""
}

func (x *VerifyEnclaveIngressResponse) GetUserUuid() string {
	if x != nil {
		return x.UserUuid
	}
	return ""
}

func (x *VerifyEnclaveIngressResponse) GetRoleUuid() string {
	if x != nil {
		return x.RoleUuid
	}
	return ""
}

func (x *VerifyEnclaveIngressResponse) GetAuthToken() string {
	if x != nil {
		return x.AuthToken
	}
	return ""
}

func (x *VerifyEnclaveIngressResponse) GetExpiresAt() uint64 {
	if x != nil {
		return x.ExpiresAt
	}
	return 0
}

// Stores the payload that is necessary to create a custom environment variable for an enclave
type EnclaveEnvironmentVariableAddRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The UUID of the enclave file that will be updated with the given environment variable
	FileUuid string `protobuf:"bytes,1,opt,name=file_uuid,json=fileUuid,proto3" json:"file_uuid,omitempty"`
	// The name of the environment variable
	Name string `protobuf:"bytes,11,opt,name=name,proto3" json:"name,omitempty"`
	// The value of the environment variable
	Value string `protobuf:"bytes,12,opt,name=value,proto3" json:"value,omitempty"`
	// Denotes if the value should be stored as a secret (will not be visible to the user post creation)
	IsSecret      bool `protobuf:"varint,13,opt,name=is_secret,json=isSecret,proto3" json:"is_secret,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EnclaveEnvironmentVariableAddRequest) Reset() {
	*x = EnclaveEnvironmentVariableAddRequest{}
	mi := &file_vault_commons_scailo_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EnclaveEnvironmentVariableAddRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EnclaveEnvironmentVariableAddRequest) ProtoMessage() {}

func (x *EnclaveEnvironmentVariableAddRequest) ProtoReflect() protoreflect.Message {
	mi := &file_vault_commons_scailo_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EnclaveEnvironmentVariableAddRequest.ProtoReflect.Descriptor instead.
func (*EnclaveEnvironmentVariableAddRequest) Descriptor() ([]byte, []int) {
	return file_vault_commons_scailo_proto_rawDescGZIP(), []int{18}
}

func (x *EnclaveEnvironmentVariableAddRequest) GetFileUuid() string {
	if x != nil {
		return x.FileUuid
	}
	return ""
}

func (x *EnclaveEnvironmentVariableAddRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *EnclaveEnvironmentVariableAddRequest) GetValue() string {
	if x != nil {
		return x.Value
	}
	return ""
}

func (x *EnclaveEnvironmentVariableAddRequest) GetIsSecret() bool {
	if x != nil {
		return x.IsSecret
	}
	return false
}

// Stores the payload that is necessary to update a custom environment variable for an enclave
type EnclaveEnvironmentVariableUpdateRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The UUID of the environment variables that needs to be updated
	Uuid string `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	// The value of the environment variable that needs to be updated
	Value         string `protobuf:"bytes,11,opt,name=value,proto3" json:"value,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EnclaveEnvironmentVariableUpdateRequest) Reset() {
	*x = EnclaveEnvironmentVariableUpdateRequest{}
	mi := &file_vault_commons_scailo_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EnclaveEnvironmentVariableUpdateRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EnclaveEnvironmentVariableUpdateRequest) ProtoMessage() {}

func (x *EnclaveEnvironmentVariableUpdateRequest) ProtoReflect() protoreflect.Message {
	mi := &file_vault_commons_scailo_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EnclaveEnvironmentVariableUpdateRequest.ProtoReflect.Descriptor instead.
func (*EnclaveEnvironmentVariableUpdateRequest) Descriptor() ([]byte, []int) {
	return file_vault_commons_scailo_proto_rawDescGZIP(), []int{19}
}

func (x *EnclaveEnvironmentVariableUpdateRequest) GetUuid() string {
	if x != nil {
		return x.Uuid
	}
	return ""
}

func (x *EnclaveEnvironmentVariableUpdateRequest) GetValue() string {
	if x != nil {
		return x.Value
	}
	return ""
}

// Denotes an individual environment variable that is part of an enclave
type EnclaveEnvironmentVariable struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Stores a globally unique entity UUID. This will be set at the organization level
	EntityUuid string `protobuf:"bytes,1,opt,name=entity_uuid,json=entityUuid,proto3" json:"entity_uuid,omitempty"`
	// Stores the metadata of this user
	Metadata *EmployeeMetadata `protobuf:"bytes,2,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// Stores the ID of the file that the environment variable belongs to
	VaultFileId uint64 `protobuf:"varint,10,opt,name=vault_file_id,json=vaultFileId,proto3" json:"vault_file_id,omitempty"`
	// The name of the environment variable
	Name string `protobuf:"bytes,11,opt,name=name,proto3" json:"name,omitempty"`
	// The value of the environment variable
	Value string `protobuf:"bytes,12,opt,name=value,proto3" json:"value,omitempty"`
	// Denotes if the value should be stored as a secret (will not be visible to the user post creation)
	IsSecret      bool `protobuf:"varint,13,opt,name=is_secret,json=isSecret,proto3" json:"is_secret,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EnclaveEnvironmentVariable) Reset() {
	*x = EnclaveEnvironmentVariable{}
	mi := &file_vault_commons_scailo_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EnclaveEnvironmentVariable) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EnclaveEnvironmentVariable) ProtoMessage() {}

func (x *EnclaveEnvironmentVariable) ProtoReflect() protoreflect.Message {
	mi := &file_vault_commons_scailo_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EnclaveEnvironmentVariable.ProtoReflect.Descriptor instead.
func (*EnclaveEnvironmentVariable) Descriptor() ([]byte, []int) {
	return file_vault_commons_scailo_proto_rawDescGZIP(), []int{20}
}

func (x *EnclaveEnvironmentVariable) GetEntityUuid() string {
	if x != nil {
		return x.EntityUuid
	}
	return ""
}

func (x *EnclaveEnvironmentVariable) GetMetadata() *EmployeeMetadata {
	if x != nil {
		return x.Metadata
	}
	return nil
}

func (x *EnclaveEnvironmentVariable) GetVaultFileId() uint64 {
	if x != nil {
		return x.VaultFileId
	}
	return 0
}

func (x *EnclaveEnvironmentVariable) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *EnclaveEnvironmentVariable) GetValue() string {
	if x != nil {
		return x.Value
	}
	return ""
}

func (x *EnclaveEnvironmentVariable) GetIsSecret() bool {
	if x != nil {
		return x.IsSecret
	}
	return false
}

// Denotes the list of environment variables that are part of an enclave
type EnclaveEnvironmentVariablesList struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// List of environment variables
	List          []*EnclaveEnvironmentVariable `protobuf:"bytes,1,rep,name=list,proto3" json:"list,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EnclaveEnvironmentVariablesList) Reset() {
	*x = EnclaveEnvironmentVariablesList{}
	mi := &file_vault_commons_scailo_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EnclaveEnvironmentVariablesList) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EnclaveEnvironmentVariablesList) ProtoMessage() {}

func (x *EnclaveEnvironmentVariablesList) ProtoReflect() protoreflect.Message {
	mi := &file_vault_commons_scailo_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EnclaveEnvironmentVariablesList.ProtoReflect.Descriptor instead.
func (*EnclaveEnvironmentVariablesList) Descriptor() ([]byte, []int) {
	return file_vault_commons_scailo_proto_rawDescGZIP(), []int{21}
}

func (x *EnclaveEnvironmentVariablesList) GetList() []*EnclaveEnvironmentVariable {
	if x != nil {
		return x.List
	}
	return nil
}

// Stores the payload that is necessary to create a custom domain for an enclave
type EnclaveDomainAddRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The UUID of the enclave file that will be updated with the given domain
	FileUuid string `protobuf:"bytes,1,opt,name=file_uuid,json=fileUuid,proto3" json:"file_uuid,omitempty"`
	// The domain that points to the enclave
	Domain        string `protobuf:"bytes,11,opt,name=domain,proto3" json:"domain,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EnclaveDomainAddRequest) Reset() {
	*x = EnclaveDomainAddRequest{}
	mi := &file_vault_commons_scailo_proto_msgTypes[22]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EnclaveDomainAddRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EnclaveDomainAddRequest) ProtoMessage() {}

func (x *EnclaveDomainAddRequest) ProtoReflect() protoreflect.Message {
	mi := &file_vault_commons_scailo_proto_msgTypes[22]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EnclaveDomainAddRequest.ProtoReflect.Descriptor instead.
func (*EnclaveDomainAddRequest) Descriptor() ([]byte, []int) {
	return file_vault_commons_scailo_proto_rawDescGZIP(), []int{22}
}

func (x *EnclaveDomainAddRequest) GetFileUuid() string {
	if x != nil {
		return x.FileUuid
	}
	return ""
}

func (x *EnclaveDomainAddRequest) GetDomain() string {
	if x != nil {
		return x.Domain
	}
	return ""
}

// Denotes an individual domain that is part of an enclave
type EnclaveDomain struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Stores a globally unique entity UUID. This will be set at the organization level
	EntityUuid string `protobuf:"bytes,1,opt,name=entity_uuid,json=entityUuid,proto3" json:"entity_uuid,omitempty"`
	// Stores the metadata of this user
	Metadata *EmployeeMetadata `protobuf:"bytes,2,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// Stores the ID of the file that the domain belongs to
	VaultFileId uint64 `protobuf:"varint,10,opt,name=vault_file_id,json=vaultFileId,proto3" json:"vault_file_id,omitempty"`
	// The domain that points to the enclave
	Domain string `protobuf:"bytes,11,opt,name=domain,proto3" json:"domain,omitempty"`
	// The internal address of the service that the domain points to
	ServiceAddr   string `protobuf:"bytes,12,opt,name=service_addr,json=serviceAddr,proto3" json:"service_addr,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EnclaveDomain) Reset() {
	*x = EnclaveDomain{}
	mi := &file_vault_commons_scailo_proto_msgTypes[23]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EnclaveDomain) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EnclaveDomain) ProtoMessage() {}

func (x *EnclaveDomain) ProtoReflect() protoreflect.Message {
	mi := &file_vault_commons_scailo_proto_msgTypes[23]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EnclaveDomain.ProtoReflect.Descriptor instead.
func (*EnclaveDomain) Descriptor() ([]byte, []int) {
	return file_vault_commons_scailo_proto_rawDescGZIP(), []int{23}
}

func (x *EnclaveDomain) GetEntityUuid() string {
	if x != nil {
		return x.EntityUuid
	}
	return ""
}

func (x *EnclaveDomain) GetMetadata() *EmployeeMetadata {
	if x != nil {
		return x.Metadata
	}
	return nil
}

func (x *EnclaveDomain) GetVaultFileId() uint64 {
	if x != nil {
		return x.VaultFileId
	}
	return 0
}

func (x *EnclaveDomain) GetDomain() string {
	if x != nil {
		return x.Domain
	}
	return ""
}

func (x *EnclaveDomain) GetServiceAddr() string {
	if x != nil {
		return x.ServiceAddr
	}
	return ""
}

// Describes the request payload of a enclave domains filter search
type EnclaveDomainsFilterReq struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// If true, then returns only active records. If false, then returns only inactive records
	IsActive BOOL_FILTER `protobuf:"varint,1,opt,name=is_active,json=isActive,proto3,enum=Scailo.BOOL_FILTER" json:"is_active,omitempty"`
	// The number of records that need to be sent in the response. Returns all records if it is set to -1
	Count int64 `protobuf:"varint,2,opt,name=count,proto3" json:"count,omitempty"`
	// The number that need to be offset by before fetching the records
	Offset uint64 `protobuf:"varint,3,opt,name=offset,proto3" json:"offset,omitempty"`
	// The sort order that is to be used to fetch the pagination response
	SortOrder SORT_ORDER `protobuf:"varint,4,opt,name=sort_order,json=sortOrder,proto3,enum=Scailo.SORT_ORDER" json:"sort_order,omitempty"`
	// The sort key that is to be used to fetch the pagination response
	SortKey ENCLAVE_DOMAIN_SORT_KEY `protobuf:"varint,5,opt,name=sort_key,json=sortKey,proto3,enum=Scailo.ENCLAVE_DOMAIN_SORT_KEY" json:"sort_key,omitempty"`
	// The minimum timestamp that needs to be considered to filter by creation
	CreationTimestampStart uint64 `protobuf:"varint,101,opt,name=creation_timestamp_start,json=creationTimestampStart,proto3" json:"creation_timestamp_start,omitempty"`
	// The maximum timestamp that needs to be considered to filter by creation
	CreationTimestampEnd uint64 `protobuf:"varint,102,opt,name=creation_timestamp_end,json=creationTimestampEnd,proto3" json:"creation_timestamp_end,omitempty"`
	// The minimum timestamp that needs to be considered to filter by modification
	ModificationTimestampStart uint64 `protobuf:"varint,103,opt,name=modification_timestamp_start,json=modificationTimestampStart,proto3" json:"modification_timestamp_start,omitempty"`
	// The maximum timestamp that needs to be considered to filter by modification
	ModificationTimestampEnd uint64 `protobuf:"varint,104,opt,name=modification_timestamp_end,json=modificationTimestampEnd,proto3" json:"modification_timestamp_end,omitempty"`
	// The entity UUID that is to be used to filter records
	EntityUuid string `protobuf:"bytes,8,opt,name=entity_uuid,json=entityUuid,proto3" json:"entity_uuid,omitempty"`
	// The domain that points to the enclave
	Domain string `protobuf:"bytes,11,opt,name=domain,proto3" json:"domain,omitempty"`
	// The internal address of the service that the domain points to
	ServiceAddr   string `protobuf:"bytes,12,opt,name=service_addr,json=serviceAddr,proto3" json:"service_addr,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EnclaveDomainsFilterReq) Reset() {
	*x = EnclaveDomainsFilterReq{}
	mi := &file_vault_commons_scailo_proto_msgTypes[24]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EnclaveDomainsFilterReq) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EnclaveDomainsFilterReq) ProtoMessage() {}

func (x *EnclaveDomainsFilterReq) ProtoReflect() protoreflect.Message {
	mi := &file_vault_commons_scailo_proto_msgTypes[24]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EnclaveDomainsFilterReq.ProtoReflect.Descriptor instead.
func (*EnclaveDomainsFilterReq) Descriptor() ([]byte, []int) {
	return file_vault_commons_scailo_proto_rawDescGZIP(), []int{24}
}

func (x *EnclaveDomainsFilterReq) GetIsActive() BOOL_FILTER {
	if x != nil {
		return x.IsActive
	}
	return BOOL_FILTER_BOOL_FILTER_ANY_UNSPECIFIED
}

func (x *EnclaveDomainsFilterReq) GetCount() int64 {
	if x != nil {
		return x.Count
	}
	return 0
}

func (x *EnclaveDomainsFilterReq) GetOffset() uint64 {
	if x != nil {
		return x.Offset
	}
	return 0
}

func (x *EnclaveDomainsFilterReq) GetSortOrder() SORT_ORDER {
	if x != nil {
		return x.SortOrder
	}
	return SORT_ORDER_ASCENDING_UNSPECIFIED
}

func (x *EnclaveDomainsFilterReq) GetSortKey() ENCLAVE_DOMAIN_SORT_KEY {
	if x != nil {
		return x.SortKey
	}
	return ENCLAVE_DOMAIN_SORT_KEY_ENCLAVE_DOMAIN_SORT_KEY_ID_UNSPECIFIED
}

func (x *EnclaveDomainsFilterReq) GetCreationTimestampStart() uint64 {
	if x != nil {
		return x.CreationTimestampStart
	}
	return 0
}

func (x *EnclaveDomainsFilterReq) GetCreationTimestampEnd() uint64 {
	if x != nil {
		return x.CreationTimestampEnd
	}
	return 0
}

func (x *EnclaveDomainsFilterReq) GetModificationTimestampStart() uint64 {
	if x != nil {
		return x.ModificationTimestampStart
	}
	return 0
}

func (x *EnclaveDomainsFilterReq) GetModificationTimestampEnd() uint64 {
	if x != nil {
		return x.ModificationTimestampEnd
	}
	return 0
}

func (x *EnclaveDomainsFilterReq) GetEntityUuid() string {
	if x != nil {
		return x.EntityUuid
	}
	return ""
}

func (x *EnclaveDomainsFilterReq) GetDomain() string {
	if x != nil {
		return x.Domain
	}
	return ""
}

func (x *EnclaveDomainsFilterReq) GetServiceAddr() string {
	if x != nil {
		return x.ServiceAddr
	}
	return ""
}

// Denotes the list of domains that are part of an enclave
type EnclaveDomainsList struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// List of domains
	List          []*EnclaveDomain `protobuf:"bytes,1,rep,name=list,proto3" json:"list,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EnclaveDomainsList) Reset() {
	*x = EnclaveDomainsList{}
	mi := &file_vault_commons_scailo_proto_msgTypes[25]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EnclaveDomainsList) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EnclaveDomainsList) ProtoMessage() {}

func (x *EnclaveDomainsList) ProtoReflect() protoreflect.Message {
	mi := &file_vault_commons_scailo_proto_msgTypes[25]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EnclaveDomainsList.ProtoReflect.Descriptor instead.
func (*EnclaveDomainsList) Descriptor() ([]byte, []int) {
	return file_vault_commons_scailo_proto_rawDescGZIP(), []int{25}
}

func (x *EnclaveDomainsList) GetList() []*EnclaveDomain {
	if x != nil {
		return x.List
	}
	return nil
}

// The response that contains the default domain suffix that is used for creating enclave domains
type EnclaveDomainSuffixResp struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The suffix that is used
	Suffix string `protobuf:"bytes,1,opt,name=suffix,proto3" json:"suffix,omitempty"`
	// The relay that is used
	Relay         string `protobuf:"bytes,2,opt,name=relay,proto3" json:"relay,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EnclaveDomainSuffixResp) Reset() {
	*x = EnclaveDomainSuffixResp{}
	mi := &file_vault_commons_scailo_proto_msgTypes[26]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EnclaveDomainSuffixResp) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EnclaveDomainSuffixResp) ProtoMessage() {}

func (x *EnclaveDomainSuffixResp) ProtoReflect() protoreflect.Message {
	mi := &file_vault_commons_scailo_proto_msgTypes[26]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EnclaveDomainSuffixResp.ProtoReflect.Descriptor instead.
func (*EnclaveDomainSuffixResp) Descriptor() ([]byte, []int) {
	return file_vault_commons_scailo_proto_rawDescGZIP(), []int{26}
}

func (x *EnclaveDomainSuffixResp) GetSuffix() string {
	if x != nil {
		return x.Suffix
	}
	return ""
}

func (x *EnclaveDomainSuffixResp) GetRelay() string {
	if x != nil {
		return x.Relay
	}
	return ""
}

// Stores the payload that is necessary to create a custom frame for an enclave
type EnclaveFrameAddRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The UUID of the enclave file that will be updated with the given frame
	FileUuid string `protobuf:"bytes,1,opt,name=file_uuid,json=fileUuid,proto3" json:"file_uuid,omitempty"`
	// The sequence number of the frame
	SequenceNumber uint64 `protobuf:"varint,10,opt,name=sequence_number,json=sequenceNumber,proto3" json:"sequence_number,omitempty"`
	// The time in seconds after which the frame needs to be refreshed. O denotes no auto refresh.
	AutoRefreshInterval uint64 `protobuf:"varint,11,opt,name=auto_refresh_interval,json=autoRefreshInterval,proto3" json:"auto_refresh_interval,omitempty"`
	// The width of the frame, with the possible values being 3, 4, 6, 8, 9, and 12
	Width uint64 `protobuf:"varint,12,opt,name=width,proto3" json:"width,omitempty"`
	// The height of the frame in vh (viewport height)
	Height        uint64 `protobuf:"varint,13,opt,name=height,proto3" json:"height,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EnclaveFrameAddRequest) Reset() {
	*x = EnclaveFrameAddRequest{}
	mi := &file_vault_commons_scailo_proto_msgTypes[27]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EnclaveFrameAddRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EnclaveFrameAddRequest) ProtoMessage() {}

func (x *EnclaveFrameAddRequest) ProtoReflect() protoreflect.Message {
	mi := &file_vault_commons_scailo_proto_msgTypes[27]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EnclaveFrameAddRequest.ProtoReflect.Descriptor instead.
func (*EnclaveFrameAddRequest) Descriptor() ([]byte, []int) {
	return file_vault_commons_scailo_proto_rawDescGZIP(), []int{27}
}

func (x *EnclaveFrameAddRequest) GetFileUuid() string {
	if x != nil {
		return x.FileUuid
	}
	return ""
}

func (x *EnclaveFrameAddRequest) GetSequenceNumber() uint64 {
	if x != nil {
		return x.SequenceNumber
	}
	return 0
}

func (x *EnclaveFrameAddRequest) GetAutoRefreshInterval() uint64 {
	if x != nil {
		return x.AutoRefreshInterval
	}
	return 0
}

func (x *EnclaveFrameAddRequest) GetWidth() uint64 {
	if x != nil {
		return x.Width
	}
	return 0
}

func (x *EnclaveFrameAddRequest) GetHeight() uint64 {
	if x != nil {
		return x.Height
	}
	return 0
}

// Stores the payload that is necessary to update a custom frame for an enclave
type EnclaveFrameUpdateRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The UUID of the frame that needs to be updated
	Uuid string `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	// The sequence number of the frame
	SequenceNumber uint64 `protobuf:"varint,10,opt,name=sequence_number,json=sequenceNumber,proto3" json:"sequence_number,omitempty"`
	// The time in seconds after which the frame needs to be refreshed
	AutoRefreshInterval uint64 `protobuf:"varint,11,opt,name=auto_refresh_interval,json=autoRefreshInterval,proto3" json:"auto_refresh_interval,omitempty"`
	// The width of the frame, with the possible values being 3, 4, 6, 8, 9, and 12
	Width uint64 `protobuf:"varint,12,opt,name=width,proto3" json:"width,omitempty"`
	// The height of the frame in vh (viewport height)
	Height        uint64 `protobuf:"varint,13,opt,name=height,proto3" json:"height,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EnclaveFrameUpdateRequest) Reset() {
	*x = EnclaveFrameUpdateRequest{}
	mi := &file_vault_commons_scailo_proto_msgTypes[28]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EnclaveFrameUpdateRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EnclaveFrameUpdateRequest) ProtoMessage() {}

func (x *EnclaveFrameUpdateRequest) ProtoReflect() protoreflect.Message {
	mi := &file_vault_commons_scailo_proto_msgTypes[28]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EnclaveFrameUpdateRequest.ProtoReflect.Descriptor instead.
func (*EnclaveFrameUpdateRequest) Descriptor() ([]byte, []int) {
	return file_vault_commons_scailo_proto_rawDescGZIP(), []int{28}
}

func (x *EnclaveFrameUpdateRequest) GetUuid() string {
	if x != nil {
		return x.Uuid
	}
	return ""
}

func (x *EnclaveFrameUpdateRequest) GetSequenceNumber() uint64 {
	if x != nil {
		return x.SequenceNumber
	}
	return 0
}

func (x *EnclaveFrameUpdateRequest) GetAutoRefreshInterval() uint64 {
	if x != nil {
		return x.AutoRefreshInterval
	}
	return 0
}

func (x *EnclaveFrameUpdateRequest) GetWidth() uint64 {
	if x != nil {
		return x.Width
	}
	return 0
}

func (x *EnclaveFrameUpdateRequest) GetHeight() uint64 {
	if x != nil {
		return x.Height
	}
	return 0
}

// Denotes an individual frame that is part of an enclave
type EnclaveFrame struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Stores a globally unique entity UUID. This will be set at the organization level
	EntityUuid string `protobuf:"bytes,1,opt,name=entity_uuid,json=entityUuid,proto3" json:"entity_uuid,omitempty"`
	// Stores the metadata of this user
	Metadata *EmployeeMetadata `protobuf:"bytes,2,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// Stores the ID of the user that the frame belongs to
	UserId uint64 `protobuf:"varint,10,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	// Stores the ID of the file that is used to render the frame
	VaultFileId uint64 `protobuf:"varint,11,opt,name=vault_file_id,json=vaultFileId,proto3" json:"vault_file_id,omitempty"`
	// The sequence number of the frame
	SequenceNumber uint64 `protobuf:"varint,20,opt,name=sequence_number,json=sequenceNumber,proto3" json:"sequence_number,omitempty"`
	// The time in seconds after which the frame needs to be refreshed
	AutoRefreshInterval uint64 `protobuf:"varint,21,opt,name=auto_refresh_interval,json=autoRefreshInterval,proto3" json:"auto_refresh_interval,omitempty"`
	// The width of the frame, with the possible values being 3, 4, 6, 8, 9, and 12
	Width uint64 `protobuf:"varint,22,opt,name=width,proto3" json:"width,omitempty"`
	// The height of the frame in vh (viewport height)
	Height        uint64 `protobuf:"varint,23,opt,name=height,proto3" json:"height,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EnclaveFrame) Reset() {
	*x = EnclaveFrame{}
	mi := &file_vault_commons_scailo_proto_msgTypes[29]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EnclaveFrame) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EnclaveFrame) ProtoMessage() {}

func (x *EnclaveFrame) ProtoReflect() protoreflect.Message {
	mi := &file_vault_commons_scailo_proto_msgTypes[29]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EnclaveFrame.ProtoReflect.Descriptor instead.
func (*EnclaveFrame) Descriptor() ([]byte, []int) {
	return file_vault_commons_scailo_proto_rawDescGZIP(), []int{29}
}

func (x *EnclaveFrame) GetEntityUuid() string {
	if x != nil {
		return x.EntityUuid
	}
	return ""
}

func (x *EnclaveFrame) GetMetadata() *EmployeeMetadata {
	if x != nil {
		return x.Metadata
	}
	return nil
}

func (x *EnclaveFrame) GetUserId() uint64 {
	if x != nil {
		return x.UserId
	}
	return 0
}

func (x *EnclaveFrame) GetVaultFileId() uint64 {
	if x != nil {
		return x.VaultFileId
	}
	return 0
}

func (x *EnclaveFrame) GetSequenceNumber() uint64 {
	if x != nil {
		return x.SequenceNumber
	}
	return 0
}

func (x *EnclaveFrame) GetAutoRefreshInterval() uint64 {
	if x != nil {
		return x.AutoRefreshInterval
	}
	return 0
}

func (x *EnclaveFrame) GetWidth() uint64 {
	if x != nil {
		return x.Width
	}
	return 0
}

func (x *EnclaveFrame) GetHeight() uint64 {
	if x != nil {
		return x.Height
	}
	return 0
}

// Describes the data that is returned after setting up a frame
type EnclaveFrameSetup struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Stores a globally unique entity UUID. This will be set at the organization level
	EntityUuid string `protobuf:"bytes,1,opt,name=entity_uuid,json=entityUuid,proto3" json:"entity_uuid,omitempty"`
	// Stores the expiry timestamp of the frame
	ExpiresAt uint64 `protobuf:"varint,10,opt,name=expires_at,json=expiresAt,proto3" json:"expires_at,omitempty"`
	// Stores the unique identifier of the application
	EnclaveName string `protobuf:"bytes,12,opt,name=enclave_name,json=enclaveName,proto3" json:"enclave_name,omitempty"`
	// Stores the endpoint of the application execution
	AppEndpoint string `protobuf:"bytes,13,opt,name=app_endpoint,json=appEndpoint,proto3" json:"app_endpoint,omitempty"`
	// Stores the UUID of the enclave frame
	EnclaveFrameUuid string `protobuf:"bytes,20,opt,name=enclave_frame_uuid,json=enclaveFrameUuid,proto3" json:"enclave_frame_uuid,omitempty"`
	// Stores the UUID of the file
	FileUuid string `protobuf:"bytes,21,opt,name=file_uuid,json=fileUuid,proto3" json:"file_uuid,omitempty"`
	// Stores the version number of the enclave
	AppVersion string `protobuf:"bytes,22,opt,name=app_version,json=appVersion,proto3" json:"app_version,omitempty"`
	// The sequence number of the frame
	SequenceNumber uint64 `protobuf:"varint,30,opt,name=sequence_number,json=sequenceNumber,proto3" json:"sequence_number,omitempty"`
	// The time in seconds after which the frame needs to be refreshed
	AutoRefreshInterval uint64 `protobuf:"varint,31,opt,name=auto_refresh_interval,json=autoRefreshInterval,proto3" json:"auto_refresh_interval,omitempty"`
	// The width of the frame, with the possible values being 3, 4, 6, 8, 9, and 12
	Width uint64 `protobuf:"varint,32,opt,name=width,proto3" json:"width,omitempty"`
	// The height of the frame in vh (viewport height)
	Height        uint64 `protobuf:"varint,33,opt,name=height,proto3" json:"height,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EnclaveFrameSetup) Reset() {
	*x = EnclaveFrameSetup{}
	mi := &file_vault_commons_scailo_proto_msgTypes[30]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EnclaveFrameSetup) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EnclaveFrameSetup) ProtoMessage() {}

func (x *EnclaveFrameSetup) ProtoReflect() protoreflect.Message {
	mi := &file_vault_commons_scailo_proto_msgTypes[30]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EnclaveFrameSetup.ProtoReflect.Descriptor instead.
func (*EnclaveFrameSetup) Descriptor() ([]byte, []int) {
	return file_vault_commons_scailo_proto_rawDescGZIP(), []int{30}
}

func (x *EnclaveFrameSetup) GetEntityUuid() string {
	if x != nil {
		return x.EntityUuid
	}
	return ""
}

func (x *EnclaveFrameSetup) GetExpiresAt() uint64 {
	if x != nil {
		return x.ExpiresAt
	}
	return 0
}

func (x *EnclaveFrameSetup) GetEnclaveName() string {
	if x != nil {
		return x.EnclaveName
	}
	return ""
}

func (x *EnclaveFrameSetup) GetAppEndpoint() string {
	if x != nil {
		return x.AppEndpoint
	}
	return ""
}

func (x *EnclaveFrameSetup) GetEnclaveFrameUuid() string {
	if x != nil {
		return x.EnclaveFrameUuid
	}
	return ""
}

func (x *EnclaveFrameSetup) GetFileUuid() string {
	if x != nil {
		return x.FileUuid
	}
	return ""
}

func (x *EnclaveFrameSetup) GetAppVersion() string {
	if x != nil {
		return x.AppVersion
	}
	return ""
}

func (x *EnclaveFrameSetup) GetSequenceNumber() uint64 {
	if x != nil {
		return x.SequenceNumber
	}
	return 0
}

func (x *EnclaveFrameSetup) GetAutoRefreshInterval() uint64 {
	if x != nil {
		return x.AutoRefreshInterval
	}
	return 0
}

func (x *EnclaveFrameSetup) GetWidth() uint64 {
	if x != nil {
		return x.Width
	}
	return 0
}

func (x *EnclaveFrameSetup) GetHeight() uint64 {
	if x != nil {
		return x.Height
	}
	return 0
}

// Describes the list of enclave frames that have been setup
type EnclaveFrameSetupList struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// List of setup frames
	List          []*EnclaveFrameSetup `protobuf:"bytes,1,rep,name=list,proto3" json:"list,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EnclaveFrameSetupList) Reset() {
	*x = EnclaveFrameSetupList{}
	mi := &file_vault_commons_scailo_proto_msgTypes[31]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EnclaveFrameSetupList) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EnclaveFrameSetupList) ProtoMessage() {}

func (x *EnclaveFrameSetupList) ProtoReflect() protoreflect.Message {
	mi := &file_vault_commons_scailo_proto_msgTypes[31]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EnclaveFrameSetupList.ProtoReflect.Descriptor instead.
func (*EnclaveFrameSetupList) Descriptor() ([]byte, []int) {
	return file_vault_commons_scailo_proto_rawDescGZIP(), []int{31}
}

func (x *EnclaveFrameSetupList) GetList() []*EnclaveFrameSetup {
	if x != nil {
		return x.List
	}
	return nil
}

type VaultSearchReq struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// If true, then returns only active records. If false, then returns only inactive records
	IsActive BOOL_FILTER `protobuf:"varint,1,opt,name=is_active,json=isActive,proto3,enum=Scailo.BOOL_FILTER" json:"is_active,omitempty"`
	// The number of records that need to be sent in the response. Returns all records if it is set to -1
	Count int64 `protobuf:"varint,2,opt,name=count,proto3" json:"count,omitempty"`
	// The number that need to be offset by before fetching the records
	Offset uint64 `protobuf:"varint,3,opt,name=offset,proto3" json:"offset,omitempty"`
	// The sort order that is to be used to fetch the pagination response
	SortOrder SORT_ORDER `protobuf:"varint,4,opt,name=sort_order,json=sortOrder,proto3,enum=Scailo.SORT_ORDER" json:"sort_order,omitempty"`
	// The sort key that is to be used to fetch the pagination response
	SortKey VAULT_SORT_KEY `protobuf:"varint,5,opt,name=sort_key,json=sortKey,proto3,enum=Scailo.VAULT_SORT_KEY" json:"sort_key,omitempty"`
	// The minimum timestamp that needs to be considered to filter by creation
	CreationTimestampStart uint64 `protobuf:"varint,101,opt,name=creation_timestamp_start,json=creationTimestampStart,proto3" json:"creation_timestamp_start,omitempty"`
	// The maximum timestamp that needs to be considered to filter by creation
	CreationTimestampEnd uint64 `protobuf:"varint,102,opt,name=creation_timestamp_end,json=creationTimestampEnd,proto3" json:"creation_timestamp_end,omitempty"`
	// The minimum timestamp that needs to be considered to filter by modification
	ModificationTimestampStart uint64 `protobuf:"varint,103,opt,name=modification_timestamp_start,json=modificationTimestampStart,proto3" json:"modification_timestamp_start,omitempty"`
	// The maximum timestamp that needs to be considered to filter by modification
	ModificationTimestampEnd uint64 `protobuf:"varint,104,opt,name=modification_timestamp_end,json=modificationTimestampEnd,proto3" json:"modification_timestamp_end,omitempty"`
	// The entity UUID that is to be used to filter records
	EntityUuid string `protobuf:"bytes,8,opt,name=entity_uuid,json=entityUuid,proto3" json:"entity_uuid,omitempty"`
	// Limit the search to the given ref_for
	RefFor VAULT_REF_FOR `protobuf:"varint,9,opt,name=ref_for,json=refFor,proto3,enum=Scailo.VAULT_REF_FOR" json:"ref_for,omitempty"`
	// Limit the search to an optional folder
	FolderUuid string `protobuf:"bytes,10,opt,name=folder_uuid,json=folderUuid,proto3" json:"folder_uuid,omitempty"`
	// Describes the key with which the search operation needs to be performed
	SearchKey     string `protobuf:"bytes,11,opt,name=search_key,json=searchKey,proto3" json:"search_key,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *VaultSearchReq) Reset() {
	*x = VaultSearchReq{}
	mi := &file_vault_commons_scailo_proto_msgTypes[32]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VaultSearchReq) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VaultSearchReq) ProtoMessage() {}

func (x *VaultSearchReq) ProtoReflect() protoreflect.Message {
	mi := &file_vault_commons_scailo_proto_msgTypes[32]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VaultSearchReq.ProtoReflect.Descriptor instead.
func (*VaultSearchReq) Descriptor() ([]byte, []int) {
	return file_vault_commons_scailo_proto_rawDescGZIP(), []int{32}
}

func (x *VaultSearchReq) GetIsActive() BOOL_FILTER {
	if x != nil {
		return x.IsActive
	}
	return BOOL_FILTER_BOOL_FILTER_ANY_UNSPECIFIED
}

func (x *VaultSearchReq) GetCount() int64 {
	if x != nil {
		return x.Count
	}
	return 0
}

func (x *VaultSearchReq) GetOffset() uint64 {
	if x != nil {
		return x.Offset
	}
	return 0
}

func (x *VaultSearchReq) GetSortOrder() SORT_ORDER {
	if x != nil {
		return x.SortOrder
	}
	return SORT_ORDER_ASCENDING_UNSPECIFIED
}

func (x *VaultSearchReq) GetSortKey() VAULT_SORT_KEY {
	if x != nil {
		return x.SortKey
	}
	return VAULT_SORT_KEY_VAULT_SORT_KEY_ID_UNSPECIFIED
}

func (x *VaultSearchReq) GetCreationTimestampStart() uint64 {
	if x != nil {
		return x.CreationTimestampStart
	}
	return 0
}

func (x *VaultSearchReq) GetCreationTimestampEnd() uint64 {
	if x != nil {
		return x.CreationTimestampEnd
	}
	return 0
}

func (x *VaultSearchReq) GetModificationTimestampStart() uint64 {
	if x != nil {
		return x.ModificationTimestampStart
	}
	return 0
}

func (x *VaultSearchReq) GetModificationTimestampEnd() uint64 {
	if x != nil {
		return x.ModificationTimestampEnd
	}
	return 0
}

func (x *VaultSearchReq) GetEntityUuid() string {
	if x != nil {
		return x.EntityUuid
	}
	return ""
}

func (x *VaultSearchReq) GetRefFor() VAULT_REF_FOR {
	if x != nil {
		return x.RefFor
	}
	return VAULT_REF_FOR_VAULT_REF_FOR_ANY_UNSPECIFIED
}

func (x *VaultSearchReq) GetFolderUuid() string {
	if x != nil {
		return x.FolderUuid
	}
	return ""
}

func (x *VaultSearchReq) GetSearchKey() string {
	if x != nil {
		return x.SearchKey
	}
	return ""
}

// Describes the search information of vault files and folders into a single message
type VaultSearchResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The search name
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// The type of the file
	Type VAULT_REF_FOR `protobuf:"varint,2,opt,name=type,proto3,enum=Scailo.VAULT_REF_FOR" json:"type,omitempty"`
	// The ID of the element
	ElementId uint64 `protobuf:"varint,3,opt,name=element_id,json=elementId,proto3" json:"element_id,omitempty"`
	// The UUID of the element
	ElementUuid string `protobuf:"bytes,4,opt,name=element_uuid,json=elementUuid,proto3" json:"element_uuid,omitempty"`
	// The full path of the folder or the file
	Path string `protobuf:"bytes,5,opt,name=path,proto3" json:"path,omitempty"`
	// The link to the parent folder
	ParentFolderUuid string `protobuf:"bytes,6,opt,name=parent_folder_uuid,json=parentFolderUuid,proto3" json:"parent_folder_uuid,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *VaultSearchResponse) Reset() {
	*x = VaultSearchResponse{}
	mi := &file_vault_commons_scailo_proto_msgTypes[33]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VaultSearchResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VaultSearchResponse) ProtoMessage() {}

func (x *VaultSearchResponse) ProtoReflect() protoreflect.Message {
	mi := &file_vault_commons_scailo_proto_msgTypes[33]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VaultSearchResponse.ProtoReflect.Descriptor instead.
func (*VaultSearchResponse) Descriptor() ([]byte, []int) {
	return file_vault_commons_scailo_proto_rawDescGZIP(), []int{33}
}

func (x *VaultSearchResponse) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *VaultSearchResponse) GetType() VAULT_REF_FOR {
	if x != nil {
		return x.Type
	}
	return VAULT_REF_FOR_VAULT_REF_FOR_ANY_UNSPECIFIED
}

func (x *VaultSearchResponse) GetElementId() uint64 {
	if x != nil {
		return x.ElementId
	}
	return 0
}

func (x *VaultSearchResponse) GetElementUuid() string {
	if x != nil {
		return x.ElementUuid
	}
	return ""
}

func (x *VaultSearchResponse) GetPath() string {
	if x != nil {
		return x.Path
	}
	return ""
}

func (x *VaultSearchResponse) GetParentFolderUuid() string {
	if x != nil {
		return x.ParentFolderUuid
	}
	return ""
}

// Describes the message consisting of the list of vault search response
type VaultSearchResponsesList struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// List of search responses
	List          []*VaultSearchResponse `protobuf:"bytes,1,rep,name=list,proto3" json:"list,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *VaultSearchResponsesList) Reset() {
	*x = VaultSearchResponsesList{}
	mi := &file_vault_commons_scailo_proto_msgTypes[34]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VaultSearchResponsesList) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VaultSearchResponsesList) ProtoMessage() {}

func (x *VaultSearchResponsesList) ProtoReflect() protoreflect.Message {
	mi := &file_vault_commons_scailo_proto_msgTypes[34]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VaultSearchResponsesList.ProtoReflect.Descriptor instead.
func (*VaultSearchResponsesList) Descriptor() ([]byte, []int) {
	return file_vault_commons_scailo_proto_rawDescGZIP(), []int{34}
}

func (x *VaultSearchResponsesList) GetList() []*VaultSearchResponse {
	if x != nil {
		return x.List
	}
	return nil
}

// Describes the message to test if the file or folder already exists in the given folder UUID
type VaultDuplicateCheckReq struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The name of the file/folder
	Name string `protobuf:"bytes,10,opt,name=name,proto3" json:"name,omitempty"`
	// The UUID of the folder that the file/folder will reside in
	FolderUuid    string `protobuf:"bytes,13,opt,name=folder_uuid,json=folderUuid,proto3" json:"folder_uuid,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *VaultDuplicateCheckReq) Reset() {
	*x = VaultDuplicateCheckReq{}
	mi := &file_vault_commons_scailo_proto_msgTypes[35]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VaultDuplicateCheckReq) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VaultDuplicateCheckReq) ProtoMessage() {}

func (x *VaultDuplicateCheckReq) ProtoReflect() protoreflect.Message {
	mi := &file_vault_commons_scailo_proto_msgTypes[35]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VaultDuplicateCheckReq.ProtoReflect.Descriptor instead.
func (*VaultDuplicateCheckReq) Descriptor() ([]byte, []int) {
	return file_vault_commons_scailo_proto_rawDescGZIP(), []int{35}
}

func (x *VaultDuplicateCheckReq) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *VaultDuplicateCheckReq) GetFolderUuid() string {
	if x != nil {
		return x.FolderUuid
	}
	return ""
}

// Describes the access log of every file or folder
type VaultAccessLog struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Stores a globally unique entity UUID. This will be set at the organization level
	EntityUuid string `protobuf:"bytes,1,opt,name=entity_uuid,json=entityUuid,proto3" json:"entity_uuid,omitempty"`
	// Stores the metadata of this user
	Metadata *EmployeeMetadata `protobuf:"bytes,2,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// Stores the reference for which this access log is applicable
	RefFor VAULT_REF_FOR `protobuf:"varint,10,opt,name=ref_for,json=refFor,proto3,enum=Scailo.VAULT_REF_FOR" json:"ref_for,omitempty"`
	// Stores the ID of the underlying file or folder that has been accessed
	RefId uint64 `protobuf:"varint,11,opt,name=ref_id,json=refId,proto3" json:"ref_id,omitempty"`
	// Stores the username of the user who accessed this resource
	Username string `protobuf:"bytes,12,opt,name=username,proto3" json:"username,omitempty"`
	// Stores the IP address from where the resource was accessed
	IpAddr string `protobuf:"bytes,13,opt,name=ip_addr,json=ipAddr,proto3" json:"ip_addr,omitempty"`
	// Stores the operation that was performed (Add/Move/Rename/Delete/Download)
	Operation VAULT_ACCESS_LOG_OPERATION `protobuf:"varint,14,opt,name=operation,proto3,enum=Scailo.VAULT_ACCESS_LOG_OPERATION" json:"operation,omitempty"`
	// Stores the comment that describes the operation
	Comment       string `protobuf:"bytes,15,opt,name=comment,proto3" json:"comment,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *VaultAccessLog) Reset() {
	*x = VaultAccessLog{}
	mi := &file_vault_commons_scailo_proto_msgTypes[36]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VaultAccessLog) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VaultAccessLog) ProtoMessage() {}

func (x *VaultAccessLog) ProtoReflect() protoreflect.Message {
	mi := &file_vault_commons_scailo_proto_msgTypes[36]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VaultAccessLog.ProtoReflect.Descriptor instead.
func (*VaultAccessLog) Descriptor() ([]byte, []int) {
	return file_vault_commons_scailo_proto_rawDescGZIP(), []int{36}
}

func (x *VaultAccessLog) GetEntityUuid() string {
	if x != nil {
		return x.EntityUuid
	}
	return ""
}

func (x *VaultAccessLog) GetMetadata() *EmployeeMetadata {
	if x != nil {
		return x.Metadata
	}
	return nil
}

func (x *VaultAccessLog) GetRefFor() VAULT_REF_FOR {
	if x != nil {
		return x.RefFor
	}
	return VAULT_REF_FOR_VAULT_REF_FOR_ANY_UNSPECIFIED
}

func (x *VaultAccessLog) GetRefId() uint64 {
	if x != nil {
		return x.RefId
	}
	return 0
}

func (x *VaultAccessLog) GetUsername() string {
	if x != nil {
		return x.Username
	}
	return ""
}

func (x *VaultAccessLog) GetIpAddr() string {
	if x != nil {
		return x.IpAddr
	}
	return ""
}

func (x *VaultAccessLog) GetOperation() VAULT_ACCESS_LOG_OPERATION {
	if x != nil {
		return x.Operation
	}
	return VAULT_ACCESS_LOG_OPERATION_VAULT_ACCESS_LOG_OPERATION_ANY_UNSPECIFIED
}

func (x *VaultAccessLog) GetComment() string {
	if x != nil {
		return x.Comment
	}
	return ""
}

// Describes the necessary parameters to create an access log
type VaultAccessLogCreateRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Stores a globally unique entity UUID. This will be set at the organization level
	EntityUuid string `protobuf:"bytes,1,opt,name=entity_uuid,json=entityUuid,proto3" json:"entity_uuid,omitempty"`
	// Stores the reference for which this access log is applicable
	RefFor VAULT_REF_FOR `protobuf:"varint,10,opt,name=ref_for,json=refFor,proto3,enum=Scailo.VAULT_REF_FOR" json:"ref_for,omitempty"`
	// Stores the ID of the underlying file or folder that has been accessed
	RefId uint64 `protobuf:"varint,11,opt,name=ref_id,json=refId,proto3" json:"ref_id,omitempty"`
	// Stores the username of the user who accessed this resource
	Username string `protobuf:"bytes,12,opt,name=username,proto3" json:"username,omitempty"`
	// Stores the IP address from where the resource was accessed
	IpAddr string `protobuf:"bytes,13,opt,name=ip_addr,json=ipAddr,proto3" json:"ip_addr,omitempty"`
	// Stores the operation that was performed (Add/Move/Rename/Delete/Download)
	Operation VAULT_ACCESS_LOG_OPERATION `protobuf:"varint,14,opt,name=operation,proto3,enum=Scailo.VAULT_ACCESS_LOG_OPERATION" json:"operation,omitempty"`
	// Stores the comment that describes the operation
	Comment       string `protobuf:"bytes,15,opt,name=comment,proto3" json:"comment,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *VaultAccessLogCreateRequest) Reset() {
	*x = VaultAccessLogCreateRequest{}
	mi := &file_vault_commons_scailo_proto_msgTypes[37]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VaultAccessLogCreateRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VaultAccessLogCreateRequest) ProtoMessage() {}

func (x *VaultAccessLogCreateRequest) ProtoReflect() protoreflect.Message {
	mi := &file_vault_commons_scailo_proto_msgTypes[37]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VaultAccessLogCreateRequest.ProtoReflect.Descriptor instead.
func (*VaultAccessLogCreateRequest) Descriptor() ([]byte, []int) {
	return file_vault_commons_scailo_proto_rawDescGZIP(), []int{37}
}

func (x *VaultAccessLogCreateRequest) GetEntityUuid() string {
	if x != nil {
		return x.EntityUuid
	}
	return ""
}

func (x *VaultAccessLogCreateRequest) GetRefFor() VAULT_REF_FOR {
	if x != nil {
		return x.RefFor
	}
	return VAULT_REF_FOR_VAULT_REF_FOR_ANY_UNSPECIFIED
}

func (x *VaultAccessLogCreateRequest) GetRefId() uint64 {
	if x != nil {
		return x.RefId
	}
	return 0
}

func (x *VaultAccessLogCreateRequest) GetUsername() string {
	if x != nil {
		return x.Username
	}
	return ""
}

func (x *VaultAccessLogCreateRequest) GetIpAddr() string {
	if x != nil {
		return x.IpAddr
	}
	return ""
}

func (x *VaultAccessLogCreateRequest) GetOperation() VAULT_ACCESS_LOG_OPERATION {
	if x != nil {
		return x.Operation
	}
	return VAULT_ACCESS_LOG_OPERATION_VAULT_ACCESS_LOG_OPERATION_ANY_UNSPECIFIED
}

func (x *VaultAccessLogCreateRequest) GetComment() string {
	if x != nil {
		return x.Comment
	}
	return ""
}

// Describes the message consisting of the list of access logs
type VaultAccessLogsList struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// List of access logs
	List          []*VaultAccessLog `protobuf:"bytes,1,rep,name=list,proto3" json:"list,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *VaultAccessLogsList) Reset() {
	*x = VaultAccessLogsList{}
	mi := &file_vault_commons_scailo_proto_msgTypes[38]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VaultAccessLogsList) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VaultAccessLogsList) ProtoMessage() {}

func (x *VaultAccessLogsList) ProtoReflect() protoreflect.Message {
	mi := &file_vault_commons_scailo_proto_msgTypes[38]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VaultAccessLogsList.ProtoReflect.Descriptor instead.
func (*VaultAccessLogsList) Descriptor() ([]byte, []int) {
	return file_vault_commons_scailo_proto_rawDescGZIP(), []int{38}
}

func (x *VaultAccessLogsList) GetList() []*VaultAccessLog {
	if x != nil {
		return x.List
	}
	return nil
}

var File_vault_commons_scailo_proto protoreflect.FileDescriptor

const file_vault_commons_scailo_proto_rawDesc = "" +
	"\n" +
	"\x1avault_commons.scailo.proto\x12\x06Scailo\x1a\x11base.scailo.proto\x1a\x1bbuf/validate/validate.proto\"\xf1\x01\n" +
	"\x0fVaultPermission\x12\x1f\n" +
	"\ventity_uuid\x18\x01 \x01(\tR\n" +
	"entityUuid\x124\n" +
	"\bmetadata\x18\x02 \x01(\v2\x18.Scailo.EmployeeMetadataR\bmetadata\x12.\n" +
	"\aref_for\x18\n" +
	" \x01(\x0e2\x15.Scailo.VAULT_REF_FORR\x06refFor\x12\x15\n" +
	"\x06ref_id\x18\v \x01(\x04R\x05refId\x12\x17\n" +
	"\arole_id\x18\f \x01(\x04R\x06roleId\x12'\n" +
	"\x0fpermission_code\x18\r \x01(\x04R\x0epermissionCode\"\xd8\x01\n" +
	"\x19VaultPermissionAddRequest\x12\x1f\n" +
	"\ventity_uuid\x18\x01 \x01(\tR\n" +
	"entityUuid\x12!\n" +
	"\fuser_comment\x18\x02 \x01(\tR\vuserComment\x12#\n" +
	"\bref_uuid\x18\v \x01(\tB\b\xbaH\x05r\x03\xb0\x01\x01R\arefUuid\x12 \n" +
	"\arole_id\x18\f \x01(\x04B\a\xbaH\x042\x02 \x00R\x06roleId\x120\n" +
	"\x0fpermission_code\x18\r \x01(\x04B\a\xbaH\x042\x02 \x00R\x0epermissionCode\"\x91\x01\n" +
	"\x1cVaultPermissionModifyRequest\x12\x1c\n" +
	"\x04uuid\x18\x01 \x01(\tB\b\xbaH\x05r\x03\xb0\x01\x01R\x04uuid\x12!\n" +
	"\fuser_comment\x18\x02 \x01(\tR\vuserComment\x120\n" +
	"\x0fpermission_code\x18\r \x01(\x04B\a\xbaH\x042\x02 \x00R\x0epermissionCode\"j\n" +
	"\fGixResources\x12\x1e\n" +
	"\n" +
	"html_entry\x18\x01 \x01(\tR\n" +
	"html_entry\x12\x14\n" +
	"\x05logos\x18\x02 \x03(\tR\x05logos\x12$\n" +
	"\rexternal_apis\x18\x03 \x03(\tR\rexternal_apis\"\xc5\x02\n" +
	"\vGiXManifest\x12*\n" +
	"\x10manifest_version\x18\x01 \x01(\tR\x10manifest_version\x12 \n" +
	"\vapp_version\x18\x02 \x01(\tR\vapp_version\x12\x1a\n" +
	"\bapp_name\x18\x03 \x01(\tR\bapp_name\x124\n" +
	"\x15app_unique_identifier\x18\x04 \x01(\tR\x15app_unique_identifier\x120\n" +
	"\x13min_genesis_version\x18\x05 \x01(\tR\x13min_genesis_version\x120\n" +
	"\x13max_genesis_version\x18\x06 \x01(\tR\x13max_genesis_version\x122\n" +
	"\tresources\x18\a \x01(\v2\x14.Scailo.GixResourcesR\tresources\"\xd4\x03\n" +
	"\tGiXAppRun\x12\x1f\n" +
	"\ventity_uuid\x18\x01 \x01(\tR\n" +
	"entityUuid\x124\n" +
	"\bmetadata\x18\x02 \x01(\v2\x18.Scailo.EmployeeMetadataR\bmetadata\x12\"\n" +
	"\rvault_file_id\x18\n" +
	" \x01(\x04R\vvaultFileId\x121\n" +
	"\x15vault_file_version_id\x18\v \x01(\x04R\x12vaultFileVersionId\x122\n" +
	"\x15app_unique_identifier\x18\f \x01(\tR\x13appUniqueIdentifier\x12%\n" +
	"\x0eextracted_path\x18\r \x01(\tR\rextractedPath\x12\x17\n" +
	"\aip_addr\x18\x0e \x01(\tR\x06ipAddr\x12/\n" +
	"\bmanifest\x18\x0f \x01(\v2\x13.Scailo.GiXManifestR\bmanifest\x12\x15\n" +
	"\x06run_by\x18\x10 \x01(\tR\x05runBy\x12\x1f\n" +
	"\vapp_version\x18\x1e \x01(\tR\n" +
	"appVersion\x12\x19\n" +
	"\bapp_name\x18\x1f \x01(\tR\aappName\x12!\n" +
	"\fapp_endpoint\x18( \x01(\tR\vappEndpoint\"7\n" +
	"\x0eGiXAppRunsList\x12%\n" +
	"\x04list\x18\x01 \x03(\v2\x11.Scailo.GiXAppRunR\x04list\"\xab\x03\n" +
	"\x11GiXAppRunCountReq\x120\n" +
	"\tis_active\x18\x01 \x01(\x0e2\x13.Scailo.BOOL_FILTERR\bisActive\x128\n" +
	"\x18creation_timestamp_start\x18e \x01(\x04R\x16creationTimestampStart\x124\n" +
	"\x16creation_timestamp_end\x18f \x01(\x04R\x14creationTimestampEnd\x12@\n" +
	"\x1cmodification_timestamp_start\x18g \x01(\x04R\x1amodificationTimestampStart\x12<\n" +
	"\x1amodification_timestamp_end\x18h \x01(\x04R\x18modificationTimestampEnd\x12&\n" +
	"\x0fvault_file_uuid\x18\x14 \x01(\tR\rvaultFileUuid\x125\n" +
	"\x17vault_file_version_uuid\x18\x15 \x01(\tR\x14vaultFileVersionUuid\x12\x15\n" +
	"\x06run_by\x18\x1e \x01(\tR\x05runBy\"\xf5\x03\n" +
	"\x12GiXAppRunFilterReq\x120\n" +
	"\tis_active\x18\x01 \x01(\x0e2\x13.Scailo.BOOL_FILTERR\bisActive\x12&\n" +
	"\x05count\x18\x02 \x01(\x03B\x10\xbaH\r\"\v(\xff\xff\xff\xff\xff\xff\xff\xff\xff\x01R\x05count\x12\x1f\n" +
	"\x06offset\x18\x03 \x01(\x04B\a\xbaH\x042\x02(\x00R\x06offset\x128\n" +
	"\x18creation_timestamp_start\x18e \x01(\x04R\x16creationTimestampStart\x124\n" +
	"\x16creation_timestamp_end\x18f \x01(\x04R\x14creationTimestampEnd\x12@\n" +
	"\x1cmodification_timestamp_start\x18g \x01(\x04R\x1amodificationTimestampStart\x12<\n" +
	"\x1amodification_timestamp_end\x18h \x01(\x04R\x18modificationTimestampEnd\x12&\n" +
	"\x0fvault_file_uuid\x18\x14 \x01(\tR\rvaultFileUuid\x125\n" +
	"\x17vault_file_version_uuid\x18\x15 \x01(\tR\x14vaultFileVersionUuid\x12\x15\n" +
	"\x06run_by\x18\x1e \x01(\tR\x05runBy\"X\n" +
	"\x10EnclaveResources\x12\x14\n" +
	"\x05logos\x18\x01 \x03(\tR\x05logos\x12\x18\n" +
	"\afolders\x18\x02 \x03(\tR\afolders\x12\x14\n" +
	"\x05files\x18\x03 \x03(\tR\x05files\"d\n" +
	"\x1aEnclaveManifestEnvVariable\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value\x12\x1c\n" +
	"\tis_secret\x18\x03 \x01(\bR\tis_secret\"\x9c\x04\n" +
	"\x0fEnclaveManifest\x12*\n" +
	"\x10manifest_version\x18\x01 \x01(\tR\x10manifest_version\x12E\n" +
	"\x0fenclave_runtime\x18\x02 \x01(\tB\x1b\xbaH\x18r\x16R\x04nodeR\x06golangR\x06pythonR\x0fenclave_runtime\x12 \n" +
	"\vapp_version\x18\x03 \x01(\tR\vapp_version\x12\x1a\n" +
	"\bapp_name\x18\x04 \x01(\tR\bapp_name\x12\"\n" +
	"\fenclave_name\x18\x05 \x01(\tR\fenclave_name\x124\n" +
	"\x15app_unique_identifier\x18\x06 \x01(\tR\x15app_unique_identifier\x12\x1e\n" +
	"\n" +
	"start_exec\x18\a \x01(\tR\n" +
	"start_exec\x12\\\n" +
	"\x16entry_point_management\x18\b \x01(\tB$\xbaH!r\x1fR\n" +
	"direct_urlR\x11platform_redirectR\x16entry_point_management\x12H\n" +
	"\renv_variables\x18\t \x03(\v2\".Scailo.EnclaveManifestEnvVariableR\renv_variables\x126\n" +
	"\tresources\x18\n" +
	" \x01(\v2\x18.Scailo.EnclaveResourcesR\tresources\"\x9e\x03\n" +
	"\x0eEnclaveIngress\x12\x1f\n" +
	"\ventity_uuid\x18\x01 \x01(\tR\n" +
	"entityUuid\x124\n" +
	"\bmetadata\x18\x02 \x01(\v2\x18.Scailo.EmployeeMetadataR\bmetadata\x12\x14\n" +
	"\x05token\x18\n" +
	" \x01(\tR\x05token\x12\x1d\n" +
	"\n" +
	"expires_at\x18\v \x01(\x04R\texpiresAt\x12\"\n" +
	"\rvault_file_id\x18\x14 \x01(\x04R\vvaultFileId\x121\n" +
	"\x15vault_file_version_id\x18\x15 \x01(\x04R\x12vaultFileVersionId\x12!\n" +
	"\fenclave_name\x18\x16 \x01(\tR\venclaveName\x12\x17\n" +
	"\aip_addr\x18\x18 \x01(\tR\x06ipAddr\x12$\n" +
	"\x0erunner_user_id\x18\x1e \x01(\x04R\frunnerUserId\x12$\n" +
	"\x0erunner_role_id\x18\x1f \x01(\x04R\frunnerRoleId\x12!\n" +
	"\fapp_endpoint\x18< \x01(\tR\vappEndpoint\"B\n" +
	"\x14EnclaveIngressesList\x12*\n" +
	"\x04list\x18\x01 \x03(\v2\x16.Scailo.EnclaveIngressR\x04list\"\xe5\x03\n" +
	"\x16EnclaveIngressCountReq\x120\n" +
	"\tis_active\x18\x01 \x01(\x0e2\x13.Scailo.BOOL_FILTERR\bisActive\x128\n" +
	"\x18creation_timestamp_start\x18e \x01(\x04R\x16creationTimestampStart\x124\n" +
	"\x16creation_timestamp_end\x18f \x01(\x04R\x14creationTimestampEnd\x12@\n" +
	"\x1cmodification_timestamp_start\x18g \x01(\x04R\x1amodificationTimestampStart\x12<\n" +
	"\x1amodification_timestamp_end\x18h \x01(\x04R\x18modificationTimestampEnd\x12&\n" +
	"\x0fvault_file_uuid\x18\x14 \x01(\tR\rvaultFileUuid\x125\n" +
	"\x17vault_file_version_uuid\x18\x15 \x01(\tR\x14vaultFileVersionUuid\x12$\n" +
	"\x0erunner_user_id\x18\x1e \x01(\x04R\frunnerUserId\x12$\n" +
	"\x0erunner_role_id\x18\x1f \x01(\x04R\frunnerRoleId\"\xaf\x04\n" +
	"\x17EnclaveIngressFilterReq\x120\n" +
	"\tis_active\x18\x01 \x01(\x0e2\x13.Scailo.BOOL_FILTERR\bisActive\x12&\n" +
	"\x05count\x18\x02 \x01(\x03B\x10\xbaH\r\"\v(\xff\xff\xff\xff\xff\xff\xff\xff\xff\x01R\x05count\x12\x1f\n" +
	"\x06offset\x18\x03 \x01(\x04B\a\xbaH\x042\x02(\x00R\x06offset\x128\n" +
	"\x18creation_timestamp_start\x18e \x01(\x04R\x16creationTimestampStart\x124\n" +
	"\x16creation_timestamp_end\x18f \x01(\x04R\x14creationTimestampEnd\x12@\n" +
	"\x1cmodification_timestamp_start\x18g \x01(\x04R\x1amodificationTimestampStart\x12<\n" +
	"\x1amodification_timestamp_end\x18h \x01(\x04R\x18modificationTimestampEnd\x12&\n" +
	"\x0fvault_file_uuid\x18\x14 \x01(\tR\rvaultFileUuid\x125\n" +
	"\x17vault_file_version_uuid\x18\x15 \x01(\tR\x14vaultFileVersionUuid\x12$\n" +
	"\x0erunner_user_id\x18\x1e \x01(\x04R\frunnerUserId\x12$\n" +
	"\x0erunner_role_id\x18\x1f \x01(\x04R\frunnerRoleId\"3\n" +
	"\x1bVerifyEnclaveIngressRequest\x12\x14\n" +
	"\x05token\x18\x01 \x01(\tR\x05token\"\xb9\x01\n" +
	"\x1cVerifyEnclaveIngressResponse\x12!\n" +
	"\fenclave_name\x18\x01 \x01(\tR\venclaveName\x12\x1b\n" +
	"\tuser_uuid\x18\x02 \x01(\tR\buserUuid\x12\x1b\n" +
	"\trole_uuid\x18\x03 \x01(\tR\broleUuid\x12\x1d\n" +
	"\n" +
	"auth_token\x18\x04 \x01(\tR\tauthToken\x12\x1d\n" +
	"\n" +
	"expires_at\x18\x05 \x01(\x04R\texpiresAt\"\xa6\x01\n" +
	"$EnclaveEnvironmentVariableAddRequest\x12%\n" +
	"\tfile_uuid\x18\x01 \x01(\tB\b\xbaH\x05r\x03\xb0\x01\x01R\bfileUuid\x12\x1b\n" +
	"\x04name\x18\v \x01(\tB\a\xbaH\x04r\x02\x10\x01R\x04name\x12\x1d\n" +
	"\x05value\x18\f \x01(\tB\a\xbaH\x04r\x02\x10\x01R\x05value\x12\x1b\n" +
	"\tis_secret\x18\r \x01(\bR\bisSecret\"f\n" +
	"'EnclaveEnvironmentVariableUpdateRequest\x12\x1c\n" +
	"\x04uuid\x18\x01 \x01(\tB\b\xbaH\x05r\x03\xb0\x01\x01R\x04uuid\x12\x1d\n" +
	"\x05value\x18\v \x01(\tB\a\xbaH\x04r\x02\x10\x01R\x05value\"\xde\x01\n" +
	"\x1aEnclaveEnvironmentVariable\x12\x1f\n" +
	"\ventity_uuid\x18\x01 \x01(\tR\n" +
	"entityUuid\x124\n" +
	"\bmetadata\x18\x02 \x01(\v2\x18.Scailo.EmployeeMetadataR\bmetadata\x12\"\n" +
	"\rvault_file_id\x18\n" +
	" \x01(\x04R\vvaultFileId\x12\x12\n" +
	"\x04name\x18\v \x01(\tR\x04name\x12\x14\n" +
	"\x05value\x18\f \x01(\tR\x05value\x12\x1b\n" +
	"\tis_secret\x18\r \x01(\bR\bisSecret\"Y\n" +
	"\x1fEnclaveEnvironmentVariablesList\x126\n" +
	"\x04list\x18\x01 \x03(\v2\".Scailo.EnclaveEnvironmentVariableR\x04list\"a\n" +
	"\x17EnclaveDomainAddRequest\x12%\n" +
	"\tfile_uuid\x18\x01 \x01(\tB\b\xbaH\x05r\x03\xb0\x01\x01R\bfileUuid\x12\x1f\n" +
	"\x06domain\x18\v \x01(\tB\a\xbaH\x04r\x02h\x01R\x06domain\"\xd7\x01\n" +
	"\rEnclaveDomain\x12\x1f\n" +
	"\ventity_uuid\x18\x01 \x01(\tR\n" +
	"entityUuid\x124\n" +
	"\bmetadata\x18\x02 \x01(\v2\x18.Scailo.EmployeeMetadataR\bmetadata\x12\"\n" +
	"\rvault_file_id\x18\n" +
	" \x01(\x04R\vvaultFileId\x12\x1f\n" +
	"\x06domain\x18\v \x01(\tB\a\xbaH\x04r\x02h\x01R\x06domain\x12*\n" +
	"\fservice_addr\x18\f \x01(\tB\a\xbaH\x04r\x02h\x01R\vserviceAddr\"\xcf\x04\n" +
	"\x17EnclaveDomainsFilterReq\x120\n" +
	"\tis_active\x18\x01 \x01(\x0e2\x13.Scailo.BOOL_FILTERR\bisActive\x12&\n" +
	"\x05count\x18\x02 \x01(\x03B\x10\xbaH\r\"\v(\xff\xff\xff\xff\xff\xff\xff\xff\xff\x01R\x05count\x12\x1f\n" +
	"\x06offset\x18\x03 \x01(\x04B\a\xbaH\x042\x02(\x00R\x06offset\x121\n" +
	"\n" +
	"sort_order\x18\x04 \x01(\x0e2\x12.Scailo.SORT_ORDERR\tsortOrder\x12:\n" +
	"\bsort_key\x18\x05 \x01(\x0e2\x1f.Scailo.ENCLAVE_DOMAIN_SORT_KEYR\asortKey\x128\n" +
	"\x18creation_timestamp_start\x18e \x01(\x04R\x16creationTimestampStart\x124\n" +
	"\x16creation_timestamp_end\x18f \x01(\x04R\x14creationTimestampEnd\x12@\n" +
	"\x1cmodification_timestamp_start\x18g \x01(\x04R\x1amodificationTimestampStart\x12<\n" +
	"\x1amodification_timestamp_end\x18h \x01(\x04R\x18modificationTimestampEnd\x12\x1f\n" +
	"\ventity_uuid\x18\b \x01(\tR\n" +
	"entityUuid\x12\x16\n" +
	"\x06domain\x18\v \x01(\tR\x06domain\x12!\n" +
	"\fservice_addr\x18\f \x01(\tR\vserviceAddr\"?\n" +
	"\x12EnclaveDomainsList\x12)\n" +
	"\x04list\x18\x01 \x03(\v2\x15.Scailo.EnclaveDomainR\x04list\"G\n" +
	"\x17EnclaveDomainSuffixResp\x12\x16\n" +
	"\x06suffix\x18\x01 \x01(\tR\x06suffix\x12\x14\n" +
	"\x05relay\x18\x02 \x01(\tR\x05relay\"\xe5\x01\n" +
	"\x16EnclaveFrameAddRequest\x12%\n" +
	"\tfile_uuid\x18\x01 \x01(\tB\b\xbaH\x05r\x03\xb0\x01\x01R\bfileUuid\x120\n" +
	"\x0fsequence_number\x18\n" +
	" \x01(\x04B\a\xbaH\x042\x02 \x00R\x0esequenceNumber\x122\n" +
	"\x15auto_refresh_interval\x18\v \x01(\x04R\x13autoRefreshInterval\x12\x1d\n" +
	"\x05width\x18\f \x01(\x04B\a\xbaH\x042\x02 \x00R\x05width\x12\x1f\n" +
	"\x06height\x18\r \x01(\x04B\a\xbaH\x042\x02 \x00R\x06height\"\xc4\x01\n" +
	"\x19EnclaveFrameUpdateRequest\x12\x1c\n" +
	"\x04uuid\x18\x01 \x01(\tB\b\xbaH\x05r\x03\xb0\x01\x01R\x04uuid\x12'\n" +
	"\x0fsequence_number\x18\n" +
	" \x01(\x04R\x0esequenceNumber\x122\n" +
	"\x15auto_refresh_interval\x18\v \x01(\x04R\x13autoRefreshInterval\x12\x14\n" +
	"\x05width\x18\f \x01(\x04R\x05width\x12\x16\n" +
	"\x06height\x18\r \x01(\x04R\x06height\"\xad\x02\n" +
	"\fEnclaveFrame\x12\x1f\n" +
	"\ventity_uuid\x18\x01 \x01(\tR\n" +
	"entityUuid\x124\n" +
	"\bmetadata\x18\x02 \x01(\v2\x18.Scailo.EmployeeMetadataR\bmetadata\x12\x17\n" +
	"\auser_id\x18\n" +
	" \x01(\x04R\x06userId\x12\"\n" +
	"\rvault_file_id\x18\v \x01(\x04R\vvaultFileId\x12'\n" +
	"\x0fsequence_number\x18\x14 \x01(\x04R\x0esequenceNumber\x122\n" +
	"\x15auto_refresh_interval\x18\x15 \x01(\x04R\x13autoRefreshInterval\x12\x14\n" +
	"\x05width\x18\x16 \x01(\x04R\x05width\x12\x16\n" +
	"\x06height\x18\x17 \x01(\x04R\x06height\"\x90\x03\n" +
	"\x11EnclaveFrameSetup\x12\x1f\n" +
	"\ventity_uuid\x18\x01 \x01(\tR\n" +
	"entityUuid\x12\x1d\n" +
	"\n" +
	"expires_at\x18\n" +
	" \x01(\x04R\texpiresAt\x12!\n" +
	"\fenclave_name\x18\f \x01(\tR\venclaveName\x12!\n" +
	"\fapp_endpoint\x18\r \x01(\tR\vappEndpoint\x12,\n" +
	"\x12enclave_frame_uuid\x18\x14 \x01(\tR\x10enclaveFrameUuid\x12\x1b\n" +
	"\tfile_uuid\x18\x15 \x01(\tR\bfileUuid\x12\x1f\n" +
	"\vapp_version\x18\x16 \x01(\tR\n" +
	"appVersion\x12'\n" +
	"\x0fsequence_number\x18\x1e \x01(\x04R\x0esequenceNumber\x122\n" +
	"\x15auto_refresh_interval\x18\x1f \x01(\x04R\x13autoRefreshInterval\x12\x14\n" +
	"\x05width\x18  \x01(\x04R\x05width\x12\x16\n" +
	"\x06height\x18! \x01(\x04R\x06height\"F\n" +
	"\x15EnclaveFrameSetupList\x12-\n" +
	"\x04list\x18\x01 \x03(\v2\x19.Scailo.EnclaveFrameSetupR\x04list\"\xf2\x04\n" +
	"\x0eVaultSearchReq\x120\n" +
	"\tis_active\x18\x01 \x01(\x0e2\x13.Scailo.BOOL_FILTERR\bisActive\x12&\n" +
	"\x05count\x18\x02 \x01(\x03B\x10\xbaH\r\"\v(\xff\xff\xff\xff\xff\xff\xff\xff\xff\x01R\x05count\x12\x1f\n" +
	"\x06offset\x18\x03 \x01(\x04B\a\xbaH\x042\x02(\x00R\x06offset\x121\n" +
	"\n" +
	"sort_order\x18\x04 \x01(\x0e2\x12.Scailo.SORT_ORDERR\tsortOrder\x121\n" +
	"\bsort_key\x18\x05 \x01(\x0e2\x16.Scailo.VAULT_SORT_KEYR\asortKey\x128\n" +
	"\x18creation_timestamp_start\x18e \x01(\x04R\x16creationTimestampStart\x124\n" +
	"\x16creation_timestamp_end\x18f \x01(\x04R\x14creationTimestampEnd\x12@\n" +
	"\x1cmodification_timestamp_start\x18g \x01(\x04R\x1amodificationTimestampStart\x12<\n" +
	"\x1amodification_timestamp_end\x18h \x01(\x04R\x18modificationTimestampEnd\x12\x1f\n" +
	"\ventity_uuid\x18\b \x01(\tR\n" +
	"entityUuid\x12.\n" +
	"\aref_for\x18\t \x01(\x0e2\x15.Scailo.VAULT_REF_FORR\x06refFor\x12\x1f\n" +
	"\vfolder_uuid\x18\n" +
	" \x01(\tR\n" +
	"folderUuid\x12\x1d\n" +
	"\n" +
	"search_key\x18\v \x01(\tR\tsearchKey\"\xd8\x01\n" +
	"\x13VaultSearchResponse\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12)\n" +
	"\x04type\x18\x02 \x01(\x0e2\x15.Scailo.VAULT_REF_FORR\x04type\x12\x1d\n" +
	"\n" +
	"element_id\x18\x03 \x01(\x04R\telementId\x12!\n" +
	"\felement_uuid\x18\x04 \x01(\tR\velementUuid\x12\x12\n" +
	"\x04path\x18\x05 \x01(\tR\x04path\x12,\n" +
	"\x12parent_folder_uuid\x18\x06 \x01(\tR\x10parentFolderUuid\"K\n" +
	"\x18VaultSearchResponsesList\x12/\n" +
	"\x04list\x18\x01 \x03(\v2\x1b.Scailo.VaultSearchResponseR\x04list\"`\n" +
	"\x16VaultDuplicateCheckReq\x12\x1b\n" +
	"\x04name\x18\n" +
	" \x01(\tB\a\xbaH\x04r\x02\x10\x01R\x04name\x12)\n" +
	"\vfolder_uuid\x18\r \x01(\tB\b\xbaH\x05r\x03\xb0\x01\x01R\n" +
	"folderUuid\"\xbf\x02\n" +
	"\x0eVaultAccessLog\x12\x1f\n" +
	"\ventity_uuid\x18\x01 \x01(\tR\n" +
	"entityUuid\x124\n" +
	"\bmetadata\x18\x02 \x01(\v2\x18.Scailo.EmployeeMetadataR\bmetadata\x12.\n" +
	"\aref_for\x18\n" +
	" \x01(\x0e2\x15.Scailo.VAULT_REF_FORR\x06refFor\x12\x15\n" +
	"\x06ref_id\x18\v \x01(\x04R\x05refId\x12\x1a\n" +
	"\busername\x18\f \x01(\tR\busername\x12\x17\n" +
	"\aip_addr\x18\r \x01(\tR\x06ipAddr\x12@\n" +
	"\toperation\x18\x0e \x01(\x0e2\".Scailo.VAULT_ACCESS_LOG_OPERATIONR\toperation\x12\x18\n" +
	"\acomment\x18\x0f \x01(\tR\acomment\"\xb1\x02\n" +
	"\x1bVaultAccessLogCreateRequest\x12\x1f\n" +
	"\ventity_uuid\x18\x01 \x01(\tR\n" +
	"entityUuid\x12.\n" +
	"\aref_for\x18\n" +
	" \x01(\x0e2\x15.Scailo.VAULT_REF_FORR\x06refFor\x12\x1e\n" +
	"\x06ref_id\x18\v \x01(\x04B\a\xbaH\x042\x02 \x00R\x05refId\x12#\n" +
	"\busername\x18\f \x01(\tB\a\xbaH\x04r\x02\x10\x01R\busername\x12 \n" +
	"\aip_addr\x18\r \x01(\tB\a\xbaH\x04r\x02p\x01R\x06ipAddr\x12@\n" +
	"\toperation\x18\x0e \x01(\x0e2\".Scailo.VAULT_ACCESS_LOG_OPERATIONR\toperation\x12\x18\n" +
	"\acomment\x18\x0f \x01(\tR\acomment\"A\n" +
	"\x13VaultAccessLogsList\x12*\n" +
	"\x04list\x18\x01 \x03(\v2\x16.Scailo.VaultAccessLogR\x04list*d\n" +
	"\rVAULT_REF_FOR\x12!\n" +
	"\x1dVAULT_REF_FOR_ANY_UNSPECIFIED\x10\x00\x12\x16\n" +
	"\x12VAULT_REF_FOR_FILE\x10\x01\x12\x18\n" +
	"\x14VAULT_REF_FOR_FOLDER\x10\x02*\xa5\x02\n" +
	"\x15VAULT_PERMISSION_CODE\x12%\n" +
	"!VAULT_PERMISSION_CODE_UNSPECIFIED\x10\x00\x12\x1e\n" +
	"\x1aVAULT_PERMISSION_CODE_VIEW\x10\x01\x12\x1e\n" +
	"\x1aVAULT_PERMISSION_CODE_META\x10\x02\x12\"\n" +
	"\x1eVAULT_PERMISSION_CODE_DOWNLOAD\x10\x04\x12\x1d\n" +
	"\x19VAULT_PERMISSION_CODE_ADD\x10\b\x12 \n" +
	"\x1cVAULT_PERMISSION_CODE_DELETE\x10\x10\x12!\n" +
	"\x1dVAULT_PERMISSION_CODE_EXECUTE\x10 \x12\x1d\n" +
	"\x19VAULT_PERMISSION_CODE_ALL\x10?*\x91\x01\n" +
	"\x17ENCLAVE_DOMAIN_SORT_KEY\x12*\n" +
	"&ENCLAVE_DOMAIN_SORT_KEY_ID_UNSPECIFIED\x10\x00\x12&\n" +
	"\"ENCLAVE_DOMAIN_SORT_KEY_CREATED_AT\x10\x01\x12\"\n" +
	"\x1eENCLAVE_DOMAIN_SORT_KEY_DOMAIN\x10\n" +
	"*\x8b\x01\n" +
	"\x0eVAULT_SORT_KEY\x12!\n" +
	"\x1dVAULT_SORT_KEY_ID_UNSPECIFIED\x10\x00\x12\x1d\n" +
	"\x19VAULT_SORT_KEY_CREATED_AT\x10\x01\x12\x1e\n" +
	"\x1aVAULT_SORT_KEY_MODIFIED_AT\x10\x02\x12\x17\n" +
	"\x13VAULT_SORT_KEY_NAME\x10\n" +
	"*\xdb\x03\n" +
	"\x1aVAULT_ACCESS_LOG_OPERATION\x12.\n" +
	"*VAULT_ACCESS_LOG_OPERATION_ANY_UNSPECIFIED\x10\x00\x12%\n" +
	"!VAULT_ACCESS_LOG_OPERATION_CREATE\x10\x01\x12#\n" +
	"\x1fVAULT_ACCESS_LOG_OPERATION_MOVE\x10\x02\x12%\n" +
	"!VAULT_ACCESS_LOG_OPERATION_RENAME\x10\x03\x12%\n" +
	"!VAULT_ACCESS_LOG_OPERATION_DELETE\x10\x04\x12'\n" +
	"#VAULT_ACCESS_LOG_OPERATION_DOWNLOAD\x10\x05\x12%\n" +
	"!VAULT_ACCESS_LOG_OPERATION_UPLOAD\x10\x06\x12$\n" +
	" VAULT_ACCESS_LOG_OPERATION_UNZIP\x10\a\x12)\n" +
	"%VAULT_ACCESS_LOG_OPERATION_PERSISTENT\x10\b\x12*\n" +
	"&VAULT_ACCESS_LOG_OPERATION_PERMISSIONS\x10\t\x12&\n" +
	"\"VAULT_ACCESS_LOG_OPERATION_EXECUTE\x10\n" +
	"Bi\n" +
	"\n" +
	"com.ScailoB\x17VaultCommonsScailoProtoP\x01Z\n" +
	"Scailo/sdk\xa2\x02\x03SXX\xaa\x02\x06Scailo\xca\x02\x06Scailo\xe2\x02\x12Scailo\\GPBMetadata\xea\x02\x06Scailob\x06proto3"

var (
	file_vault_commons_scailo_proto_rawDescOnce sync.Once
	file_vault_commons_scailo_proto_rawDescData []byte
)

func file_vault_commons_scailo_proto_rawDescGZIP() []byte {
	file_vault_commons_scailo_proto_rawDescOnce.Do(func() {
		file_vault_commons_scailo_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_vault_commons_scailo_proto_rawDesc), len(file_vault_commons_scailo_proto_rawDesc)))
	})
	return file_vault_commons_scailo_proto_rawDescData
}

var file_vault_commons_scailo_proto_enumTypes = make([]protoimpl.EnumInfo, 5)
var file_vault_commons_scailo_proto_msgTypes = make([]protoimpl.MessageInfo, 39)
var file_vault_commons_scailo_proto_goTypes = []any{
	(VAULT_REF_FOR)(0),                              // 0: Scailo.VAULT_REF_FOR
	(VAULT_PERMISSION_CODE)(0),                      // 1: Scailo.VAULT_PERMISSION_CODE
	(ENCLAVE_DOMAIN_SORT_KEY)(0),                    // 2: Scailo.ENCLAVE_DOMAIN_SORT_KEY
	(VAULT_SORT_KEY)(0),                             // 3: Scailo.VAULT_SORT_KEY
	(VAULT_ACCESS_LOG_OPERATION)(0),                 // 4: Scailo.VAULT_ACCESS_LOG_OPERATION
	(*VaultPermission)(nil),                         // 5: Scailo.VaultPermission
	(*VaultPermissionAddRequest)(nil),               // 6: Scailo.VaultPermissionAddRequest
	(*VaultPermissionModifyRequest)(nil),            // 7: Scailo.VaultPermissionModifyRequest
	(*GixResources)(nil),                            // 8: Scailo.GixResources
	(*GiXManifest)(nil),                             // 9: Scailo.GiXManifest
	(*GiXAppRun)(nil),                               // 10: Scailo.GiXAppRun
	(*GiXAppRunsList)(nil),                          // 11: Scailo.GiXAppRunsList
	(*GiXAppRunCountReq)(nil),                       // 12: Scailo.GiXAppRunCountReq
	(*GiXAppRunFilterReq)(nil),                      // 13: Scailo.GiXAppRunFilterReq
	(*EnclaveResources)(nil),                        // 14: Scailo.EnclaveResources
	(*EnclaveManifestEnvVariable)(nil),              // 15: Scailo.EnclaveManifestEnvVariable
	(*EnclaveManifest)(nil),                         // 16: Scailo.EnclaveManifest
	(*EnclaveIngress)(nil),                          // 17: Scailo.EnclaveIngress
	(*EnclaveIngressesList)(nil),                    // 18: Scailo.EnclaveIngressesList
	(*EnclaveIngressCountReq)(nil),                  // 19: Scailo.EnclaveIngressCountReq
	(*EnclaveIngressFilterReq)(nil),                 // 20: Scailo.EnclaveIngressFilterReq
	(*VerifyEnclaveIngressRequest)(nil),             // 21: Scailo.VerifyEnclaveIngressRequest
	(*VerifyEnclaveIngressResponse)(nil),            // 22: Scailo.VerifyEnclaveIngressResponse
	(*EnclaveEnvironmentVariableAddRequest)(nil),    // 23: Scailo.EnclaveEnvironmentVariableAddRequest
	(*EnclaveEnvironmentVariableUpdateRequest)(nil), // 24: Scailo.EnclaveEnvironmentVariableUpdateRequest
	(*EnclaveEnvironmentVariable)(nil),              // 25: Scailo.EnclaveEnvironmentVariable
	(*EnclaveEnvironmentVariablesList)(nil),         // 26: Scailo.EnclaveEnvironmentVariablesList
	(*EnclaveDomainAddRequest)(nil),                 // 27: Scailo.EnclaveDomainAddRequest
	(*EnclaveDomain)(nil),                           // 28: Scailo.EnclaveDomain
	(*EnclaveDomainsFilterReq)(nil),                 // 29: Scailo.EnclaveDomainsFilterReq
	(*EnclaveDomainsList)(nil),                      // 30: Scailo.EnclaveDomainsList
	(*EnclaveDomainSuffixResp)(nil),                 // 31: Scailo.EnclaveDomainSuffixResp
	(*EnclaveFrameAddRequest)(nil),                  // 32: Scailo.EnclaveFrameAddRequest
	(*EnclaveFrameUpdateRequest)(nil),               // 33: Scailo.EnclaveFrameUpdateRequest
	(*EnclaveFrame)(nil),                            // 34: Scailo.EnclaveFrame
	(*EnclaveFrameSetup)(nil),                       // 35: Scailo.EnclaveFrameSetup
	(*EnclaveFrameSetupList)(nil),                   // 36: Scailo.EnclaveFrameSetupList
	(*VaultSearchReq)(nil),                          // 37: Scailo.VaultSearchReq
	(*VaultSearchResponse)(nil),                     // 38: Scailo.VaultSearchResponse
	(*VaultSearchResponsesList)(nil),                // 39: Scailo.VaultSearchResponsesList
	(*VaultDuplicateCheckReq)(nil),                  // 40: Scailo.VaultDuplicateCheckReq
	(*VaultAccessLog)(nil),                          // 41: Scailo.VaultAccessLog
	(*VaultAccessLogCreateRequest)(nil),             // 42: Scailo.VaultAccessLogCreateRequest
	(*VaultAccessLogsList)(nil),                     // 43: Scailo.VaultAccessLogsList
	(*EmployeeMetadata)(nil),                        // 44: Scailo.EmployeeMetadata
	(BOOL_FILTER)(0),                                // 45: Scailo.BOOL_FILTER
	(SORT_ORDER)(0),                                 // 46: Scailo.SORT_ORDER
}
var file_vault_commons_scailo_proto_depIdxs = []int32{
	44, // 0: Scailo.VaultPermission.metadata:type_name -> Scailo.EmployeeMetadata
	0,  // 1: Scailo.VaultPermission.ref_for:type_name -> Scailo.VAULT_REF_FOR
	8,  // 2: Scailo.GiXManifest.resources:type_name -> Scailo.GixResources
	44, // 3: Scailo.GiXAppRun.metadata:type_name -> Scailo.EmployeeMetadata
	9,  // 4: Scailo.GiXAppRun.manifest:type_name -> Scailo.GiXManifest
	10, // 5: Scailo.GiXAppRunsList.list:type_name -> Scailo.GiXAppRun
	45, // 6: Scailo.GiXAppRunCountReq.is_active:type_name -> Scailo.BOOL_FILTER
	45, // 7: Scailo.GiXAppRunFilterReq.is_active:type_name -> Scailo.BOOL_FILTER
	15, // 8: Scailo.EnclaveManifest.env_variables:type_name -> Scailo.EnclaveManifestEnvVariable
	14, // 9: Scailo.EnclaveManifest.resources:type_name -> Scailo.EnclaveResources
	44, // 10: Scailo.EnclaveIngress.metadata:type_name -> Scailo.EmployeeMetadata
	17, // 11: Scailo.EnclaveIngressesList.list:type_name -> Scailo.EnclaveIngress
	45, // 12: Scailo.EnclaveIngressCountReq.is_active:type_name -> Scailo.BOOL_FILTER
	45, // 13: Scailo.EnclaveIngressFilterReq.is_active:type_name -> Scailo.BOOL_FILTER
	44, // 14: Scailo.EnclaveEnvironmentVariable.metadata:type_name -> Scailo.EmployeeMetadata
	25, // 15: Scailo.EnclaveEnvironmentVariablesList.list:type_name -> Scailo.EnclaveEnvironmentVariable
	44, // 16: Scailo.EnclaveDomain.metadata:type_name -> Scailo.EmployeeMetadata
	45, // 17: Scailo.EnclaveDomainsFilterReq.is_active:type_name -> Scailo.BOOL_FILTER
	46, // 18: Scailo.EnclaveDomainsFilterReq.sort_order:type_name -> Scailo.SORT_ORDER
	2,  // 19: Scailo.EnclaveDomainsFilterReq.sort_key:type_name -> Scailo.ENCLAVE_DOMAIN_SORT_KEY
	28, // 20: Scailo.EnclaveDomainsList.list:type_name -> Scailo.EnclaveDomain
	44, // 21: Scailo.EnclaveFrame.metadata:type_name -> Scailo.EmployeeMetadata
	35, // 22: Scailo.EnclaveFrameSetupList.list:type_name -> Scailo.EnclaveFrameSetup
	45, // 23: Scailo.VaultSearchReq.is_active:type_name -> Scailo.BOOL_FILTER
	46, // 24: Scailo.VaultSearchReq.sort_order:type_name -> Scailo.SORT_ORDER
	3,  // 25: Scailo.VaultSearchReq.sort_key:type_name -> Scailo.VAULT_SORT_KEY
	0,  // 26: Scailo.VaultSearchReq.ref_for:type_name -> Scailo.VAULT_REF_FOR
	0,  // 27: Scailo.VaultSearchResponse.type:type_name -> Scailo.VAULT_REF_FOR
	38, // 28: Scailo.VaultSearchResponsesList.list:type_name -> Scailo.VaultSearchResponse
	44, // 29: Scailo.VaultAccessLog.metadata:type_name -> Scailo.EmployeeMetadata
	0,  // 30: Scailo.VaultAccessLog.ref_for:type_name -> Scailo.VAULT_REF_FOR
	4,  // 31: Scailo.VaultAccessLog.operation:type_name -> Scailo.VAULT_ACCESS_LOG_OPERATION
	0,  // 32: Scailo.VaultAccessLogCreateRequest.ref_for:type_name -> Scailo.VAULT_REF_FOR
	4,  // 33: Scailo.VaultAccessLogCreateRequest.operation:type_name -> Scailo.VAULT_ACCESS_LOG_OPERATION
	41, // 34: Scailo.VaultAccessLogsList.list:type_name -> Scailo.VaultAccessLog
	35, // [35:35] is the sub-list for method output_type
	35, // [35:35] is the sub-list for method input_type
	35, // [35:35] is the sub-list for extension type_name
	35, // [35:35] is the sub-list for extension extendee
	0,  // [0:35] is the sub-list for field type_name
}

func init() { file_vault_commons_scailo_proto_init() }
func file_vault_commons_scailo_proto_init() {
	if File_vault_commons_scailo_proto != nil {
		return
	}
	file_base_scailo_proto_init()
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_vault_commons_scailo_proto_rawDesc), len(file_vault_commons_scailo_proto_rawDesc)),
			NumEnums:      5,
			NumMessages:   39,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_vault_commons_scailo_proto_goTypes,
		DependencyIndexes: file_vault_commons_scailo_proto_depIdxs,
		EnumInfos:         file_vault_commons_scailo_proto_enumTypes,
		MessageInfos:      file_vault_commons_scailo_proto_msgTypes,
	}.Build()
	File_vault_commons_scailo_proto = out.File
	file_vault_commons_scailo_proto_goTypes = nil
	file_vault_commons_scailo_proto_depIdxs = nil
}
