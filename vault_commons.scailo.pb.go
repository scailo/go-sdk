// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.8
// 	protoc        (unknown)
// source: vault_commons.scailo.proto

package sdk

import (
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"

	_ "buf.build/gen/go/bufbuild/protovalidate/protocolbuffers/go/buf/validate"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Describes the available references for permissions
type VAULT_REF_FOR int32

const (
	// Ignore ref for (can only be used during search APIs)
	VAULT_REF_FOR_VAULT_REF_FOR_ANY_UNSPECIFIED VAULT_REF_FOR = 0
	// Permission refers to a file
	VAULT_REF_FOR_VAULT_REF_FOR_FILE VAULT_REF_FOR = 1
	// Permission refers to a folder
	VAULT_REF_FOR_VAULT_REF_FOR_FOLDER VAULT_REF_FOR = 2
)

// Enum value maps for VAULT_REF_FOR.
var (
	VAULT_REF_FOR_name = map[int32]string{
		0: "VAULT_REF_FOR_ANY_UNSPECIFIED",
		1: "VAULT_REF_FOR_FILE",
		2: "VAULT_REF_FOR_FOLDER",
	}
	VAULT_REF_FOR_value = map[string]int32{
		"VAULT_REF_FOR_ANY_UNSPECIFIED": 0,
		"VAULT_REF_FOR_FILE":            1,
		"VAULT_REF_FOR_FOLDER":          2,
	}
)

func (x VAULT_REF_FOR) Enum() *VAULT_REF_FOR {
	p := new(VAULT_REF_FOR)
	*p = x
	return p
}

func (x VAULT_REF_FOR) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (VAULT_REF_FOR) Descriptor() protoreflect.EnumDescriptor {
	return file_vault_commons_scailo_proto_enumTypes[0].Descriptor()
}

func (VAULT_REF_FOR) Type() protoreflect.EnumType {
	return &file_vault_commons_scailo_proto_enumTypes[0]
}

func (x VAULT_REF_FOR) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use VAULT_REF_FOR.Descriptor instead.
func (VAULT_REF_FOR) EnumDescriptor() ([]byte, []int) {
	return file_vault_commons_scailo_proto_rawDescGZIP(), []int{0}
}

// Describes the available permission codes
type VAULT_PERMISSION_CODE int32

const (
	// Stores the default value
	VAULT_PERMISSION_CODE_VAULT_PERMISSION_CODE_UNSPECIFIED VAULT_PERMISSION_CODE = 0
	// Stores the bit weight of the view permission (value is 2^0 = 1)
	VAULT_PERMISSION_CODE_VAULT_PERMISSION_CODE_VIEW VAULT_PERMISSION_CODE = 1
	// Stores the bit weight of the meta permission (value is 2^1 = 2)
	VAULT_PERMISSION_CODE_VAULT_PERMISSION_CODE_META VAULT_PERMISSION_CODE = 2
	// Stores the bit weight of the download permission (value is 2^2 = 4)
	VAULT_PERMISSION_CODE_VAULT_PERMISSION_CODE_DOWNLOAD VAULT_PERMISSION_CODE = 4
	// Stores the bit weight of the add permission (value is 2^3 = 8)
	VAULT_PERMISSION_CODE_VAULT_PERMISSION_CODE_ADD VAULT_PERMISSION_CODE = 8
	// Stores the bit weight of the delete permission (value is 2^4 = 16)
	VAULT_PERMISSION_CODE_VAULT_PERMISSION_CODE_DELETE VAULT_PERMISSION_CODE = 16
	// Stores the bit weight of the execute permission (value is 2^5 = 32)
	VAULT_PERMISSION_CODE_VAULT_PERMISSION_CODE_EXECUTE VAULT_PERMISSION_CODE = 32
	// Stores the bit weight of all the available permissions (value is 2^6 = 64 - 1)
	VAULT_PERMISSION_CODE_VAULT_PERMISSION_CODE_ALL VAULT_PERMISSION_CODE = 63
)

// Enum value maps for VAULT_PERMISSION_CODE.
var (
	VAULT_PERMISSION_CODE_name = map[int32]string{
		0:  "VAULT_PERMISSION_CODE_UNSPECIFIED",
		1:  "VAULT_PERMISSION_CODE_VIEW",
		2:  "VAULT_PERMISSION_CODE_META",
		4:  "VAULT_PERMISSION_CODE_DOWNLOAD",
		8:  "VAULT_PERMISSION_CODE_ADD",
		16: "VAULT_PERMISSION_CODE_DELETE",
		32: "VAULT_PERMISSION_CODE_EXECUTE",
		63: "VAULT_PERMISSION_CODE_ALL",
	}
	VAULT_PERMISSION_CODE_value = map[string]int32{
		"VAULT_PERMISSION_CODE_UNSPECIFIED": 0,
		"VAULT_PERMISSION_CODE_VIEW":        1,
		"VAULT_PERMISSION_CODE_META":        2,
		"VAULT_PERMISSION_CODE_DOWNLOAD":    4,
		"VAULT_PERMISSION_CODE_ADD":         8,
		"VAULT_PERMISSION_CODE_DELETE":      16,
		"VAULT_PERMISSION_CODE_EXECUTE":     32,
		"VAULT_PERMISSION_CODE_ALL":         63,
	}
)

func (x VAULT_PERMISSION_CODE) Enum() *VAULT_PERMISSION_CODE {
	p := new(VAULT_PERMISSION_CODE)
	*p = x
	return p
}

func (x VAULT_PERMISSION_CODE) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (VAULT_PERMISSION_CODE) Descriptor() protoreflect.EnumDescriptor {
	return file_vault_commons_scailo_proto_enumTypes[1].Descriptor()
}

func (VAULT_PERMISSION_CODE) Type() protoreflect.EnumType {
	return &file_vault_commons_scailo_proto_enumTypes[1]
}

func (x VAULT_PERMISSION_CODE) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use VAULT_PERMISSION_CODE.Descriptor instead.
func (VAULT_PERMISSION_CODE) EnumDescriptor() ([]byte, []int) {
	return file_vault_commons_scailo_proto_rawDescGZIP(), []int{1}
}

// Describes the available sort keys
type VAULT_SORT_KEY int32

const (
	// Fetch ordered results by id
	VAULT_SORT_KEY_VAULT_SORT_KEY_ID_UNSPECIFIED VAULT_SORT_KEY = 0
	// Fetch ordered results by the creation timestamp
	VAULT_SORT_KEY_VAULT_SORT_KEY_CREATED_AT VAULT_SORT_KEY = 1
	// Fetch ordered results by the modified timestamp
	VAULT_SORT_KEY_VAULT_SORT_KEY_MODIFIED_AT VAULT_SORT_KEY = 2
	// Fetch ordered results by the name
	VAULT_SORT_KEY_VAULT_SORT_KEY_NAME VAULT_SORT_KEY = 10
)

// Enum value maps for VAULT_SORT_KEY.
var (
	VAULT_SORT_KEY_name = map[int32]string{
		0:  "VAULT_SORT_KEY_ID_UNSPECIFIED",
		1:  "VAULT_SORT_KEY_CREATED_AT",
		2:  "VAULT_SORT_KEY_MODIFIED_AT",
		10: "VAULT_SORT_KEY_NAME",
	}
	VAULT_SORT_KEY_value = map[string]int32{
		"VAULT_SORT_KEY_ID_UNSPECIFIED": 0,
		"VAULT_SORT_KEY_CREATED_AT":     1,
		"VAULT_SORT_KEY_MODIFIED_AT":    2,
		"VAULT_SORT_KEY_NAME":           10,
	}
)

func (x VAULT_SORT_KEY) Enum() *VAULT_SORT_KEY {
	p := new(VAULT_SORT_KEY)
	*p = x
	return p
}

func (x VAULT_SORT_KEY) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (VAULT_SORT_KEY) Descriptor() protoreflect.EnumDescriptor {
	return file_vault_commons_scailo_proto_enumTypes[2].Descriptor()
}

func (VAULT_SORT_KEY) Type() protoreflect.EnumType {
	return &file_vault_commons_scailo_proto_enumTypes[2]
}

func (x VAULT_SORT_KEY) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use VAULT_SORT_KEY.Descriptor instead.
func (VAULT_SORT_KEY) EnumDescriptor() ([]byte, []int) {
	return file_vault_commons_scailo_proto_rawDescGZIP(), []int{2}
}

// Describes the available access log operations
type VAULT_ACCESS_LOG_OPERATION int32

const (
	// Ignore operation (useful only for search APIs)
	VAULT_ACCESS_LOG_OPERATION_VAULT_ACCESS_LOG_OPERATION_ANY_UNSPECIFIED VAULT_ACCESS_LOG_OPERATION = 0
	// Denotes that the user has created the resource
	VAULT_ACCESS_LOG_OPERATION_VAULT_ACCESS_LOG_OPERATION_CREATE VAULT_ACCESS_LOG_OPERATION = 1
	// Denotes that the user has moved the resource
	VAULT_ACCESS_LOG_OPERATION_VAULT_ACCESS_LOG_OPERATION_MOVE VAULT_ACCESS_LOG_OPERATION = 2
	// Denotes that the user has renamed the resource
	VAULT_ACCESS_LOG_OPERATION_VAULT_ACCESS_LOG_OPERATION_RENAME VAULT_ACCESS_LOG_OPERATION = 3
	// Denotes that the user has deleted the resource
	VAULT_ACCESS_LOG_OPERATION_VAULT_ACCESS_LOG_OPERATION_DELETE VAULT_ACCESS_LOG_OPERATION = 4
	// Denotes that the user has downloaded the resource
	VAULT_ACCESS_LOG_OPERATION_VAULT_ACCESS_LOG_OPERATION_DOWNLOAD VAULT_ACCESS_LOG_OPERATION = 5
	// Denotes that the user has uploaded the resource
	VAULT_ACCESS_LOG_OPERATION_VAULT_ACCESS_LOG_OPERATION_UPLOAD VAULT_ACCESS_LOG_OPERATION = 6
	// Denotes that the user has begun unzipping the resource
	VAULT_ACCESS_LOG_OPERATION_VAULT_ACCESS_LOG_OPERATION_UNZIP VAULT_ACCESS_LOG_OPERATION = 7
	// Denotes that the user has marked the resource as persistent
	VAULT_ACCESS_LOG_OPERATION_VAULT_ACCESS_LOG_OPERATION_PERSISTENT VAULT_ACCESS_LOG_OPERATION = 8
	// Denotes that the user is updating the permissions to a resource
	VAULT_ACCESS_LOG_OPERATION_VAULT_ACCESS_LOG_OPERATION_PERMISSIONS VAULT_ACCESS_LOG_OPERATION = 9
	// Denotes that the user is executing the resource (most likely a GiX app)
	VAULT_ACCESS_LOG_OPERATION_VAULT_ACCESS_LOG_OPERATION_EXECUTE VAULT_ACCESS_LOG_OPERATION = 10
)

// Enum value maps for VAULT_ACCESS_LOG_OPERATION.
var (
	VAULT_ACCESS_LOG_OPERATION_name = map[int32]string{
		0:  "VAULT_ACCESS_LOG_OPERATION_ANY_UNSPECIFIED",
		1:  "VAULT_ACCESS_LOG_OPERATION_CREATE",
		2:  "VAULT_ACCESS_LOG_OPERATION_MOVE",
		3:  "VAULT_ACCESS_LOG_OPERATION_RENAME",
		4:  "VAULT_ACCESS_LOG_OPERATION_DELETE",
		5:  "VAULT_ACCESS_LOG_OPERATION_DOWNLOAD",
		6:  "VAULT_ACCESS_LOG_OPERATION_UPLOAD",
		7:  "VAULT_ACCESS_LOG_OPERATION_UNZIP",
		8:  "VAULT_ACCESS_LOG_OPERATION_PERSISTENT",
		9:  "VAULT_ACCESS_LOG_OPERATION_PERMISSIONS",
		10: "VAULT_ACCESS_LOG_OPERATION_EXECUTE",
	}
	VAULT_ACCESS_LOG_OPERATION_value = map[string]int32{
		"VAULT_ACCESS_LOG_OPERATION_ANY_UNSPECIFIED": 0,
		"VAULT_ACCESS_LOG_OPERATION_CREATE":          1,
		"VAULT_ACCESS_LOG_OPERATION_MOVE":            2,
		"VAULT_ACCESS_LOG_OPERATION_RENAME":          3,
		"VAULT_ACCESS_LOG_OPERATION_DELETE":          4,
		"VAULT_ACCESS_LOG_OPERATION_DOWNLOAD":        5,
		"VAULT_ACCESS_LOG_OPERATION_UPLOAD":          6,
		"VAULT_ACCESS_LOG_OPERATION_UNZIP":           7,
		"VAULT_ACCESS_LOG_OPERATION_PERSISTENT":      8,
		"VAULT_ACCESS_LOG_OPERATION_PERMISSIONS":     9,
		"VAULT_ACCESS_LOG_OPERATION_EXECUTE":         10,
	}
)

func (x VAULT_ACCESS_LOG_OPERATION) Enum() *VAULT_ACCESS_LOG_OPERATION {
	p := new(VAULT_ACCESS_LOG_OPERATION)
	*p = x
	return p
}

func (x VAULT_ACCESS_LOG_OPERATION) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (VAULT_ACCESS_LOG_OPERATION) Descriptor() protoreflect.EnumDescriptor {
	return file_vault_commons_scailo_proto_enumTypes[3].Descriptor()
}

func (VAULT_ACCESS_LOG_OPERATION) Type() protoreflect.EnumType {
	return &file_vault_commons_scailo_proto_enumTypes[3]
}

func (x VAULT_ACCESS_LOG_OPERATION) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use VAULT_ACCESS_LOG_OPERATION.Descriptor instead.
func (VAULT_ACCESS_LOG_OPERATION) EnumDescriptor() ([]byte, []int) {
	return file_vault_commons_scailo_proto_rawDescGZIP(), []int{3}
}

// Describes the parameters of a permission related to a vault file or folder
type VaultPermission struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Stores a globally unique entity UUID. This will be set at the organization level
	EntityUuid string `protobuf:"bytes,1,opt,name=entity_uuid,json=entityUuid,proto3" json:"entity_uuid,omitempty"`
	// Stores the metadata of this user
	Metadata *EmployeeMetadata `protobuf:"bytes,2,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// Stores the reference for which this permission is applicable
	RefFor VAULT_REF_FOR `protobuf:"varint,10,opt,name=ref_for,json=refFor,proto3,enum=Scailo.VAULT_REF_FOR" json:"ref_for,omitempty"`
	// Stores the ID of the underlying file or folder that this permission if applicable for
	RefId uint64 `protobuf:"varint,11,opt,name=ref_id,json=refId,proto3" json:"ref_id,omitempty"`
	// Stores the ID of the role
	RoleId uint64 `protobuf:"varint,12,opt,name=role_id,json=roleId,proto3" json:"role_id,omitempty"`
	// Stores the applicable permissions
	PermissionCode uint64 `protobuf:"varint,13,opt,name=permission_code,json=permissionCode,proto3" json:"permission_code,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *VaultPermission) Reset() {
	*x = VaultPermission{}
	mi := &file_vault_commons_scailo_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VaultPermission) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VaultPermission) ProtoMessage() {}

func (x *VaultPermission) ProtoReflect() protoreflect.Message {
	mi := &file_vault_commons_scailo_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VaultPermission.ProtoReflect.Descriptor instead.
func (*VaultPermission) Descriptor() ([]byte, []int) {
	return file_vault_commons_scailo_proto_rawDescGZIP(), []int{0}
}

func (x *VaultPermission) GetEntityUuid() string {
	if x != nil {
		return x.EntityUuid
	}
	return ""
}

func (x *VaultPermission) GetMetadata() *EmployeeMetadata {
	if x != nil {
		return x.Metadata
	}
	return nil
}

func (x *VaultPermission) GetRefFor() VAULT_REF_FOR {
	if x != nil {
		return x.RefFor
	}
	return VAULT_REF_FOR_VAULT_REF_FOR_ANY_UNSPECIFIED
}

func (x *VaultPermission) GetRefId() uint64 {
	if x != nil {
		return x.RefId
	}
	return 0
}

func (x *VaultPermission) GetRoleId() uint64 {
	if x != nil {
		return x.RoleId
	}
	return 0
}

func (x *VaultPermission) GetPermissionCode() uint64 {
	if x != nil {
		return x.PermissionCode
	}
	return 0
}

// Describes the parameters required to create a vault permission
type VaultPermissionAddRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Stores a globally unique entity UUID. This will be set at the organization level
	EntityUuid string `protobuf:"bytes,1,opt,name=entity_uuid,json=entityUuid,proto3" json:"entity_uuid,omitempty"`
	// Stores any comment that the user might add during this operation
	UserComment string `protobuf:"bytes,2,opt,name=user_comment,json=userComment,proto3" json:"user_comment,omitempty"`
	// Stores the UUID of the underlying file or folder that this permission if applicable for
	RefUuid string `protobuf:"bytes,11,opt,name=ref_uuid,json=refUuid,proto3" json:"ref_uuid,omitempty"`
	// Stores the ID of the role
	RoleId uint64 `protobuf:"varint,12,opt,name=role_id,json=roleId,proto3" json:"role_id,omitempty"`
	// Stores the applicable permissions
	PermissionCode uint64 `protobuf:"varint,13,opt,name=permission_code,json=permissionCode,proto3" json:"permission_code,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *VaultPermissionAddRequest) Reset() {
	*x = VaultPermissionAddRequest{}
	mi := &file_vault_commons_scailo_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VaultPermissionAddRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VaultPermissionAddRequest) ProtoMessage() {}

func (x *VaultPermissionAddRequest) ProtoReflect() protoreflect.Message {
	mi := &file_vault_commons_scailo_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VaultPermissionAddRequest.ProtoReflect.Descriptor instead.
func (*VaultPermissionAddRequest) Descriptor() ([]byte, []int) {
	return file_vault_commons_scailo_proto_rawDescGZIP(), []int{1}
}

func (x *VaultPermissionAddRequest) GetEntityUuid() string {
	if x != nil {
		return x.EntityUuid
	}
	return ""
}

func (x *VaultPermissionAddRequest) GetUserComment() string {
	if x != nil {
		return x.UserComment
	}
	return ""
}

func (x *VaultPermissionAddRequest) GetRefUuid() string {
	if x != nil {
		return x.RefUuid
	}
	return ""
}

func (x *VaultPermissionAddRequest) GetRoleId() uint64 {
	if x != nil {
		return x.RoleId
	}
	return 0
}

func (x *VaultPermissionAddRequest) GetPermissionCode() uint64 {
	if x != nil {
		return x.PermissionCode
	}
	return 0
}

// Describes the parameters required to modify a vault permission
type VaultPermissionModifyRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The UUID of the permission
	Uuid string `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	// Stores any comment that the user might add during this operation
	UserComment string `protobuf:"bytes,2,opt,name=user_comment,json=userComment,proto3" json:"user_comment,omitempty"`
	// Stores the applicable permissions
	PermissionCode uint64 `protobuf:"varint,13,opt,name=permission_code,json=permissionCode,proto3" json:"permission_code,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *VaultPermissionModifyRequest) Reset() {
	*x = VaultPermissionModifyRequest{}
	mi := &file_vault_commons_scailo_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VaultPermissionModifyRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VaultPermissionModifyRequest) ProtoMessage() {}

func (x *VaultPermissionModifyRequest) ProtoReflect() protoreflect.Message {
	mi := &file_vault_commons_scailo_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VaultPermissionModifyRequest.ProtoReflect.Descriptor instead.
func (*VaultPermissionModifyRequest) Descriptor() ([]byte, []int) {
	return file_vault_commons_scailo_proto_rawDescGZIP(), []int{2}
}

func (x *VaultPermissionModifyRequest) GetUuid() string {
	if x != nil {
		return x.Uuid
	}
	return ""
}

func (x *VaultPermissionModifyRequest) GetUserComment() string {
	if x != nil {
		return x.UserComment
	}
	return ""
}

func (x *VaultPermissionModifyRequest) GetPermissionCode() uint64 {
	if x != nil {
		return x.PermissionCode
	}
	return 0
}

// Describes the resources section of a GiX app
type GixResources struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Stores the entry point of the GiX app
	HtmlEntry string `protobuf:"bytes,1,opt,name=html_entry,proto3" json:"html_entry,omitempty"`
	// Stores the list of logos that are available
	Logos []string `protobuf:"bytes,2,rep,name=logos,proto3" json:"logos,omitempty"`
	// Stores the list of external APIs that need to be accessible by the GiX app
	ExternalApis  []string `protobuf:"bytes,3,rep,name=external_apis,proto3" json:"external_apis,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GixResources) Reset() {
	*x = GixResources{}
	mi := &file_vault_commons_scailo_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GixResources) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GixResources) ProtoMessage() {}

func (x *GixResources) ProtoReflect() protoreflect.Message {
	mi := &file_vault_commons_scailo_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GixResources.ProtoReflect.Descriptor instead.
func (*GixResources) Descriptor() ([]byte, []int) {
	return file_vault_commons_scailo_proto_rawDescGZIP(), []int{3}
}

func (x *GixResources) GetHtmlEntry() string {
	if x != nil {
		return x.HtmlEntry
	}
	return ""
}

func (x *GixResources) GetLogos() []string {
	if x != nil {
		return x.Logos
	}
	return nil
}

func (x *GixResources) GetExternalApis() []string {
	if x != nil {
		return x.ExternalApis
	}
	return nil
}

// Describes the manifest file of a GiX app. Stores the attributes that can be a part of the MANIFEST.yaml file, that is present in the root folder of a GiX app
type GiXManifest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Stores the manifest version
	ManifestVersion string `protobuf:"bytes,1,opt,name=manifest_version,proto3" json:"manifest_version,omitempty"`
	// Stores the application version
	AppVersion string `protobuf:"bytes,2,opt,name=app_version,proto3" json:"app_version,omitempty"`
	// Stores the name of the application
	AppName string `protobuf:"bytes,3,opt,name=app_name,proto3" json:"app_name,omitempty"`
	// Stores the unique identifier for the application
	AppUniqueIdentifier string `protobuf:"bytes,4,opt,name=app_unique_identifier,proto3" json:"app_unique_identifier,omitempty"`
	// Stores the minimum version of Scailo that the application supports
	MinGenesisVersion string `protobuf:"bytes,5,opt,name=min_genesis_version,proto3" json:"min_genesis_version,omitempty"`
	// Stores the manimum version of Scailo that the application supports
	MaxGenesisVersion string `protobuf:"bytes,6,opt,name=max_genesis_version,proto3" json:"max_genesis_version,omitempty"`
	// Stores the resources of the GiX application
	Resources     *GixResources `protobuf:"bytes,7,opt,name=resources,proto3" json:"resources,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GiXManifest) Reset() {
	*x = GiXManifest{}
	mi := &file_vault_commons_scailo_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GiXManifest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GiXManifest) ProtoMessage() {}

func (x *GiXManifest) ProtoReflect() protoreflect.Message {
	mi := &file_vault_commons_scailo_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GiXManifest.ProtoReflect.Descriptor instead.
func (*GiXManifest) Descriptor() ([]byte, []int) {
	return file_vault_commons_scailo_proto_rawDescGZIP(), []int{4}
}

func (x *GiXManifest) GetManifestVersion() string {
	if x != nil {
		return x.ManifestVersion
	}
	return ""
}

func (x *GiXManifest) GetAppVersion() string {
	if x != nil {
		return x.AppVersion
	}
	return ""
}

func (x *GiXManifest) GetAppName() string {
	if x != nil {
		return x.AppName
	}
	return ""
}

func (x *GiXManifest) GetAppUniqueIdentifier() string {
	if x != nil {
		return x.AppUniqueIdentifier
	}
	return ""
}

func (x *GiXManifest) GetMinGenesisVersion() string {
	if x != nil {
		return x.MinGenesisVersion
	}
	return ""
}

func (x *GiXManifest) GetMaxGenesisVersion() string {
	if x != nil {
		return x.MaxGenesisVersion
	}
	return ""
}

func (x *GiXManifest) GetResources() *GixResources {
	if x != nil {
		return x.Resources
	}
	return nil
}

// Describes the parameters that are a part of each vault app execution (GiX app execution)
type GiXAppRun struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Stores a globally unique entity UUID. This will be set at the organization level
	EntityUuid string `protobuf:"bytes,1,opt,name=entity_uuid,json=entityUuid,proto3" json:"entity_uuid,omitempty"`
	// Stores the metadata of this user
	Metadata *EmployeeMetadata `protobuf:"bytes,2,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// Stores the ID of the file that is being executed
	VaultFileId uint64 `protobuf:"varint,10,opt,name=vault_file_id,json=vaultFileId,proto3" json:"vault_file_id,omitempty"`
	// Stores the ID of the version of the file that is being executed
	VaultFileVersionId uint64 `protobuf:"varint,11,opt,name=vault_file_version_id,json=vaultFileVersionId,proto3" json:"vault_file_version_id,omitempty"`
	// Stores the unique identifier of the application
	AppUniqueIdentifier string `protobuf:"bytes,12,opt,name=app_unique_identifier,json=appUniqueIdentifier,proto3" json:"app_unique_identifier,omitempty"`
	// Stores the path of the extracted file on disk, from where static files will be served
	ExtractedPath string `protobuf:"bytes,13,opt,name=extracted_path,json=extractedPath,proto3" json:"extracted_path,omitempty"`
	// Stores the IP address from where the app was executed
	IpAddr string `protobuf:"bytes,14,opt,name=ip_addr,json=ipAddr,proto3" json:"ip_addr,omitempty"`
	// Stores the manifest of the GiX app
	Manifest *GiXManifest `protobuf:"bytes,15,opt,name=manifest,proto3" json:"manifest,omitempty"`
	// Stores the username of the user who is running the app
	RunBy string `protobuf:"bytes,16,opt,name=run_by,json=runBy,proto3" json:"run_by,omitempty"`
	// Stores the application version
	AppVersion string `protobuf:"bytes,30,opt,name=app_version,json=appVersion,proto3" json:"app_version,omitempty"`
	// Stores the name of the application
	AppName string `protobuf:"bytes,31,opt,name=app_name,json=appName,proto3" json:"app_name,omitempty"`
	// Stores the endpoint of the application execution
	AppEndpoint   string `protobuf:"bytes,40,opt,name=app_endpoint,json=appEndpoint,proto3" json:"app_endpoint,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GiXAppRun) Reset() {
	*x = GiXAppRun{}
	mi := &file_vault_commons_scailo_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GiXAppRun) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GiXAppRun) ProtoMessage() {}

func (x *GiXAppRun) ProtoReflect() protoreflect.Message {
	mi := &file_vault_commons_scailo_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GiXAppRun.ProtoReflect.Descriptor instead.
func (*GiXAppRun) Descriptor() ([]byte, []int) {
	return file_vault_commons_scailo_proto_rawDescGZIP(), []int{5}
}

func (x *GiXAppRun) GetEntityUuid() string {
	if x != nil {
		return x.EntityUuid
	}
	return ""
}

func (x *GiXAppRun) GetMetadata() *EmployeeMetadata {
	if x != nil {
		return x.Metadata
	}
	return nil
}

func (x *GiXAppRun) GetVaultFileId() uint64 {
	if x != nil {
		return x.VaultFileId
	}
	return 0
}

func (x *GiXAppRun) GetVaultFileVersionId() uint64 {
	if x != nil {
		return x.VaultFileVersionId
	}
	return 0
}

func (x *GiXAppRun) GetAppUniqueIdentifier() string {
	if x != nil {
		return x.AppUniqueIdentifier
	}
	return ""
}

func (x *GiXAppRun) GetExtractedPath() string {
	if x != nil {
		return x.ExtractedPath
	}
	return ""
}

func (x *GiXAppRun) GetIpAddr() string {
	if x != nil {
		return x.IpAddr
	}
	return ""
}

func (x *GiXAppRun) GetManifest() *GiXManifest {
	if x != nil {
		return x.Manifest
	}
	return nil
}

func (x *GiXAppRun) GetRunBy() string {
	if x != nil {
		return x.RunBy
	}
	return ""
}

func (x *GiXAppRun) GetAppVersion() string {
	if x != nil {
		return x.AppVersion
	}
	return ""
}

func (x *GiXAppRun) GetAppName() string {
	if x != nil {
		return x.AppName
	}
	return ""
}

func (x *GiXAppRun) GetAppEndpoint() string {
	if x != nil {
		return x.AppEndpoint
	}
	return ""
}

// Describes the message consisting of the list of gix app runs
type GiXAppRunsList struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// List of runs
	List          []*GiXAppRun `protobuf:"bytes,1,rep,name=list,proto3" json:"list,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GiXAppRunsList) Reset() {
	*x = GiXAppRunsList{}
	mi := &file_vault_commons_scailo_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GiXAppRunsList) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GiXAppRunsList) ProtoMessage() {}

func (x *GiXAppRunsList) ProtoReflect() protoreflect.Message {
	mi := &file_vault_commons_scailo_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GiXAppRunsList.ProtoReflect.Descriptor instead.
func (*GiXAppRunsList) Descriptor() ([]byte, []int) {
	return file_vault_commons_scailo_proto_rawDescGZIP(), []int{6}
}

func (x *GiXAppRunsList) GetList() []*GiXAppRun {
	if x != nil {
		return x.List
	}
	return nil
}

// Describes the request payload of a count filter for app runs
type GiXAppRunCountReq struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// If true, then returns only active records. If false, then returns only inactive records
	IsActive BOOL_FILTER `protobuf:"varint,1,opt,name=is_active,json=isActive,proto3,enum=Scailo.BOOL_FILTER" json:"is_active,omitempty"`
	// The minimum timestamp that needs to be considered to filter by creation
	CreationTimestampStart uint64 `protobuf:"varint,101,opt,name=creation_timestamp_start,json=creationTimestampStart,proto3" json:"creation_timestamp_start,omitempty"`
	// The maximum timestamp that needs to be considered to filter by creation
	CreationTimestampEnd uint64 `protobuf:"varint,102,opt,name=creation_timestamp_end,json=creationTimestampEnd,proto3" json:"creation_timestamp_end,omitempty"`
	// The minimum timestamp that needs to be considered to filter by modification
	ModificationTimestampStart uint64 `protobuf:"varint,103,opt,name=modification_timestamp_start,json=modificationTimestampStart,proto3" json:"modification_timestamp_start,omitempty"`
	// The maximum timestamp that needs to be considered to filter by modification
	ModificationTimestampEnd uint64 `protobuf:"varint,104,opt,name=modification_timestamp_end,json=modificationTimestampEnd,proto3" json:"modification_timestamp_end,omitempty"`
	// The UUID of the file
	VaultFileUuid string `protobuf:"bytes,20,opt,name=vault_file_uuid,json=vaultFileUuid,proto3" json:"vault_file_uuid,omitempty"`
	// The UUID of the version
	VaultFileVersionUuid string `protobuf:"bytes,21,opt,name=vault_file_version_uuid,json=vaultFileVersionUuid,proto3" json:"vault_file_version_uuid,omitempty"` // --------------------------------------------------------
	// The username of the user who executed the app
	RunBy         string `protobuf:"bytes,30,opt,name=run_by,json=runBy,proto3" json:"run_by,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GiXAppRunCountReq) Reset() {
	*x = GiXAppRunCountReq{}
	mi := &file_vault_commons_scailo_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GiXAppRunCountReq) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GiXAppRunCountReq) ProtoMessage() {}

func (x *GiXAppRunCountReq) ProtoReflect() protoreflect.Message {
	mi := &file_vault_commons_scailo_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GiXAppRunCountReq.ProtoReflect.Descriptor instead.
func (*GiXAppRunCountReq) Descriptor() ([]byte, []int) {
	return file_vault_commons_scailo_proto_rawDescGZIP(), []int{7}
}

func (x *GiXAppRunCountReq) GetIsActive() BOOL_FILTER {
	if x != nil {
		return x.IsActive
	}
	return BOOL_FILTER_BOOL_FILTER_ANY_UNSPECIFIED
}

func (x *GiXAppRunCountReq) GetCreationTimestampStart() uint64 {
	if x != nil {
		return x.CreationTimestampStart
	}
	return 0
}

func (x *GiXAppRunCountReq) GetCreationTimestampEnd() uint64 {
	if x != nil {
		return x.CreationTimestampEnd
	}
	return 0
}

func (x *GiXAppRunCountReq) GetModificationTimestampStart() uint64 {
	if x != nil {
		return x.ModificationTimestampStart
	}
	return 0
}

func (x *GiXAppRunCountReq) GetModificationTimestampEnd() uint64 {
	if x != nil {
		return x.ModificationTimestampEnd
	}
	return 0
}

func (x *GiXAppRunCountReq) GetVaultFileUuid() string {
	if x != nil {
		return x.VaultFileUuid
	}
	return ""
}

func (x *GiXAppRunCountReq) GetVaultFileVersionUuid() string {
	if x != nil {
		return x.VaultFileVersionUuid
	}
	return ""
}

func (x *GiXAppRunCountReq) GetRunBy() string {
	if x != nil {
		return x.RunBy
	}
	return ""
}

// Describes the base request payload of a filter search for gix app runs
type GiXAppRunFilterReq struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// If true, then returns only active records. If false, then returns only inactive records
	IsActive BOOL_FILTER `protobuf:"varint,1,opt,name=is_active,json=isActive,proto3,enum=Scailo.BOOL_FILTER" json:"is_active,omitempty"`
	// The number of records that need to be sent in the response. Returns all records if it is set to -1
	Count int64 `protobuf:"varint,2,opt,name=count,proto3" json:"count,omitempty"`
	// The number that need to be offset by before fetching the records
	Offset uint64 `protobuf:"varint,3,opt,name=offset,proto3" json:"offset,omitempty"`
	// The minimum timestamp that needs to be considered to filter by creation
	CreationTimestampStart uint64 `protobuf:"varint,101,opt,name=creation_timestamp_start,json=creationTimestampStart,proto3" json:"creation_timestamp_start,omitempty"`
	// The maximum timestamp that needs to be considered to filter by creation
	CreationTimestampEnd uint64 `protobuf:"varint,102,opt,name=creation_timestamp_end,json=creationTimestampEnd,proto3" json:"creation_timestamp_end,omitempty"`
	// The minimum timestamp that needs to be considered to filter by modification
	ModificationTimestampStart uint64 `protobuf:"varint,103,opt,name=modification_timestamp_start,json=modificationTimestampStart,proto3" json:"modification_timestamp_start,omitempty"`
	// The maximum timestamp that needs to be considered to filter by modification
	ModificationTimestampEnd uint64 `protobuf:"varint,104,opt,name=modification_timestamp_end,json=modificationTimestampEnd,proto3" json:"modification_timestamp_end,omitempty"`
	// The UUID of the file
	VaultFileUuid string `protobuf:"bytes,20,opt,name=vault_file_uuid,json=vaultFileUuid,proto3" json:"vault_file_uuid,omitempty"`
	// The UUID of the version
	VaultFileVersionUuid string `protobuf:"bytes,21,opt,name=vault_file_version_uuid,json=vaultFileVersionUuid,proto3" json:"vault_file_version_uuid,omitempty"` // --------------------------------------------------------
	// The username of the user who executed the app
	RunBy         string `protobuf:"bytes,30,opt,name=run_by,json=runBy,proto3" json:"run_by,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GiXAppRunFilterReq) Reset() {
	*x = GiXAppRunFilterReq{}
	mi := &file_vault_commons_scailo_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GiXAppRunFilterReq) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GiXAppRunFilterReq) ProtoMessage() {}

func (x *GiXAppRunFilterReq) ProtoReflect() protoreflect.Message {
	mi := &file_vault_commons_scailo_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GiXAppRunFilterReq.ProtoReflect.Descriptor instead.
func (*GiXAppRunFilterReq) Descriptor() ([]byte, []int) {
	return file_vault_commons_scailo_proto_rawDescGZIP(), []int{8}
}

func (x *GiXAppRunFilterReq) GetIsActive() BOOL_FILTER {
	if x != nil {
		return x.IsActive
	}
	return BOOL_FILTER_BOOL_FILTER_ANY_UNSPECIFIED
}

func (x *GiXAppRunFilterReq) GetCount() int64 {
	if x != nil {
		return x.Count
	}
	return 0
}

func (x *GiXAppRunFilterReq) GetOffset() uint64 {
	if x != nil {
		return x.Offset
	}
	return 0
}

func (x *GiXAppRunFilterReq) GetCreationTimestampStart() uint64 {
	if x != nil {
		return x.CreationTimestampStart
	}
	return 0
}

func (x *GiXAppRunFilterReq) GetCreationTimestampEnd() uint64 {
	if x != nil {
		return x.CreationTimestampEnd
	}
	return 0
}

func (x *GiXAppRunFilterReq) GetModificationTimestampStart() uint64 {
	if x != nil {
		return x.ModificationTimestampStart
	}
	return 0
}

func (x *GiXAppRunFilterReq) GetModificationTimestampEnd() uint64 {
	if x != nil {
		return x.ModificationTimestampEnd
	}
	return 0
}

func (x *GiXAppRunFilterReq) GetVaultFileUuid() string {
	if x != nil {
		return x.VaultFileUuid
	}
	return ""
}

func (x *GiXAppRunFilterReq) GetVaultFileVersionUuid() string {
	if x != nil {
		return x.VaultFileVersionUuid
	}
	return ""
}

func (x *GiXAppRunFilterReq) GetRunBy() string {
	if x != nil {
		return x.RunBy
	}
	return ""
}

type VaultSearchReq struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// If true, then returns only active records. If false, then returns only inactive records
	IsActive BOOL_FILTER `protobuf:"varint,1,opt,name=is_active,json=isActive,proto3,enum=Scailo.BOOL_FILTER" json:"is_active,omitempty"`
	// The number of records that need to be sent in the response. Returns all records if it is set to -1
	Count int64 `protobuf:"varint,2,opt,name=count,proto3" json:"count,omitempty"`
	// The number that need to be offset by before fetching the records
	Offset uint64 `protobuf:"varint,3,opt,name=offset,proto3" json:"offset,omitempty"`
	// The sort order that is to be used to fetch the pagination response
	SortOrder SORT_ORDER `protobuf:"varint,4,opt,name=sort_order,json=sortOrder,proto3,enum=Scailo.SORT_ORDER" json:"sort_order,omitempty"`
	// The sort key that is to be used to fetch the pagination response
	SortKey VAULT_SORT_KEY `protobuf:"varint,5,opt,name=sort_key,json=sortKey,proto3,enum=Scailo.VAULT_SORT_KEY" json:"sort_key,omitempty"`
	// The minimum timestamp that needs to be considered to filter by creation
	CreationTimestampStart uint64 `protobuf:"varint,101,opt,name=creation_timestamp_start,json=creationTimestampStart,proto3" json:"creation_timestamp_start,omitempty"`
	// The maximum timestamp that needs to be considered to filter by creation
	CreationTimestampEnd uint64 `protobuf:"varint,102,opt,name=creation_timestamp_end,json=creationTimestampEnd,proto3" json:"creation_timestamp_end,omitempty"`
	// The minimum timestamp that needs to be considered to filter by modification
	ModificationTimestampStart uint64 `protobuf:"varint,103,opt,name=modification_timestamp_start,json=modificationTimestampStart,proto3" json:"modification_timestamp_start,omitempty"`
	// The maximum timestamp that needs to be considered to filter by modification
	ModificationTimestampEnd uint64 `protobuf:"varint,104,opt,name=modification_timestamp_end,json=modificationTimestampEnd,proto3" json:"modification_timestamp_end,omitempty"`
	// The entity UUID that is to be used to filter records
	EntityUuid string `protobuf:"bytes,8,opt,name=entity_uuid,json=entityUuid,proto3" json:"entity_uuid,omitempty"`
	// Limit the search to the given ref_for
	RefFor VAULT_REF_FOR `protobuf:"varint,9,opt,name=ref_for,json=refFor,proto3,enum=Scailo.VAULT_REF_FOR" json:"ref_for,omitempty"`
	// Limit the search to an optional folder
	FolderUuid string `protobuf:"bytes,10,opt,name=folder_uuid,json=folderUuid,proto3" json:"folder_uuid,omitempty"`
	// Describes the key with which the search operation needs to be performed
	SearchKey     string `protobuf:"bytes,11,opt,name=search_key,json=searchKey,proto3" json:"search_key,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *VaultSearchReq) Reset() {
	*x = VaultSearchReq{}
	mi := &file_vault_commons_scailo_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VaultSearchReq) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VaultSearchReq) ProtoMessage() {}

func (x *VaultSearchReq) ProtoReflect() protoreflect.Message {
	mi := &file_vault_commons_scailo_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VaultSearchReq.ProtoReflect.Descriptor instead.
func (*VaultSearchReq) Descriptor() ([]byte, []int) {
	return file_vault_commons_scailo_proto_rawDescGZIP(), []int{9}
}

func (x *VaultSearchReq) GetIsActive() BOOL_FILTER {
	if x != nil {
		return x.IsActive
	}
	return BOOL_FILTER_BOOL_FILTER_ANY_UNSPECIFIED
}

func (x *VaultSearchReq) GetCount() int64 {
	if x != nil {
		return x.Count
	}
	return 0
}

func (x *VaultSearchReq) GetOffset() uint64 {
	if x != nil {
		return x.Offset
	}
	return 0
}

func (x *VaultSearchReq) GetSortOrder() SORT_ORDER {
	if x != nil {
		return x.SortOrder
	}
	return SORT_ORDER_ASCENDING_UNSPECIFIED
}

func (x *VaultSearchReq) GetSortKey() VAULT_SORT_KEY {
	if x != nil {
		return x.SortKey
	}
	return VAULT_SORT_KEY_VAULT_SORT_KEY_ID_UNSPECIFIED
}

func (x *VaultSearchReq) GetCreationTimestampStart() uint64 {
	if x != nil {
		return x.CreationTimestampStart
	}
	return 0
}

func (x *VaultSearchReq) GetCreationTimestampEnd() uint64 {
	if x != nil {
		return x.CreationTimestampEnd
	}
	return 0
}

func (x *VaultSearchReq) GetModificationTimestampStart() uint64 {
	if x != nil {
		return x.ModificationTimestampStart
	}
	return 0
}

func (x *VaultSearchReq) GetModificationTimestampEnd() uint64 {
	if x != nil {
		return x.ModificationTimestampEnd
	}
	return 0
}

func (x *VaultSearchReq) GetEntityUuid() string {
	if x != nil {
		return x.EntityUuid
	}
	return ""
}

func (x *VaultSearchReq) GetRefFor() VAULT_REF_FOR {
	if x != nil {
		return x.RefFor
	}
	return VAULT_REF_FOR_VAULT_REF_FOR_ANY_UNSPECIFIED
}

func (x *VaultSearchReq) GetFolderUuid() string {
	if x != nil {
		return x.FolderUuid
	}
	return ""
}

func (x *VaultSearchReq) GetSearchKey() string {
	if x != nil {
		return x.SearchKey
	}
	return ""
}

// Describes the search information of vault files and folders into a single message
type VaultSearchResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The search name
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// The type of the file
	Type VAULT_REF_FOR `protobuf:"varint,2,opt,name=type,proto3,enum=Scailo.VAULT_REF_FOR" json:"type,omitempty"`
	// The ID of the element
	ElementId uint64 `protobuf:"varint,3,opt,name=element_id,json=elementId,proto3" json:"element_id,omitempty"`
	// The UUID of the element
	ElementUuid string `protobuf:"bytes,4,opt,name=element_uuid,json=elementUuid,proto3" json:"element_uuid,omitempty"`
	// The full path of the folder or the file
	Path string `protobuf:"bytes,5,opt,name=path,proto3" json:"path,omitempty"`
	// The link to the parent folder
	ParentFolderUuid string `protobuf:"bytes,6,opt,name=parent_folder_uuid,json=parentFolderUuid,proto3" json:"parent_folder_uuid,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *VaultSearchResponse) Reset() {
	*x = VaultSearchResponse{}
	mi := &file_vault_commons_scailo_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VaultSearchResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VaultSearchResponse) ProtoMessage() {}

func (x *VaultSearchResponse) ProtoReflect() protoreflect.Message {
	mi := &file_vault_commons_scailo_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VaultSearchResponse.ProtoReflect.Descriptor instead.
func (*VaultSearchResponse) Descriptor() ([]byte, []int) {
	return file_vault_commons_scailo_proto_rawDescGZIP(), []int{10}
}

func (x *VaultSearchResponse) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *VaultSearchResponse) GetType() VAULT_REF_FOR {
	if x != nil {
		return x.Type
	}
	return VAULT_REF_FOR_VAULT_REF_FOR_ANY_UNSPECIFIED
}

func (x *VaultSearchResponse) GetElementId() uint64 {
	if x != nil {
		return x.ElementId
	}
	return 0
}

func (x *VaultSearchResponse) GetElementUuid() string {
	if x != nil {
		return x.ElementUuid
	}
	return ""
}

func (x *VaultSearchResponse) GetPath() string {
	if x != nil {
		return x.Path
	}
	return ""
}

func (x *VaultSearchResponse) GetParentFolderUuid() string {
	if x != nil {
		return x.ParentFolderUuid
	}
	return ""
}

// Describes the message consisting of the list of vault search response
type VaultSearchResponsesList struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// List of search responses
	List          []*VaultSearchResponse `protobuf:"bytes,1,rep,name=list,proto3" json:"list,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *VaultSearchResponsesList) Reset() {
	*x = VaultSearchResponsesList{}
	mi := &file_vault_commons_scailo_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VaultSearchResponsesList) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VaultSearchResponsesList) ProtoMessage() {}

func (x *VaultSearchResponsesList) ProtoReflect() protoreflect.Message {
	mi := &file_vault_commons_scailo_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VaultSearchResponsesList.ProtoReflect.Descriptor instead.
func (*VaultSearchResponsesList) Descriptor() ([]byte, []int) {
	return file_vault_commons_scailo_proto_rawDescGZIP(), []int{11}
}

func (x *VaultSearchResponsesList) GetList() []*VaultSearchResponse {
	if x != nil {
		return x.List
	}
	return nil
}

// Describes the message to test if the file or folder already exists in the given folder UUID
type VaultDuplicateCheckReq struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The name of the file/folder
	Name string `protobuf:"bytes,10,opt,name=name,proto3" json:"name,omitempty"`
	// The UUID of the folder that the file/folder will reside in
	FolderUuid    string `protobuf:"bytes,13,opt,name=folder_uuid,json=folderUuid,proto3" json:"folder_uuid,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *VaultDuplicateCheckReq) Reset() {
	*x = VaultDuplicateCheckReq{}
	mi := &file_vault_commons_scailo_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VaultDuplicateCheckReq) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VaultDuplicateCheckReq) ProtoMessage() {}

func (x *VaultDuplicateCheckReq) ProtoReflect() protoreflect.Message {
	mi := &file_vault_commons_scailo_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VaultDuplicateCheckReq.ProtoReflect.Descriptor instead.
func (*VaultDuplicateCheckReq) Descriptor() ([]byte, []int) {
	return file_vault_commons_scailo_proto_rawDescGZIP(), []int{12}
}

func (x *VaultDuplicateCheckReq) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *VaultDuplicateCheckReq) GetFolderUuid() string {
	if x != nil {
		return x.FolderUuid
	}
	return ""
}

// Describes the access log of every file or folder
type VaultAccessLog struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Stores a globally unique entity UUID. This will be set at the organization level
	EntityUuid string `protobuf:"bytes,1,opt,name=entity_uuid,json=entityUuid,proto3" json:"entity_uuid,omitempty"`
	// Stores the metadata of this user
	Metadata *EmployeeMetadata `protobuf:"bytes,2,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// Stores the reference for which this access log is applicable
	RefFor VAULT_REF_FOR `protobuf:"varint,10,opt,name=ref_for,json=refFor,proto3,enum=Scailo.VAULT_REF_FOR" json:"ref_for,omitempty"`
	// Stores the ID of the underlying file or folder that has been accessed
	RefId uint64 `protobuf:"varint,11,opt,name=ref_id,json=refId,proto3" json:"ref_id,omitempty"`
	// Stores the username of the user who accessed this resource
	Username string `protobuf:"bytes,12,opt,name=username,proto3" json:"username,omitempty"`
	// Stores the IP address from where the resource was accessed
	IpAddr string `protobuf:"bytes,13,opt,name=ip_addr,json=ipAddr,proto3" json:"ip_addr,omitempty"`
	// Stores the operation that was performed (Add/Move/Rename/Delete/Download)
	Operation VAULT_ACCESS_LOG_OPERATION `protobuf:"varint,14,opt,name=operation,proto3,enum=Scailo.VAULT_ACCESS_LOG_OPERATION" json:"operation,omitempty"`
	// Stores the comment that describes the operation
	Comment       string `protobuf:"bytes,15,opt,name=comment,proto3" json:"comment,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *VaultAccessLog) Reset() {
	*x = VaultAccessLog{}
	mi := &file_vault_commons_scailo_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VaultAccessLog) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VaultAccessLog) ProtoMessage() {}

func (x *VaultAccessLog) ProtoReflect() protoreflect.Message {
	mi := &file_vault_commons_scailo_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VaultAccessLog.ProtoReflect.Descriptor instead.
func (*VaultAccessLog) Descriptor() ([]byte, []int) {
	return file_vault_commons_scailo_proto_rawDescGZIP(), []int{13}
}

func (x *VaultAccessLog) GetEntityUuid() string {
	if x != nil {
		return x.EntityUuid
	}
	return ""
}

func (x *VaultAccessLog) GetMetadata() *EmployeeMetadata {
	if x != nil {
		return x.Metadata
	}
	return nil
}

func (x *VaultAccessLog) GetRefFor() VAULT_REF_FOR {
	if x != nil {
		return x.RefFor
	}
	return VAULT_REF_FOR_VAULT_REF_FOR_ANY_UNSPECIFIED
}

func (x *VaultAccessLog) GetRefId() uint64 {
	if x != nil {
		return x.RefId
	}
	return 0
}

func (x *VaultAccessLog) GetUsername() string {
	if x != nil {
		return x.Username
	}
	return ""
}

func (x *VaultAccessLog) GetIpAddr() string {
	if x != nil {
		return x.IpAddr
	}
	return ""
}

func (x *VaultAccessLog) GetOperation() VAULT_ACCESS_LOG_OPERATION {
	if x != nil {
		return x.Operation
	}
	return VAULT_ACCESS_LOG_OPERATION_VAULT_ACCESS_LOG_OPERATION_ANY_UNSPECIFIED
}

func (x *VaultAccessLog) GetComment() string {
	if x != nil {
		return x.Comment
	}
	return ""
}

// Describes the necessary parameters to create an access log
type VaultAccessLogCreateRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Stores a globally unique entity UUID. This will be set at the organization level
	EntityUuid string `protobuf:"bytes,1,opt,name=entity_uuid,json=entityUuid,proto3" json:"entity_uuid,omitempty"`
	// Stores the reference for which this access log is applicable
	RefFor VAULT_REF_FOR `protobuf:"varint,10,opt,name=ref_for,json=refFor,proto3,enum=Scailo.VAULT_REF_FOR" json:"ref_for,omitempty"`
	// Stores the ID of the underlying file or folder that has been accessed
	RefId uint64 `protobuf:"varint,11,opt,name=ref_id,json=refId,proto3" json:"ref_id,omitempty"`
	// Stores the username of the user who accessed this resource
	Username string `protobuf:"bytes,12,opt,name=username,proto3" json:"username,omitempty"`
	// Stores the IP address from where the resource was accessed
	IpAddr string `protobuf:"bytes,13,opt,name=ip_addr,json=ipAddr,proto3" json:"ip_addr,omitempty"`
	// Stores the operation that was performed (Add/Move/Rename/Delete/Download)
	Operation VAULT_ACCESS_LOG_OPERATION `protobuf:"varint,14,opt,name=operation,proto3,enum=Scailo.VAULT_ACCESS_LOG_OPERATION" json:"operation,omitempty"`
	// Stores the comment that describes the operation
	Comment       string `protobuf:"bytes,15,opt,name=comment,proto3" json:"comment,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *VaultAccessLogCreateRequest) Reset() {
	*x = VaultAccessLogCreateRequest{}
	mi := &file_vault_commons_scailo_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VaultAccessLogCreateRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VaultAccessLogCreateRequest) ProtoMessage() {}

func (x *VaultAccessLogCreateRequest) ProtoReflect() protoreflect.Message {
	mi := &file_vault_commons_scailo_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VaultAccessLogCreateRequest.ProtoReflect.Descriptor instead.
func (*VaultAccessLogCreateRequest) Descriptor() ([]byte, []int) {
	return file_vault_commons_scailo_proto_rawDescGZIP(), []int{14}
}

func (x *VaultAccessLogCreateRequest) GetEntityUuid() string {
	if x != nil {
		return x.EntityUuid
	}
	return ""
}

func (x *VaultAccessLogCreateRequest) GetRefFor() VAULT_REF_FOR {
	if x != nil {
		return x.RefFor
	}
	return VAULT_REF_FOR_VAULT_REF_FOR_ANY_UNSPECIFIED
}

func (x *VaultAccessLogCreateRequest) GetRefId() uint64 {
	if x != nil {
		return x.RefId
	}
	return 0
}

func (x *VaultAccessLogCreateRequest) GetUsername() string {
	if x != nil {
		return x.Username
	}
	return ""
}

func (x *VaultAccessLogCreateRequest) GetIpAddr() string {
	if x != nil {
		return x.IpAddr
	}
	return ""
}

func (x *VaultAccessLogCreateRequest) GetOperation() VAULT_ACCESS_LOG_OPERATION {
	if x != nil {
		return x.Operation
	}
	return VAULT_ACCESS_LOG_OPERATION_VAULT_ACCESS_LOG_OPERATION_ANY_UNSPECIFIED
}

func (x *VaultAccessLogCreateRequest) GetComment() string {
	if x != nil {
		return x.Comment
	}
	return ""
}

// Describes the message consisting of the list of access logs
type VaultAccessLogsList struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// List of access logs
	List          []*VaultAccessLog `protobuf:"bytes,1,rep,name=list,proto3" json:"list,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *VaultAccessLogsList) Reset() {
	*x = VaultAccessLogsList{}
	mi := &file_vault_commons_scailo_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VaultAccessLogsList) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VaultAccessLogsList) ProtoMessage() {}

func (x *VaultAccessLogsList) ProtoReflect() protoreflect.Message {
	mi := &file_vault_commons_scailo_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VaultAccessLogsList.ProtoReflect.Descriptor instead.
func (*VaultAccessLogsList) Descriptor() ([]byte, []int) {
	return file_vault_commons_scailo_proto_rawDescGZIP(), []int{15}
}

func (x *VaultAccessLogsList) GetList() []*VaultAccessLog {
	if x != nil {
		return x.List
	}
	return nil
}

var File_vault_commons_scailo_proto protoreflect.FileDescriptor

const file_vault_commons_scailo_proto_rawDesc = "" +
	"\n" +
	"\x1avault_commons.scailo.proto\x12\x06Scailo\x1a\x11base.scailo.proto\x1a\x1bbuf/validate/validate.proto\"\xf1\x01\n" +
	"\x0fVaultPermission\x12\x1f\n" +
	"\ventity_uuid\x18\x01 \x01(\tR\n" +
	"entityUuid\x124\n" +
	"\bmetadata\x18\x02 \x01(\v2\x18.Scailo.EmployeeMetadataR\bmetadata\x12.\n" +
	"\aref_for\x18\n" +
	" \x01(\x0e2\x15.Scailo.VAULT_REF_FORR\x06refFor\x12\x15\n" +
	"\x06ref_id\x18\v \x01(\x04R\x05refId\x12\x17\n" +
	"\arole_id\x18\f \x01(\x04R\x06roleId\x12'\n" +
	"\x0fpermission_code\x18\r \x01(\x04R\x0epermissionCode\"\xd8\x01\n" +
	"\x19VaultPermissionAddRequest\x12\x1f\n" +
	"\ventity_uuid\x18\x01 \x01(\tR\n" +
	"entityUuid\x12!\n" +
	"\fuser_comment\x18\x02 \x01(\tR\vuserComment\x12#\n" +
	"\bref_uuid\x18\v \x01(\tB\b\xbaH\x05r\x03\xb0\x01\x01R\arefUuid\x12 \n" +
	"\arole_id\x18\f \x01(\x04B\a\xbaH\x042\x02 \x00R\x06roleId\x120\n" +
	"\x0fpermission_code\x18\r \x01(\x04B\a\xbaH\x042\x02 \x00R\x0epermissionCode\"\x91\x01\n" +
	"\x1cVaultPermissionModifyRequest\x12\x1c\n" +
	"\x04uuid\x18\x01 \x01(\tB\b\xbaH\x05r\x03\xb0\x01\x01R\x04uuid\x12!\n" +
	"\fuser_comment\x18\x02 \x01(\tR\vuserComment\x120\n" +
	"\x0fpermission_code\x18\r \x01(\x04B\a\xbaH\x042\x02 \x00R\x0epermissionCode\"j\n" +
	"\fGixResources\x12\x1e\n" +
	"\n" +
	"html_entry\x18\x01 \x01(\tR\n" +
	"html_entry\x12\x14\n" +
	"\x05logos\x18\x02 \x03(\tR\x05logos\x12$\n" +
	"\rexternal_apis\x18\x03 \x03(\tR\rexternal_apis\"\xc5\x02\n" +
	"\vGiXManifest\x12*\n" +
	"\x10manifest_version\x18\x01 \x01(\tR\x10manifest_version\x12 \n" +
	"\vapp_version\x18\x02 \x01(\tR\vapp_version\x12\x1a\n" +
	"\bapp_name\x18\x03 \x01(\tR\bapp_name\x124\n" +
	"\x15app_unique_identifier\x18\x04 \x01(\tR\x15app_unique_identifier\x120\n" +
	"\x13min_genesis_version\x18\x05 \x01(\tR\x13min_genesis_version\x120\n" +
	"\x13max_genesis_version\x18\x06 \x01(\tR\x13max_genesis_version\x122\n" +
	"\tresources\x18\a \x01(\v2\x14.Scailo.GixResourcesR\tresources\"\xd4\x03\n" +
	"\tGiXAppRun\x12\x1f\n" +
	"\ventity_uuid\x18\x01 \x01(\tR\n" +
	"entityUuid\x124\n" +
	"\bmetadata\x18\x02 \x01(\v2\x18.Scailo.EmployeeMetadataR\bmetadata\x12\"\n" +
	"\rvault_file_id\x18\n" +
	" \x01(\x04R\vvaultFileId\x121\n" +
	"\x15vault_file_version_id\x18\v \x01(\x04R\x12vaultFileVersionId\x122\n" +
	"\x15app_unique_identifier\x18\f \x01(\tR\x13appUniqueIdentifier\x12%\n" +
	"\x0eextracted_path\x18\r \x01(\tR\rextractedPath\x12\x17\n" +
	"\aip_addr\x18\x0e \x01(\tR\x06ipAddr\x12/\n" +
	"\bmanifest\x18\x0f \x01(\v2\x13.Scailo.GiXManifestR\bmanifest\x12\x15\n" +
	"\x06run_by\x18\x10 \x01(\tR\x05runBy\x12\x1f\n" +
	"\vapp_version\x18\x1e \x01(\tR\n" +
	"appVersion\x12\x19\n" +
	"\bapp_name\x18\x1f \x01(\tR\aappName\x12!\n" +
	"\fapp_endpoint\x18( \x01(\tR\vappEndpoint\"7\n" +
	"\x0eGiXAppRunsList\x12%\n" +
	"\x04list\x18\x01 \x03(\v2\x11.Scailo.GiXAppRunR\x04list\"\xab\x03\n" +
	"\x11GiXAppRunCountReq\x120\n" +
	"\tis_active\x18\x01 \x01(\x0e2\x13.Scailo.BOOL_FILTERR\bisActive\x128\n" +
	"\x18creation_timestamp_start\x18e \x01(\x04R\x16creationTimestampStart\x124\n" +
	"\x16creation_timestamp_end\x18f \x01(\x04R\x14creationTimestampEnd\x12@\n" +
	"\x1cmodification_timestamp_start\x18g \x01(\x04R\x1amodificationTimestampStart\x12<\n" +
	"\x1amodification_timestamp_end\x18h \x01(\x04R\x18modificationTimestampEnd\x12&\n" +
	"\x0fvault_file_uuid\x18\x14 \x01(\tR\rvaultFileUuid\x125\n" +
	"\x17vault_file_version_uuid\x18\x15 \x01(\tR\x14vaultFileVersionUuid\x12\x15\n" +
	"\x06run_by\x18\x1e \x01(\tR\x05runBy\"\xf5\x03\n" +
	"\x12GiXAppRunFilterReq\x120\n" +
	"\tis_active\x18\x01 \x01(\x0e2\x13.Scailo.BOOL_FILTERR\bisActive\x12&\n" +
	"\x05count\x18\x02 \x01(\x03B\x10\xbaH\r\"\v(\xff\xff\xff\xff\xff\xff\xff\xff\xff\x01R\x05count\x12\x1f\n" +
	"\x06offset\x18\x03 \x01(\x04B\a\xbaH\x042\x02(\x00R\x06offset\x128\n" +
	"\x18creation_timestamp_start\x18e \x01(\x04R\x16creationTimestampStart\x124\n" +
	"\x16creation_timestamp_end\x18f \x01(\x04R\x14creationTimestampEnd\x12@\n" +
	"\x1cmodification_timestamp_start\x18g \x01(\x04R\x1amodificationTimestampStart\x12<\n" +
	"\x1amodification_timestamp_end\x18h \x01(\x04R\x18modificationTimestampEnd\x12&\n" +
	"\x0fvault_file_uuid\x18\x14 \x01(\tR\rvaultFileUuid\x125\n" +
	"\x17vault_file_version_uuid\x18\x15 \x01(\tR\x14vaultFileVersionUuid\x12\x15\n" +
	"\x06run_by\x18\x1e \x01(\tR\x05runBy\"\xf2\x04\n" +
	"\x0eVaultSearchReq\x120\n" +
	"\tis_active\x18\x01 \x01(\x0e2\x13.Scailo.BOOL_FILTERR\bisActive\x12&\n" +
	"\x05count\x18\x02 \x01(\x03B\x10\xbaH\r\"\v(\xff\xff\xff\xff\xff\xff\xff\xff\xff\x01R\x05count\x12\x1f\n" +
	"\x06offset\x18\x03 \x01(\x04B\a\xbaH\x042\x02(\x00R\x06offset\x121\n" +
	"\n" +
	"sort_order\x18\x04 \x01(\x0e2\x12.Scailo.SORT_ORDERR\tsortOrder\x121\n" +
	"\bsort_key\x18\x05 \x01(\x0e2\x16.Scailo.VAULT_SORT_KEYR\asortKey\x128\n" +
	"\x18creation_timestamp_start\x18e \x01(\x04R\x16creationTimestampStart\x124\n" +
	"\x16creation_timestamp_end\x18f \x01(\x04R\x14creationTimestampEnd\x12@\n" +
	"\x1cmodification_timestamp_start\x18g \x01(\x04R\x1amodificationTimestampStart\x12<\n" +
	"\x1amodification_timestamp_end\x18h \x01(\x04R\x18modificationTimestampEnd\x12\x1f\n" +
	"\ventity_uuid\x18\b \x01(\tR\n" +
	"entityUuid\x12.\n" +
	"\aref_for\x18\t \x01(\x0e2\x15.Scailo.VAULT_REF_FORR\x06refFor\x12\x1f\n" +
	"\vfolder_uuid\x18\n" +
	" \x01(\tR\n" +
	"folderUuid\x12\x1d\n" +
	"\n" +
	"search_key\x18\v \x01(\tR\tsearchKey\"\xd8\x01\n" +
	"\x13VaultSearchResponse\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12)\n" +
	"\x04type\x18\x02 \x01(\x0e2\x15.Scailo.VAULT_REF_FORR\x04type\x12\x1d\n" +
	"\n" +
	"element_id\x18\x03 \x01(\x04R\telementId\x12!\n" +
	"\felement_uuid\x18\x04 \x01(\tR\velementUuid\x12\x12\n" +
	"\x04path\x18\x05 \x01(\tR\x04path\x12,\n" +
	"\x12parent_folder_uuid\x18\x06 \x01(\tR\x10parentFolderUuid\"K\n" +
	"\x18VaultSearchResponsesList\x12/\n" +
	"\x04list\x18\x01 \x03(\v2\x1b.Scailo.VaultSearchResponseR\x04list\"`\n" +
	"\x16VaultDuplicateCheckReq\x12\x1b\n" +
	"\x04name\x18\n" +
	" \x01(\tB\a\xbaH\x04r\x02\x10\x01R\x04name\x12)\n" +
	"\vfolder_uuid\x18\r \x01(\tB\b\xbaH\x05r\x03\xb0\x01\x01R\n" +
	"folderUuid\"\xbf\x02\n" +
	"\x0eVaultAccessLog\x12\x1f\n" +
	"\ventity_uuid\x18\x01 \x01(\tR\n" +
	"entityUuid\x124\n" +
	"\bmetadata\x18\x02 \x01(\v2\x18.Scailo.EmployeeMetadataR\bmetadata\x12.\n" +
	"\aref_for\x18\n" +
	" \x01(\x0e2\x15.Scailo.VAULT_REF_FORR\x06refFor\x12\x15\n" +
	"\x06ref_id\x18\v \x01(\x04R\x05refId\x12\x1a\n" +
	"\busername\x18\f \x01(\tR\busername\x12\x17\n" +
	"\aip_addr\x18\r \x01(\tR\x06ipAddr\x12@\n" +
	"\toperation\x18\x0e \x01(\x0e2\".Scailo.VAULT_ACCESS_LOG_OPERATIONR\toperation\x12\x18\n" +
	"\acomment\x18\x0f \x01(\tR\acomment\"\xb1\x02\n" +
	"\x1bVaultAccessLogCreateRequest\x12\x1f\n" +
	"\ventity_uuid\x18\x01 \x01(\tR\n" +
	"entityUuid\x12.\n" +
	"\aref_for\x18\n" +
	" \x01(\x0e2\x15.Scailo.VAULT_REF_FORR\x06refFor\x12\x1e\n" +
	"\x06ref_id\x18\v \x01(\x04B\a\xbaH\x042\x02 \x00R\x05refId\x12#\n" +
	"\busername\x18\f \x01(\tB\a\xbaH\x04r\x02\x10\x01R\busername\x12 \n" +
	"\aip_addr\x18\r \x01(\tB\a\xbaH\x04r\x02p\x01R\x06ipAddr\x12@\n" +
	"\toperation\x18\x0e \x01(\x0e2\".Scailo.VAULT_ACCESS_LOG_OPERATIONR\toperation\x12\x18\n" +
	"\acomment\x18\x0f \x01(\tR\acomment\"A\n" +
	"\x13VaultAccessLogsList\x12*\n" +
	"\x04list\x18\x01 \x03(\v2\x16.Scailo.VaultAccessLogR\x04list*d\n" +
	"\rVAULT_REF_FOR\x12!\n" +
	"\x1dVAULT_REF_FOR_ANY_UNSPECIFIED\x10\x00\x12\x16\n" +
	"\x12VAULT_REF_FOR_FILE\x10\x01\x12\x18\n" +
	"\x14VAULT_REF_FOR_FOLDER\x10\x02*\xa5\x02\n" +
	"\x15VAULT_PERMISSION_CODE\x12%\n" +
	"!VAULT_PERMISSION_CODE_UNSPECIFIED\x10\x00\x12\x1e\n" +
	"\x1aVAULT_PERMISSION_CODE_VIEW\x10\x01\x12\x1e\n" +
	"\x1aVAULT_PERMISSION_CODE_META\x10\x02\x12\"\n" +
	"\x1eVAULT_PERMISSION_CODE_DOWNLOAD\x10\x04\x12\x1d\n" +
	"\x19VAULT_PERMISSION_CODE_ADD\x10\b\x12 \n" +
	"\x1cVAULT_PERMISSION_CODE_DELETE\x10\x10\x12!\n" +
	"\x1dVAULT_PERMISSION_CODE_EXECUTE\x10 \x12\x1d\n" +
	"\x19VAULT_PERMISSION_CODE_ALL\x10?*\x8b\x01\n" +
	"\x0eVAULT_SORT_KEY\x12!\n" +
	"\x1dVAULT_SORT_KEY_ID_UNSPECIFIED\x10\x00\x12\x1d\n" +
	"\x19VAULT_SORT_KEY_CREATED_AT\x10\x01\x12\x1e\n" +
	"\x1aVAULT_SORT_KEY_MODIFIED_AT\x10\x02\x12\x17\n" +
	"\x13VAULT_SORT_KEY_NAME\x10\n" +
	"*\xdb\x03\n" +
	"\x1aVAULT_ACCESS_LOG_OPERATION\x12.\n" +
	"*VAULT_ACCESS_LOG_OPERATION_ANY_UNSPECIFIED\x10\x00\x12%\n" +
	"!VAULT_ACCESS_LOG_OPERATION_CREATE\x10\x01\x12#\n" +
	"\x1fVAULT_ACCESS_LOG_OPERATION_MOVE\x10\x02\x12%\n" +
	"!VAULT_ACCESS_LOG_OPERATION_RENAME\x10\x03\x12%\n" +
	"!VAULT_ACCESS_LOG_OPERATION_DELETE\x10\x04\x12'\n" +
	"#VAULT_ACCESS_LOG_OPERATION_DOWNLOAD\x10\x05\x12%\n" +
	"!VAULT_ACCESS_LOG_OPERATION_UPLOAD\x10\x06\x12$\n" +
	" VAULT_ACCESS_LOG_OPERATION_UNZIP\x10\a\x12)\n" +
	"%VAULT_ACCESS_LOG_OPERATION_PERSISTENT\x10\b\x12*\n" +
	"&VAULT_ACCESS_LOG_OPERATION_PERMISSIONS\x10\t\x12&\n" +
	"\"VAULT_ACCESS_LOG_OPERATION_EXECUTE\x10\n" +
	"Bi\n" +
	"\n" +
	"com.ScailoB\x17VaultCommonsScailoProtoP\x01Z\n" +
	"Scailo/sdk\xa2\x02\x03SXX\xaa\x02\x06Scailo\xca\x02\x06Scailo\xe2\x02\x12Scailo\\GPBMetadata\xea\x02\x06Scailob\x06proto3"

var (
	file_vault_commons_scailo_proto_rawDescOnce sync.Once
	file_vault_commons_scailo_proto_rawDescData []byte
)

func file_vault_commons_scailo_proto_rawDescGZIP() []byte {
	file_vault_commons_scailo_proto_rawDescOnce.Do(func() {
		file_vault_commons_scailo_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_vault_commons_scailo_proto_rawDesc), len(file_vault_commons_scailo_proto_rawDesc)))
	})
	return file_vault_commons_scailo_proto_rawDescData
}

var file_vault_commons_scailo_proto_enumTypes = make([]protoimpl.EnumInfo, 4)
var file_vault_commons_scailo_proto_msgTypes = make([]protoimpl.MessageInfo, 16)
var file_vault_commons_scailo_proto_goTypes = []any{
	(VAULT_REF_FOR)(0),                   // 0: Scailo.VAULT_REF_FOR
	(VAULT_PERMISSION_CODE)(0),           // 1: Scailo.VAULT_PERMISSION_CODE
	(VAULT_SORT_KEY)(0),                  // 2: Scailo.VAULT_SORT_KEY
	(VAULT_ACCESS_LOG_OPERATION)(0),      // 3: Scailo.VAULT_ACCESS_LOG_OPERATION
	(*VaultPermission)(nil),              // 4: Scailo.VaultPermission
	(*VaultPermissionAddRequest)(nil),    // 5: Scailo.VaultPermissionAddRequest
	(*VaultPermissionModifyRequest)(nil), // 6: Scailo.VaultPermissionModifyRequest
	(*GixResources)(nil),                 // 7: Scailo.GixResources
	(*GiXManifest)(nil),                  // 8: Scailo.GiXManifest
	(*GiXAppRun)(nil),                    // 9: Scailo.GiXAppRun
	(*GiXAppRunsList)(nil),               // 10: Scailo.GiXAppRunsList
	(*GiXAppRunCountReq)(nil),            // 11: Scailo.GiXAppRunCountReq
	(*GiXAppRunFilterReq)(nil),           // 12: Scailo.GiXAppRunFilterReq
	(*VaultSearchReq)(nil),               // 13: Scailo.VaultSearchReq
	(*VaultSearchResponse)(nil),          // 14: Scailo.VaultSearchResponse
	(*VaultSearchResponsesList)(nil),     // 15: Scailo.VaultSearchResponsesList
	(*VaultDuplicateCheckReq)(nil),       // 16: Scailo.VaultDuplicateCheckReq
	(*VaultAccessLog)(nil),               // 17: Scailo.VaultAccessLog
	(*VaultAccessLogCreateRequest)(nil),  // 18: Scailo.VaultAccessLogCreateRequest
	(*VaultAccessLogsList)(nil),          // 19: Scailo.VaultAccessLogsList
	(*EmployeeMetadata)(nil),             // 20: Scailo.EmployeeMetadata
	(BOOL_FILTER)(0),                     // 21: Scailo.BOOL_FILTER
	(SORT_ORDER)(0),                      // 22: Scailo.SORT_ORDER
}
var file_vault_commons_scailo_proto_depIdxs = []int32{
	20, // 0: Scailo.VaultPermission.metadata:type_name -> Scailo.EmployeeMetadata
	0,  // 1: Scailo.VaultPermission.ref_for:type_name -> Scailo.VAULT_REF_FOR
	7,  // 2: Scailo.GiXManifest.resources:type_name -> Scailo.GixResources
	20, // 3: Scailo.GiXAppRun.metadata:type_name -> Scailo.EmployeeMetadata
	8,  // 4: Scailo.GiXAppRun.manifest:type_name -> Scailo.GiXManifest
	9,  // 5: Scailo.GiXAppRunsList.list:type_name -> Scailo.GiXAppRun
	21, // 6: Scailo.GiXAppRunCountReq.is_active:type_name -> Scailo.BOOL_FILTER
	21, // 7: Scailo.GiXAppRunFilterReq.is_active:type_name -> Scailo.BOOL_FILTER
	21, // 8: Scailo.VaultSearchReq.is_active:type_name -> Scailo.BOOL_FILTER
	22, // 9: Scailo.VaultSearchReq.sort_order:type_name -> Scailo.SORT_ORDER
	2,  // 10: Scailo.VaultSearchReq.sort_key:type_name -> Scailo.VAULT_SORT_KEY
	0,  // 11: Scailo.VaultSearchReq.ref_for:type_name -> Scailo.VAULT_REF_FOR
	0,  // 12: Scailo.VaultSearchResponse.type:type_name -> Scailo.VAULT_REF_FOR
	14, // 13: Scailo.VaultSearchResponsesList.list:type_name -> Scailo.VaultSearchResponse
	20, // 14: Scailo.VaultAccessLog.metadata:type_name -> Scailo.EmployeeMetadata
	0,  // 15: Scailo.VaultAccessLog.ref_for:type_name -> Scailo.VAULT_REF_FOR
	3,  // 16: Scailo.VaultAccessLog.operation:type_name -> Scailo.VAULT_ACCESS_LOG_OPERATION
	0,  // 17: Scailo.VaultAccessLogCreateRequest.ref_for:type_name -> Scailo.VAULT_REF_FOR
	3,  // 18: Scailo.VaultAccessLogCreateRequest.operation:type_name -> Scailo.VAULT_ACCESS_LOG_OPERATION
	17, // 19: Scailo.VaultAccessLogsList.list:type_name -> Scailo.VaultAccessLog
	20, // [20:20] is the sub-list for method output_type
	20, // [20:20] is the sub-list for method input_type
	20, // [20:20] is the sub-list for extension type_name
	20, // [20:20] is the sub-list for extension extendee
	0,  // [0:20] is the sub-list for field type_name
}

func init() { file_vault_commons_scailo_proto_init() }
func file_vault_commons_scailo_proto_init() {
	if File_vault_commons_scailo_proto != nil {
		return
	}
	file_base_scailo_proto_init()
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_vault_commons_scailo_proto_rawDesc), len(file_vault_commons_scailo_proto_rawDesc)),
			NumEnums:      4,
			NumMessages:   16,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_vault_commons_scailo_proto_goTypes,
		DependencyIndexes: file_vault_commons_scailo_proto_depIdxs,
		EnumInfos:         file_vault_commons_scailo_proto_enumTypes,
		MessageInfos:      file_vault_commons_scailo_proto_msgTypes,
	}.Build()
	File_vault_commons_scailo_proto = out.File
	file_vault_commons_scailo_proto_goTypes = nil
	file_vault_commons_scailo_proto_depIdxs = nil
}
