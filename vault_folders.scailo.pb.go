// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.8
// 	protoc        (unknown)
// source: vault_folders.scailo.proto

package sdk

import (
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"

	_ "buf.build/gen/go/bufbuild/protovalidate/protocolbuffers/go/buf/validate"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Describes the parameters necessary to add a vault folder
type VaultFolderAddRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Stores a globally unique entity UUID. This will be set at the organization level
	EntityUuid string `protobuf:"bytes,1,opt,name=entity_uuid,json=entityUuid,proto3" json:"entity_uuid,omitempty"`
	// Stores any comment that the user might add during this operation
	UserComment string `protobuf:"bytes,2,opt,name=user_comment,json=userComment,proto3" json:"user_comment,omitempty"`
	// The name of the folder
	Name string `protobuf:"bytes,10,opt,name=name,proto3" json:"name,omitempty"`
	// The UUID of the parent folder
	ParentFolderUuid string `protobuf:"bytes,11,opt,name=parent_folder_uuid,json=parentFolderUuid,proto3" json:"parent_folder_uuid,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *VaultFolderAddRequest) Reset() {
	*x = VaultFolderAddRequest{}
	mi := &file_vault_folders_scailo_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VaultFolderAddRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VaultFolderAddRequest) ProtoMessage() {}

func (x *VaultFolderAddRequest) ProtoReflect() protoreflect.Message {
	mi := &file_vault_folders_scailo_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VaultFolderAddRequest.ProtoReflect.Descriptor instead.
func (*VaultFolderAddRequest) Descriptor() ([]byte, []int) {
	return file_vault_folders_scailo_proto_rawDescGZIP(), []int{0}
}

func (x *VaultFolderAddRequest) GetEntityUuid() string {
	if x != nil {
		return x.EntityUuid
	}
	return ""
}

func (x *VaultFolderAddRequest) GetUserComment() string {
	if x != nil {
		return x.UserComment
	}
	return ""
}

func (x *VaultFolderAddRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *VaultFolderAddRequest) GetParentFolderUuid() string {
	if x != nil {
		return x.ParentFolderUuid
	}
	return ""
}

// Describes the parameters necessary to move a vault folder
type VaultFolderMoveFolderRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The UUID of the folder
	SourceFolderUuid string `protobuf:"bytes,1,opt,name=source_folder_uuid,json=sourceFolderUuid,proto3" json:"source_folder_uuid,omitempty"`
	// The UUID of the destination folder that the folder needs to be moved into
	DestinationFolderUuid string `protobuf:"bytes,13,opt,name=destination_folder_uuid,json=destinationFolderUuid,proto3" json:"destination_folder_uuid,omitempty"`
	unknownFields         protoimpl.UnknownFields
	sizeCache             protoimpl.SizeCache
}

func (x *VaultFolderMoveFolderRequest) Reset() {
	*x = VaultFolderMoveFolderRequest{}
	mi := &file_vault_folders_scailo_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VaultFolderMoveFolderRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VaultFolderMoveFolderRequest) ProtoMessage() {}

func (x *VaultFolderMoveFolderRequest) ProtoReflect() protoreflect.Message {
	mi := &file_vault_folders_scailo_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VaultFolderMoveFolderRequest.ProtoReflect.Descriptor instead.
func (*VaultFolderMoveFolderRequest) Descriptor() ([]byte, []int) {
	return file_vault_folders_scailo_proto_rawDescGZIP(), []int{1}
}

func (x *VaultFolderMoveFolderRequest) GetSourceFolderUuid() string {
	if x != nil {
		return x.SourceFolderUuid
	}
	return ""
}

func (x *VaultFolderMoveFolderRequest) GetDestinationFolderUuid() string {
	if x != nil {
		return x.DestinationFolderUuid
	}
	return ""
}

// Describes the parameters necessary to rename a vault folder
type VaultFolderRenameFolderRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The UUID of the folder
	Uuid string `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	// The new name of the folder
	Name          string `protobuf:"bytes,10,opt,name=name,proto3" json:"name,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *VaultFolderRenameFolderRequest) Reset() {
	*x = VaultFolderRenameFolderRequest{}
	mi := &file_vault_folders_scailo_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VaultFolderRenameFolderRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VaultFolderRenameFolderRequest) ProtoMessage() {}

func (x *VaultFolderRenameFolderRequest) ProtoReflect() protoreflect.Message {
	mi := &file_vault_folders_scailo_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VaultFolderRenameFolderRequest.ProtoReflect.Descriptor instead.
func (*VaultFolderRenameFolderRequest) Descriptor() ([]byte, []int) {
	return file_vault_folders_scailo_proto_rawDescGZIP(), []int{2}
}

func (x *VaultFolderRenameFolderRequest) GetUuid() string {
	if x != nil {
		return x.Uuid
	}
	return ""
}

func (x *VaultFolderRenameFolderRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

// Describes the parameters of a vault parent folder
type VaultParentFolder struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Stores a globally unique entity UUID. This will be set at the organization level
	EntityUuid string `protobuf:"bytes,1,opt,name=entity_uuid,json=entityUuid,proto3" json:"entity_uuid,omitempty"`
	// Stores the metadata of this user
	Metadata *EmployeeMetadata `protobuf:"bytes,2,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// The name of the folder
	Name string `protobuf:"bytes,10,opt,name=name,proto3" json:"name,omitempty"`
	// The ID of the parent folder
	ParentFolderId uint64 `protobuf:"varint,11,opt,name=parent_folder_id,json=parentFolderId,proto3" json:"parent_folder_id,omitempty"`
	// The path of the folder
	PathTree string `protobuf:"bytes,12,opt,name=path_tree,json=pathTree,proto3" json:"path_tree,omitempty"`
	// The list of permissions
	Permissions []*VaultPermission `protobuf:"bytes,20,rep,name=permissions,proto3" json:"permissions,omitempty"`
	// The UUID of the parent folder
	ParentFolderUuid string `protobuf:"bytes,50,opt,name=parent_folder_uuid,json=parentFolderUuid,proto3" json:"parent_folder_uuid,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *VaultParentFolder) Reset() {
	*x = VaultParentFolder{}
	mi := &file_vault_folders_scailo_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VaultParentFolder) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VaultParentFolder) ProtoMessage() {}

func (x *VaultParentFolder) ProtoReflect() protoreflect.Message {
	mi := &file_vault_folders_scailo_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VaultParentFolder.ProtoReflect.Descriptor instead.
func (*VaultParentFolder) Descriptor() ([]byte, []int) {
	return file_vault_folders_scailo_proto_rawDescGZIP(), []int{3}
}

func (x *VaultParentFolder) GetEntityUuid() string {
	if x != nil {
		return x.EntityUuid
	}
	return ""
}

func (x *VaultParentFolder) GetMetadata() *EmployeeMetadata {
	if x != nil {
		return x.Metadata
	}
	return nil
}

func (x *VaultParentFolder) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *VaultParentFolder) GetParentFolderId() uint64 {
	if x != nil {
		return x.ParentFolderId
	}
	return 0
}

func (x *VaultParentFolder) GetPathTree() string {
	if x != nil {
		return x.PathTree
	}
	return ""
}

func (x *VaultParentFolder) GetPermissions() []*VaultPermission {
	if x != nil {
		return x.Permissions
	}
	return nil
}

func (x *VaultParentFolder) GetParentFolderUuid() string {
	if x != nil {
		return x.ParentFolderUuid
	}
	return ""
}

// Describes the parameters of a vault folder
type VaultFolder struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Stores a globally unique entity UUID. This will be set at the organization level
	EntityUuid string `protobuf:"bytes,1,opt,name=entity_uuid,json=entityUuid,proto3" json:"entity_uuid,omitempty"`
	// Stores the metadata of this user
	Metadata *EmployeeMetadata `protobuf:"bytes,2,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// The name of the folder
	Name string `protobuf:"bytes,10,opt,name=name,proto3" json:"name,omitempty"`
	// The ID of the parent folder
	ParentFolderId uint64 `protobuf:"varint,11,opt,name=parent_folder_id,json=parentFolderId,proto3" json:"parent_folder_id,omitempty"`
	// The path of the folder
	PathTree string `protobuf:"bytes,12,opt,name=path_tree,json=pathTree,proto3" json:"path_tree,omitempty"`
	// The list of permissions
	Permissions []*VaultPermission `protobuf:"bytes,20,rep,name=permissions,proto3" json:"permissions,omitempty"`
	// The list of all the parent folders
	ParentFolders []*VaultParentFolder `protobuf:"bytes,30,rep,name=parent_folders,json=parentFolders,proto3" json:"parent_folders,omitempty"`
	// The UUID of the parent folder
	ParentFolderUuid string `protobuf:"bytes,50,opt,name=parent_folder_uuid,json=parentFolderUuid,proto3" json:"parent_folder_uuid,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *VaultFolder) Reset() {
	*x = VaultFolder{}
	mi := &file_vault_folders_scailo_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VaultFolder) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VaultFolder) ProtoMessage() {}

func (x *VaultFolder) ProtoReflect() protoreflect.Message {
	mi := &file_vault_folders_scailo_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VaultFolder.ProtoReflect.Descriptor instead.
func (*VaultFolder) Descriptor() ([]byte, []int) {
	return file_vault_folders_scailo_proto_rawDescGZIP(), []int{4}
}

func (x *VaultFolder) GetEntityUuid() string {
	if x != nil {
		return x.EntityUuid
	}
	return ""
}

func (x *VaultFolder) GetMetadata() *EmployeeMetadata {
	if x != nil {
		return x.Metadata
	}
	return nil
}

func (x *VaultFolder) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *VaultFolder) GetParentFolderId() uint64 {
	if x != nil {
		return x.ParentFolderId
	}
	return 0
}

func (x *VaultFolder) GetPathTree() string {
	if x != nil {
		return x.PathTree
	}
	return ""
}

func (x *VaultFolder) GetPermissions() []*VaultPermission {
	if x != nil {
		return x.Permissions
	}
	return nil
}

func (x *VaultFolder) GetParentFolders() []*VaultParentFolder {
	if x != nil {
		return x.ParentFolders
	}
	return nil
}

func (x *VaultFolder) GetParentFolderUuid() string {
	if x != nil {
		return x.ParentFolderUuid
	}
	return ""
}

// Describes the message consisting of the list of vault folders
type VaultFoldersList struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// List of folders
	List          []*VaultFolder `protobuf:"bytes,1,rep,name=list,proto3" json:"list,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *VaultFoldersList) Reset() {
	*x = VaultFoldersList{}
	mi := &file_vault_folders_scailo_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VaultFoldersList) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VaultFoldersList) ProtoMessage() {}

func (x *VaultFoldersList) ProtoReflect() protoreflect.Message {
	mi := &file_vault_folders_scailo_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VaultFoldersList.ProtoReflect.Descriptor instead.
func (*VaultFoldersList) Descriptor() ([]byte, []int) {
	return file_vault_folders_scailo_proto_rawDescGZIP(), []int{5}
}

func (x *VaultFoldersList) GetList() []*VaultFolder {
	if x != nil {
		return x.List
	}
	return nil
}

// Describes the parameters of a vault folder download
type VaultFolderDownload struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Stores a globally unique entity UUID. This will be set at the organization level
	EntityUuid string `protobuf:"bytes,1,opt,name=entity_uuid,json=entityUuid,proto3" json:"entity_uuid,omitempty"`
	// Stores the metadata of this user
	Metadata *EmployeeMetadata `protobuf:"bytes,2,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// The ID of the folder that is being downloaded
	FolderId uint64 `protobuf:"varint,10,opt,name=folder_id,json=folderId,proto3" json:"folder_id,omitempty"`
	// The path to the generated zip file
	ZipFilePath string `protobuf:"bytes,11,opt,name=zip_file_path,json=zipFilePath,proto3" json:"zip_file_path,omitempty"`
	// Stores if the folder has been zipped
	IsZipped bool `protobuf:"varint,12,opt,name=is_zipped,json=isZipped,proto3" json:"is_zipped,omitempty"`
	// Stores the username of the user who requested this download
	RequestedBy string `protobuf:"bytes,13,opt,name=requested_by,json=requestedBy,proto3" json:"requested_by,omitempty"`
	// Stores the timestamp of when the download of the folder began
	DownloadStartedAt uint64 `protobuf:"varint,14,opt,name=download_started_at,json=downloadStartedAt,proto3" json:"download_started_at,omitempty"`
	// Stores the timestamp of when the download of the folder finished
	DownloadEndedAt uint64 `protobuf:"varint,15,opt,name=download_ended_at,json=downloadEndedAt,proto3" json:"download_ended_at,omitempty"`
	// Stores the username of the user who downloaded this folder
	DownloadedBy string `protobuf:"bytes,16,opt,name=downloaded_by,json=downloadedBy,proto3" json:"downloaded_by,omitempty"`
	// Stores an error encountered, if any
	Error         string `protobuf:"bytes,17,opt,name=error,proto3" json:"error,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *VaultFolderDownload) Reset() {
	*x = VaultFolderDownload{}
	mi := &file_vault_folders_scailo_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VaultFolderDownload) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VaultFolderDownload) ProtoMessage() {}

func (x *VaultFolderDownload) ProtoReflect() protoreflect.Message {
	mi := &file_vault_folders_scailo_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VaultFolderDownload.ProtoReflect.Descriptor instead.
func (*VaultFolderDownload) Descriptor() ([]byte, []int) {
	return file_vault_folders_scailo_proto_rawDescGZIP(), []int{6}
}

func (x *VaultFolderDownload) GetEntityUuid() string {
	if x != nil {
		return x.EntityUuid
	}
	return ""
}

func (x *VaultFolderDownload) GetMetadata() *EmployeeMetadata {
	if x != nil {
		return x.Metadata
	}
	return nil
}

func (x *VaultFolderDownload) GetFolderId() uint64 {
	if x != nil {
		return x.FolderId
	}
	return 0
}

func (x *VaultFolderDownload) GetZipFilePath() string {
	if x != nil {
		return x.ZipFilePath
	}
	return ""
}

func (x *VaultFolderDownload) GetIsZipped() bool {
	if x != nil {
		return x.IsZipped
	}
	return false
}

func (x *VaultFolderDownload) GetRequestedBy() string {
	if x != nil {
		return x.RequestedBy
	}
	return ""
}

func (x *VaultFolderDownload) GetDownloadStartedAt() uint64 {
	if x != nil {
		return x.DownloadStartedAt
	}
	return 0
}

func (x *VaultFolderDownload) GetDownloadEndedAt() uint64 {
	if x != nil {
		return x.DownloadEndedAt
	}
	return 0
}

func (x *VaultFolderDownload) GetDownloadedBy() string {
	if x != nil {
		return x.DownloadedBy
	}
	return ""
}

func (x *VaultFolderDownload) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

var File_vault_folders_scailo_proto protoreflect.FileDescriptor

const file_vault_folders_scailo_proto_rawDesc = "" +
	"\n" +
	"\x1avault_folders.scailo.proto\x12\x06Scailo\x1a\x11base.scailo.proto\x1a\x1bbuf/validate/validate.proto\x1a\x1avault_commons.scailo.proto\"\xb0\x01\n" +
	"\x15VaultFolderAddRequest\x12\x1f\n" +
	"\ventity_uuid\x18\x01 \x01(\tR\n" +
	"entityUuid\x12!\n" +
	"\fuser_comment\x18\x02 \x01(\tR\vuserComment\x12\x1b\n" +
	"\x04name\x18\n" +
	" \x01(\tB\a\xbaH\x04r\x02\x10\x01R\x04name\x126\n" +
	"\x12parent_folder_uuid\x18\v \x01(\tB\b\xbaH\x05r\x03\xb0\x01\x01R\x10parentFolderUuid\"\x98\x01\n" +
	"\x1cVaultFolderMoveFolderRequest\x126\n" +
	"\x12source_folder_uuid\x18\x01 \x01(\tB\b\xbaH\x05r\x03\xb0\x01\x01R\x10sourceFolderUuid\x12@\n" +
	"\x17destination_folder_uuid\x18\r \x01(\tB\b\xbaH\x05r\x03\xb0\x01\x01R\x15destinationFolderUuid\"[\n" +
	"\x1eVaultFolderRenameFolderRequest\x12\x1c\n" +
	"\x04uuid\x18\x01 \x01(\tB\b\xbaH\x05r\x03\xb0\x01\x01R\x04uuid\x12\x1b\n" +
	"\x04name\x18\n" +
	" \x01(\tB\a\xbaH\x04r\x02\x10\x01R\x04name\"\xae\x02\n" +
	"\x11VaultParentFolder\x12\x1f\n" +
	"\ventity_uuid\x18\x01 \x01(\tR\n" +
	"entityUuid\x124\n" +
	"\bmetadata\x18\x02 \x01(\v2\x18.Scailo.EmployeeMetadataR\bmetadata\x12\x12\n" +
	"\x04name\x18\n" +
	" \x01(\tR\x04name\x12(\n" +
	"\x10parent_folder_id\x18\v \x01(\x04R\x0eparentFolderId\x12\x1b\n" +
	"\tpath_tree\x18\f \x01(\tR\bpathTree\x129\n" +
	"\vpermissions\x18\x14 \x03(\v2\x17.Scailo.VaultPermissionR\vpermissions\x12,\n" +
	"\x12parent_folder_uuid\x182 \x01(\tR\x10parentFolderUuid\"\xea\x02\n" +
	"\vVaultFolder\x12\x1f\n" +
	"\ventity_uuid\x18\x01 \x01(\tR\n" +
	"entityUuid\x124\n" +
	"\bmetadata\x18\x02 \x01(\v2\x18.Scailo.EmployeeMetadataR\bmetadata\x12\x12\n" +
	"\x04name\x18\n" +
	" \x01(\tR\x04name\x12(\n" +
	"\x10parent_folder_id\x18\v \x01(\x04R\x0eparentFolderId\x12\x1b\n" +
	"\tpath_tree\x18\f \x01(\tR\bpathTree\x129\n" +
	"\vpermissions\x18\x14 \x03(\v2\x17.Scailo.VaultPermissionR\vpermissions\x12@\n" +
	"\x0eparent_folders\x18\x1e \x03(\v2\x19.Scailo.VaultParentFolderR\rparentFolders\x12,\n" +
	"\x12parent_folder_uuid\x182 \x01(\tR\x10parentFolderUuid\";\n" +
	"\x10VaultFoldersList\x12'\n" +
	"\x04list\x18\x01 \x03(\v2\x13.Scailo.VaultFolderR\x04list\"\x84\x03\n" +
	"\x13VaultFolderDownload\x12\x1f\n" +
	"\ventity_uuid\x18\x01 \x01(\tR\n" +
	"entityUuid\x124\n" +
	"\bmetadata\x18\x02 \x01(\v2\x18.Scailo.EmployeeMetadataR\bmetadata\x12\x1b\n" +
	"\tfolder_id\x18\n" +
	" \x01(\x04R\bfolderId\x12\"\n" +
	"\rzip_file_path\x18\v \x01(\tR\vzipFilePath\x12\x1b\n" +
	"\tis_zipped\x18\f \x01(\bR\bisZipped\x12!\n" +
	"\frequested_by\x18\r \x01(\tR\vrequestedBy\x12.\n" +
	"\x13download_started_at\x18\x0e \x01(\x04R\x11downloadStartedAt\x12*\n" +
	"\x11download_ended_at\x18\x0f \x01(\x04R\x0fdownloadEndedAt\x12#\n" +
	"\rdownloaded_by\x18\x10 \x01(\tR\fdownloadedBy\x12\x14\n" +
	"\x05error\x18\x11 \x01(\tR\x05errorBi\n" +
	"\n" +
	"com.ScailoB\x17VaultFoldersScailoProtoP\x01Z\n" +
	"Scailo/sdk\xa2\x02\x03SXX\xaa\x02\x06Scailo\xca\x02\x06Scailo\xe2\x02\x12Scailo\\GPBMetadata\xea\x02\x06Scailob\x06proto3"

var (
	file_vault_folders_scailo_proto_rawDescOnce sync.Once
	file_vault_folders_scailo_proto_rawDescData []byte
)

func file_vault_folders_scailo_proto_rawDescGZIP() []byte {
	file_vault_folders_scailo_proto_rawDescOnce.Do(func() {
		file_vault_folders_scailo_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_vault_folders_scailo_proto_rawDesc), len(file_vault_folders_scailo_proto_rawDesc)))
	})
	return file_vault_folders_scailo_proto_rawDescData
}

var file_vault_folders_scailo_proto_msgTypes = make([]protoimpl.MessageInfo, 7)
var file_vault_folders_scailo_proto_goTypes = []any{
	(*VaultFolderAddRequest)(nil),          // 0: Scailo.VaultFolderAddRequest
	(*VaultFolderMoveFolderRequest)(nil),   // 1: Scailo.VaultFolderMoveFolderRequest
	(*VaultFolderRenameFolderRequest)(nil), // 2: Scailo.VaultFolderRenameFolderRequest
	(*VaultParentFolder)(nil),              // 3: Scailo.VaultParentFolder
	(*VaultFolder)(nil),                    // 4: Scailo.VaultFolder
	(*VaultFoldersList)(nil),               // 5: Scailo.VaultFoldersList
	(*VaultFolderDownload)(nil),            // 6: Scailo.VaultFolderDownload
	(*EmployeeMetadata)(nil),               // 7: Scailo.EmployeeMetadata
	(*VaultPermission)(nil),                // 8: Scailo.VaultPermission
}
var file_vault_folders_scailo_proto_depIdxs = []int32{
	7, // 0: Scailo.VaultParentFolder.metadata:type_name -> Scailo.EmployeeMetadata
	8, // 1: Scailo.VaultParentFolder.permissions:type_name -> Scailo.VaultPermission
	7, // 2: Scailo.VaultFolder.metadata:type_name -> Scailo.EmployeeMetadata
	8, // 3: Scailo.VaultFolder.permissions:type_name -> Scailo.VaultPermission
	3, // 4: Scailo.VaultFolder.parent_folders:type_name -> Scailo.VaultParentFolder
	4, // 5: Scailo.VaultFoldersList.list:type_name -> Scailo.VaultFolder
	7, // 6: Scailo.VaultFolderDownload.metadata:type_name -> Scailo.EmployeeMetadata
	7, // [7:7] is the sub-list for method output_type
	7, // [7:7] is the sub-list for method input_type
	7, // [7:7] is the sub-list for extension type_name
	7, // [7:7] is the sub-list for extension extendee
	0, // [0:7] is the sub-list for field type_name
}

func init() { file_vault_folders_scailo_proto_init() }
func file_vault_folders_scailo_proto_init() {
	if File_vault_folders_scailo_proto != nil {
		return
	}
	file_base_scailo_proto_init()
	file_vault_commons_scailo_proto_init()
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_vault_folders_scailo_proto_rawDesc), len(file_vault_folders_scailo_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   7,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_vault_folders_scailo_proto_goTypes,
		DependencyIndexes: file_vault_folders_scailo_proto_depIdxs,
		MessageInfos:      file_vault_folders_scailo_proto_msgTypes,
	}.Build()
	File_vault_folders_scailo_proto = out.File
	file_vault_folders_scailo_proto_goTypes = nil
	file_vault_folders_scailo_proto_depIdxs = nil
}
