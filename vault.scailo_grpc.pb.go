// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             (unknown)
// source: vault.scailo.proto

package sdk

import (
	context "context"

	grpc "google.golang.org/grpc"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	VaultService_InitiateFile_FullMethodName                       = "/Scailo.VaultService/InitiateFile"
	VaultService_AddFileChunk_FullMethodName                       = "/Scailo.VaultService/AddFileChunk"
	VaultService_CompleteFile_FullMethodName                       = "/Scailo.VaultService/CompleteFile"
	VaultService_RenameFile_FullMethodName                         = "/Scailo.VaultService/RenameFile"
	VaultService_UnzipFile_FullMethodName                          = "/Scailo.VaultService/UnzipFile"
	VaultService_PersistFile_FullMethodName                        = "/Scailo.VaultService/PersistFile"
	VaultService_MoveFile_FullMethodName                           = "/Scailo.VaultService/MoveFile"
	VaultService_DeleteFile_FullMethodName                         = "/Scailo.VaultService/DeleteFile"
	VaultService_AddFilePermission_FullMethodName                  = "/Scailo.VaultService/AddFilePermission"
	VaultService_ModifyFilePermission_FullMethodName               = "/Scailo.VaultService/ModifyFilePermission"
	VaultService_DeleteFilePermission_FullMethodName               = "/Scailo.VaultService/DeleteFilePermission"
	VaultService_DownloadFile_FullMethodName                       = "/Scailo.VaultService/DownloadFile"
	VaultService_DownloadFileVersion_FullMethodName                = "/Scailo.VaultService/DownloadFileVersion"
	VaultService_ViewFileLogo_FullMethodName                       = "/Scailo.VaultService/ViewFileLogo"
	VaultService_ViewFileByUUID_FullMethodName                     = "/Scailo.VaultService/ViewFileByUUID"
	VaultService_ViewFileByID_FullMethodName                       = "/Scailo.VaultService/ViewFileByID"
	VaultService_ViewFileChunk_FullMethodName                      = "/Scailo.VaultService/ViewFileChunk"
	VaultService_ViewFileChunkMetadata_FullMethodName              = "/Scailo.VaultService/ViewFileChunkMetadata"
	VaultService_ViewFilePermission_FullMethodName                 = "/Scailo.VaultService/ViewFilePermission"
	VaultService_DoesFileExist_FullMethodName                      = "/Scailo.VaultService/DoesFileExist"
	VaultService_ViewFileVersions_FullMethodName                   = "/Scailo.VaultService/ViewFileVersions"
	VaultService_ViewFileAccessLogs_FullMethodName                 = "/Scailo.VaultService/ViewFileAccessLogs"
	VaultService_AddFolder_FullMethodName                          = "/Scailo.VaultService/AddFolder"
	VaultService_MoveFolder_FullMethodName                         = "/Scailo.VaultService/MoveFolder"
	VaultService_RenameFolder_FullMethodName                       = "/Scailo.VaultService/RenameFolder"
	VaultService_DeleteFolder_FullMethodName                       = "/Scailo.VaultService/DeleteFolder"
	VaultService_ZipFolder_FullMethodName                          = "/Scailo.VaultService/ZipFolder"
	VaultService_AddFolderPermission_FullMethodName                = "/Scailo.VaultService/AddFolderPermission"
	VaultService_ModifyFolderPermission_FullMethodName             = "/Scailo.VaultService/ModifyFolderPermission"
	VaultService_DeleteFolderPermission_FullMethodName             = "/Scailo.VaultService/DeleteFolderPermission"
	VaultService_ViewFolderByID_FullMethodName                     = "/Scailo.VaultService/ViewFolderByID"
	VaultService_ViewFolderByUUID_FullMethodName                   = "/Scailo.VaultService/ViewFolderByUUID"
	VaultService_ViewFolderDownloadStatus_FullMethodName           = "/Scailo.VaultService/ViewFolderDownloadStatus"
	VaultService_DownloadFolder_FullMethodName                     = "/Scailo.VaultService/DownloadFolder"
	VaultService_ViewAccessibleFilesInFolder_FullMethodName        = "/Scailo.VaultService/ViewAccessibleFilesInFolder"
	VaultService_ViewAccessibleFoldersInFolder_FullMethodName      = "/Scailo.VaultService/ViewAccessibleFoldersInFolder"
	VaultService_ViewAccessibleResourcesInFolder_FullMethodName    = "/Scailo.VaultService/ViewAccessibleResourcesInFolder"
	VaultService_ViewFolderPermission_FullMethodName               = "/Scailo.VaultService/ViewFolderPermission"
	VaultService_DoesFolderExist_FullMethodName                    = "/Scailo.VaultService/DoesFolderExist"
	VaultService_ViewFolderAccessLogs_FullMethodName               = "/Scailo.VaultService/ViewFolderAccessLogs"
	VaultService_ViewPassthroughRolesForFolder_FullMethodName      = "/Scailo.VaultService/ViewPassthroughRolesForFolder"
	VaultService_Search_FullMethodName                             = "/Scailo.VaultService/Search"
	VaultService_SetupGiX_FullMethodName                           = "/Scailo.VaultService/SetupGiX"
	VaultService_GiXRelayDELETE_FullMethodName                     = "/Scailo.VaultService/GiXRelayDELETE"
	VaultService_GiXRelayGET_FullMethodName                        = "/Scailo.VaultService/GiXRelayGET"
	VaultService_GiXRelayHEAD_FullMethodName                       = "/Scailo.VaultService/GiXRelayHEAD"
	VaultService_GiXRelayPATCH_FullMethodName                      = "/Scailo.VaultService/GiXRelayPATCH"
	VaultService_GiXRelayPOST_FullMethodName                       = "/Scailo.VaultService/GiXRelayPOST"
	VaultService_GiXRelayPUT_FullMethodName                        = "/Scailo.VaultService/GiXRelayPUT"
	VaultService_GiXFilter_FullMethodName                          = "/Scailo.VaultService/GiXFilter"
	VaultService_GiXCount_FullMethodName                           = "/Scailo.VaultService/GiXCount"
	VaultService_ReconfigureEnclave_FullMethodName                 = "/Scailo.VaultService/ReconfigureEnclave"
	VaultService_SetupEnclaveIngress_FullMethodName                = "/Scailo.VaultService/SetupEnclaveIngress"
	VaultService_FilterEnclaveIngresses_FullMethodName             = "/Scailo.VaultService/FilterEnclaveIngresses"
	VaultService_CountEnclaveIngresses_FullMethodName              = "/Scailo.VaultService/CountEnclaveIngresses"
	VaultService_VerifyEnclaveIngress_FullMethodName               = "/Scailo.VaultService/VerifyEnclaveIngress"
	VaultService_AddEnclaveEnvironmentVariable_FullMethodName      = "/Scailo.VaultService/AddEnclaveEnvironmentVariable"
	VaultService_UpdateEnclaveEnvironmentVariable_FullMethodName   = "/Scailo.VaultService/UpdateEnclaveEnvironmentVariable"
	VaultService_DeleteEnclaveEnvironmentVariable_FullMethodName   = "/Scailo.VaultService/DeleteEnclaveEnvironmentVariable"
	VaultService_ViewEnclaveEnvironmentVariable_FullMethodName     = "/Scailo.VaultService/ViewEnclaveEnvironmentVariable"
	VaultService_ViewAllEnclaveEnvironmentVariables_FullMethodName = "/Scailo.VaultService/ViewAllEnclaveEnvironmentVariables"
	VaultService_AddEnclaveDomain_FullMethodName                   = "/Scailo.VaultService/AddEnclaveDomain"
	VaultService_DeleteEnclaveDomain_FullMethodName                = "/Scailo.VaultService/DeleteEnclaveDomain"
	VaultService_ViewEnclaveDomain_FullMethodName                  = "/Scailo.VaultService/ViewEnclaveDomain"
	VaultService_ViewAllEnclaveDomains_FullMethodName              = "/Scailo.VaultService/ViewAllEnclaveDomains"
	VaultService_ViewDomainSuffix_FullMethodName                   = "/Scailo.VaultService/ViewDomainSuffix"
	VaultService_FilterEnclaveDomains_FullMethodName               = "/Scailo.VaultService/FilterEnclaveDomains"
	VaultService_AddEnclaveFrame_FullMethodName                    = "/Scailo.VaultService/AddEnclaveFrame"
	VaultService_ViewEnclaveFrame_FullMethodName                   = "/Scailo.VaultService/ViewEnclaveFrame"
	VaultService_UpdateEnclaveFrame_FullMethodName                 = "/Scailo.VaultService/UpdateEnclaveFrame"
	VaultService_DeleteEnclaveFrame_FullMethodName                 = "/Scailo.VaultService/DeleteEnclaveFrame"
	VaultService_SetupEnclaveFrame_FullMethodName                  = "/Scailo.VaultService/SetupEnclaveFrame"
	VaultService_SetupAllEnclaveFrames_FullMethodName              = "/Scailo.VaultService/SetupAllEnclaveFrames"
)

// VaultServiceClient is the client API for VaultService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Describes the available services in Vault
type VaultServiceClient interface {
	// Initiate file upload
	InitiateFile(ctx context.Context, in *VaultFileInitiateFileRequest, opts ...grpc.CallOption) (*VaultFileInitiateFileResponse, error)
	// Add chunk to a file version and returns the UUID of the added chunk
	AddFileChunk(ctx context.Context, in *VaultFileAddChunkRequest, opts ...grpc.CallOption) (*IdentifierUUID, error)
	// Complete file upload
	CompleteFile(ctx context.Context, in *IdentifierUUID, opts ...grpc.CallOption) (*IdentifierUUID, error)
	// Rename file
	RenameFile(ctx context.Context, in *VaultFileRenameFileRequest, opts ...grpc.CallOption) (*IdentifierUUID, error)
	// Unzip file
	UnzipFile(ctx context.Context, in *VaultFileUnzipRequest, opts ...grpc.CallOption) (*IdentifierUUID, error)
	// Persist file
	PersistFile(ctx context.Context, in *IdentifierUUID, opts ...grpc.CallOption) (*IdentifierUUID, error)
	// Move file
	MoveFile(ctx context.Context, in *VaultFileMoveFileRequest, opts ...grpc.CallOption) (*IdentifierUUID, error)
	// Delete file
	DeleteFile(ctx context.Context, in *IdentifierUUID, opts ...grpc.CallOption) (*IdentifierUUID, error)
	// Permission APIs
	// Add permission and returns the UUID of the added permission
	AddFilePermission(ctx context.Context, in *VaultPermissionAddRequest, opts ...grpc.CallOption) (*IdentifierUUID, error)
	// Modify permission and returns the UUID of the added permission
	ModifyFilePermission(ctx context.Context, in *VaultPermissionModifyRequest, opts ...grpc.CallOption) (*IdentifierUUID, error)
	// Delete permission (returns the UUID of the file)
	DeleteFilePermission(ctx context.Context, in *IdentifierUUID, opts ...grpc.CallOption) (*IdentifierUUID, error)
	// Downloads
	// Download file with the given UUID
	DownloadFile(ctx context.Context, in *IdentifierUUID, opts ...grpc.CallOption) (*StandardFile, error)
	// Download file version with the given UUID
	DownloadFileVersion(ctx context.Context, in *IdentifierUUID, opts ...grpc.CallOption) (*StandardFile, error)
	// View logo
	ViewFileLogo(ctx context.Context, in *IdentifierUUID, opts ...grpc.CallOption) (*StandardFile, error)
	// View file by UUID
	ViewFileByUUID(ctx context.Context, in *IdentifierUUID, opts ...grpc.CallOption) (*VaultFile, error)
	// View file by ID
	ViewFileByID(ctx context.Context, in *Identifier, opts ...grpc.CallOption) (*VaultFile, error)
	// View chunk with the given UUID
	ViewFileChunk(ctx context.Context, in *IdentifierUUID, opts ...grpc.CallOption) (*VaultFileVersionChunk, error)
	// View chunk metadata
	ViewFileChunkMetadata(ctx context.Context, in *IdentifierUUID, opts ...grpc.CallOption) (*VaultFileVersionChunk, error)
	// View permission for file
	ViewFilePermission(ctx context.Context, in *IdentifierUUID, opts ...grpc.CallOption) (*VaultPermission, error)
	// Check if file already exists
	DoesFileExist(ctx context.Context, in *VaultDuplicateCheckReq, opts ...grpc.CallOption) (*BooleanResponse, error)
	// View all versions of file
	ViewFileVersions(ctx context.Context, in *IdentifierUUID, opts ...grpc.CallOption) (*VaultFileVersionsList, error)
	// View access logs of file
	ViewFileAccessLogs(ctx context.Context, in *IdentifierUUID, opts ...grpc.CallOption) (*VaultAccessLogsList, error)
	// Add folder
	AddFolder(ctx context.Context, in *VaultFolderAddRequest, opts ...grpc.CallOption) (*IdentifierUUID, error)
	// Move folder
	MoveFolder(ctx context.Context, in *VaultFolderMoveFolderRequest, opts ...grpc.CallOption) (*IdentifierUUID, error)
	// Rename folder
	RenameFolder(ctx context.Context, in *VaultFolderRenameFolderRequest, opts ...grpc.CallOption) (*IdentifierUUID, error)
	// Delete folder
	DeleteFolder(ctx context.Context, in *IdentifierUUID, opts ...grpc.CallOption) (*IdentifierUUID, error)
	// Zip folder and returns the UUID of the vault folder download
	ZipFolder(ctx context.Context, in *IdentifierUUID, opts ...grpc.CallOption) (*IdentifierUUID, error)
	// Permission APIs
	// Add permission and returns the UUID of the added permission
	AddFolderPermission(ctx context.Context, in *VaultPermissionAddRequest, opts ...grpc.CallOption) (*IdentifierUUID, error)
	// Modify permission and returns the UUID of the modified permission
	ModifyFolderPermission(ctx context.Context, in *VaultPermissionModifyRequest, opts ...grpc.CallOption) (*IdentifierUUID, error)
	// Delete permission (returns the UUID of the folder)
	DeleteFolderPermission(ctx context.Context, in *IdentifierUUID, opts ...grpc.CallOption) (*IdentifierUUID, error)
	// View folder by ID
	ViewFolderByID(ctx context.Context, in *IdentifierZeroable, opts ...grpc.CallOption) (*VaultFolder, error)
	// View folder by UUID
	ViewFolderByUUID(ctx context.Context, in *IdentifierUUID, opts ...grpc.CallOption) (*VaultFolder, error)
	// View the status of the folder download
	ViewFolderDownloadStatus(ctx context.Context, in *IdentifierUUID, opts ...grpc.CallOption) (*VaultFolderDownload, error)
	// Download the vault folder
	DownloadFolder(ctx context.Context, in *IdentifierUUID, opts ...grpc.CallOption) (*StandardFile, error)
	// View all files accessible by self in the given folder
	ViewAccessibleFilesInFolder(ctx context.Context, in *IdentifierUUID, opts ...grpc.CallOption) (*VaultFilesList, error)
	// View all folders accessible by self in the given folder
	ViewAccessibleFoldersInFolder(ctx context.Context, in *IdentifierUUID, opts ...grpc.CallOption) (*VaultFoldersList, error)
	// View all the resources accessible by self in the given folder
	ViewAccessibleResourcesInFolder(ctx context.Context, in *IdentifierUUID, opts ...grpc.CallOption) (*VaultResourcesList, error)
	// View permission for folder
	ViewFolderPermission(ctx context.Context, in *IdentifierUUID, opts ...grpc.CallOption) (*VaultPermission, error)
	// Check if folder already exists
	DoesFolderExist(ctx context.Context, in *VaultDuplicateCheckReq, opts ...grpc.CallOption) (*BooleanResponse, error)
	// View access logs of folder
	ViewFolderAccessLogs(ctx context.Context, in *IdentifierUUID, opts ...grpc.CallOption) (*VaultAccessLogsList, error)
	// View passthrough roles for folder
	ViewPassthroughRolesForFolder(ctx context.Context, in *IdentifierUUID, opts ...grpc.CallOption) (*RolesList, error)
	// Search for files and folders
	Search(ctx context.Context, in *VaultSearchReq, opts ...grpc.CallOption) (*VaultSearchResponsesList, error)
	// Setup GiX app
	SetupGiX(ctx context.Context, in *IdentifierUUID, opts ...grpc.CallOption) (*GiXAppRun, error)
	// Relay a DELETE API
	GiXRelayDELETE(ctx context.Context, in *GiXRelayReqWithoutBody, opts ...grpc.CallOption) (*GiXRelayResponse, error)
	// Relay a GET API
	GiXRelayGET(ctx context.Context, in *GiXRelayReqWithoutBody, opts ...grpc.CallOption) (*GiXRelayResponse, error)
	// Relay a HEAD API
	GiXRelayHEAD(ctx context.Context, in *GiXRelayReqWithoutBody, opts ...grpc.CallOption) (*GiXRelayResponse, error)
	// Relay a PATCH API
	GiXRelayPATCH(ctx context.Context, in *GiXRelayReqWithBody, opts ...grpc.CallOption) (*GiXRelayResponse, error)
	// Relay a POST API
	GiXRelayPOST(ctx context.Context, in *GiXRelayReqWithBody, opts ...grpc.CallOption) (*GiXRelayResponse, error)
	// Relay a PUT API
	GiXRelayPUT(ctx context.Context, in *GiXRelayReqWithBody, opts ...grpc.CallOption) (*GiXRelayResponse, error)
	// View all runs that match the given filter criteria
	GiXFilter(ctx context.Context, in *GiXAppRunFilterReq, opts ...grpc.CallOption) (*GiXAppRunsList, error)
	// Count all runs that match the given filter criteria
	GiXCount(ctx context.Context, in *GiXAppRunCountReq, opts ...grpc.CallOption) (*CountResponse, error)
	// Reconfigures the enclave (redeploys the enclave)
	ReconfigureEnclave(ctx context.Context, in *IdentifierUUID, opts ...grpc.CallOption) (*IdentifierUUID, error)
	// Setup Enclave Ingress
	SetupEnclaveIngress(ctx context.Context, in *IdentifierUUID, opts ...grpc.CallOption) (*EnclaveIngress, error)
	// View all enclave ingresses that match the given filter criteria
	FilterEnclaveIngresses(ctx context.Context, in *EnclaveIngressFilterReq, opts ...grpc.CallOption) (*EnclaveIngressesList, error)
	// Count all enclave ingresses that match the given filter criteria
	CountEnclaveIngresses(ctx context.Context, in *EnclaveIngressCountReq, opts ...grpc.CallOption) (*CountResponse, error)
	// Verifies the enclave ingress and returns the necessary information for subsequent requests
	VerifyEnclaveIngress(ctx context.Context, in *VerifyEnclaveIngressRequest, opts ...grpc.CallOption) (*VerifyEnclaveIngressResponse, error)
	// Add environment variable to enclave
	AddEnclaveEnvironmentVariable(ctx context.Context, in *EnclaveEnvironmentVariableAddRequest, opts ...grpc.CallOption) (*EnclaveEnvironmentVariable, error)
	// Update environment variable in enclave
	UpdateEnclaveEnvironmentVariable(ctx context.Context, in *EnclaveEnvironmentVariableUpdateRequest, opts ...grpc.CallOption) (*EnclaveEnvironmentVariable, error)
	// Delete environment variable in enclave
	DeleteEnclaveEnvironmentVariable(ctx context.Context, in *IdentifierUUID, opts ...grpc.CallOption) (*IdentifierResponse, error)
	// View environment variable in enclave represented by the Identifier
	ViewEnclaveEnvironmentVariable(ctx context.Context, in *IdentifierUUID, opts ...grpc.CallOption) (*EnclaveEnvironmentVariable, error)
	// View all environment variables in enclave for the enclave represented by the Identifier
	ViewAllEnclaveEnvironmentVariables(ctx context.Context, in *IdentifierUUID, opts ...grpc.CallOption) (*EnclaveEnvironmentVariablesList, error)
	// Add domain to enclave
	AddEnclaveDomain(ctx context.Context, in *EnclaveDomainAddRequest, opts ...grpc.CallOption) (*EnclaveDomain, error)
	// Delete domain from enclave
	DeleteEnclaveDomain(ctx context.Context, in *IdentifierUUID, opts ...grpc.CallOption) (*IdentifierResponse, error)
	// View domain for enclave represented by the Identifier
	ViewEnclaveDomain(ctx context.Context, in *IdentifierUUID, opts ...grpc.CallOption) (*EnclaveDomain, error)
	// View all domains for enclave for the enclave represented by the Identifier
	ViewAllEnclaveDomains(ctx context.Context, in *IdentifierUUID, opts ...grpc.CallOption) (*EnclaveDomainsList, error)
	// Retrieve the default domain suffix that could be used for creating a new domain
	ViewDomainSuffix(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*EnclaveDomainSuffixResp, error)
	// Filter all domains that match the given filter criteria
	FilterEnclaveDomains(ctx context.Context, in *EnclaveDomainsFilterReq, opts ...grpc.CallOption) (*EnclaveDomainsList, error)
	// Adds an enclave as a dashboard frame. The file needs to be an enclave. Returns an error otherwise
	AddEnclaveFrame(ctx context.Context, in *EnclaveFrameAddRequest, opts ...grpc.CallOption) (*EnclaveFrame, error)
	// View the properties of a frame
	ViewEnclaveFrame(ctx context.Context, in *IdentifierUUID, opts ...grpc.CallOption) (*EnclaveFrame, error)
	// Update the properties of a frame
	UpdateEnclaveFrame(ctx context.Context, in *EnclaveFrameUpdateRequest, opts ...grpc.CallOption) (*EnclaveFrame, error)
	// Delete the dashboard frame
	DeleteEnclaveFrame(ctx context.Context, in *IdentifierUUID, opts ...grpc.CallOption) (*IdentifierResponse, error)
	// Returns the endpoint that could be used to render a frame
	SetupEnclaveFrame(ctx context.Context, in *IdentifierUUID, opts ...grpc.CallOption) (*EnclaveFrameSetup, error)
	// Returns all the endpoints that could be used to render frames for the identified user. This can be primary used to render all the frames on a user's dashboard, for example.
	SetupAllEnclaveFrames(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*EnclaveFrameSetupList, error)
}

type vaultServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewVaultServiceClient(cc grpc.ClientConnInterface) VaultServiceClient {
	return &vaultServiceClient{cc}
}

func (c *vaultServiceClient) InitiateFile(ctx context.Context, in *VaultFileInitiateFileRequest, opts ...grpc.CallOption) (*VaultFileInitiateFileResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VaultFileInitiateFileResponse)
	err := c.cc.Invoke(ctx, VaultService_InitiateFile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vaultServiceClient) AddFileChunk(ctx context.Context, in *VaultFileAddChunkRequest, opts ...grpc.CallOption) (*IdentifierUUID, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IdentifierUUID)
	err := c.cc.Invoke(ctx, VaultService_AddFileChunk_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vaultServiceClient) CompleteFile(ctx context.Context, in *IdentifierUUID, opts ...grpc.CallOption) (*IdentifierUUID, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IdentifierUUID)
	err := c.cc.Invoke(ctx, VaultService_CompleteFile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vaultServiceClient) RenameFile(ctx context.Context, in *VaultFileRenameFileRequest, opts ...grpc.CallOption) (*IdentifierUUID, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IdentifierUUID)
	err := c.cc.Invoke(ctx, VaultService_RenameFile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vaultServiceClient) UnzipFile(ctx context.Context, in *VaultFileUnzipRequest, opts ...grpc.CallOption) (*IdentifierUUID, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IdentifierUUID)
	err := c.cc.Invoke(ctx, VaultService_UnzipFile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vaultServiceClient) PersistFile(ctx context.Context, in *IdentifierUUID, opts ...grpc.CallOption) (*IdentifierUUID, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IdentifierUUID)
	err := c.cc.Invoke(ctx, VaultService_PersistFile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vaultServiceClient) MoveFile(ctx context.Context, in *VaultFileMoveFileRequest, opts ...grpc.CallOption) (*IdentifierUUID, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IdentifierUUID)
	err := c.cc.Invoke(ctx, VaultService_MoveFile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vaultServiceClient) DeleteFile(ctx context.Context, in *IdentifierUUID, opts ...grpc.CallOption) (*IdentifierUUID, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IdentifierUUID)
	err := c.cc.Invoke(ctx, VaultService_DeleteFile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vaultServiceClient) AddFilePermission(ctx context.Context, in *VaultPermissionAddRequest, opts ...grpc.CallOption) (*IdentifierUUID, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IdentifierUUID)
	err := c.cc.Invoke(ctx, VaultService_AddFilePermission_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vaultServiceClient) ModifyFilePermission(ctx context.Context, in *VaultPermissionModifyRequest, opts ...grpc.CallOption) (*IdentifierUUID, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IdentifierUUID)
	err := c.cc.Invoke(ctx, VaultService_ModifyFilePermission_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vaultServiceClient) DeleteFilePermission(ctx context.Context, in *IdentifierUUID, opts ...grpc.CallOption) (*IdentifierUUID, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IdentifierUUID)
	err := c.cc.Invoke(ctx, VaultService_DeleteFilePermission_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vaultServiceClient) DownloadFile(ctx context.Context, in *IdentifierUUID, opts ...grpc.CallOption) (*StandardFile, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StandardFile)
	err := c.cc.Invoke(ctx, VaultService_DownloadFile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vaultServiceClient) DownloadFileVersion(ctx context.Context, in *IdentifierUUID, opts ...grpc.CallOption) (*StandardFile, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StandardFile)
	err := c.cc.Invoke(ctx, VaultService_DownloadFileVersion_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vaultServiceClient) ViewFileLogo(ctx context.Context, in *IdentifierUUID, opts ...grpc.CallOption) (*StandardFile, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StandardFile)
	err := c.cc.Invoke(ctx, VaultService_ViewFileLogo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vaultServiceClient) ViewFileByUUID(ctx context.Context, in *IdentifierUUID, opts ...grpc.CallOption) (*VaultFile, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VaultFile)
	err := c.cc.Invoke(ctx, VaultService_ViewFileByUUID_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vaultServiceClient) ViewFileByID(ctx context.Context, in *Identifier, opts ...grpc.CallOption) (*VaultFile, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VaultFile)
	err := c.cc.Invoke(ctx, VaultService_ViewFileByID_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vaultServiceClient) ViewFileChunk(ctx context.Context, in *IdentifierUUID, opts ...grpc.CallOption) (*VaultFileVersionChunk, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VaultFileVersionChunk)
	err := c.cc.Invoke(ctx, VaultService_ViewFileChunk_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vaultServiceClient) ViewFileChunkMetadata(ctx context.Context, in *IdentifierUUID, opts ...grpc.CallOption) (*VaultFileVersionChunk, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VaultFileVersionChunk)
	err := c.cc.Invoke(ctx, VaultService_ViewFileChunkMetadata_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vaultServiceClient) ViewFilePermission(ctx context.Context, in *IdentifierUUID, opts ...grpc.CallOption) (*VaultPermission, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VaultPermission)
	err := c.cc.Invoke(ctx, VaultService_ViewFilePermission_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vaultServiceClient) DoesFileExist(ctx context.Context, in *VaultDuplicateCheckReq, opts ...grpc.CallOption) (*BooleanResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BooleanResponse)
	err := c.cc.Invoke(ctx, VaultService_DoesFileExist_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vaultServiceClient) ViewFileVersions(ctx context.Context, in *IdentifierUUID, opts ...grpc.CallOption) (*VaultFileVersionsList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VaultFileVersionsList)
	err := c.cc.Invoke(ctx, VaultService_ViewFileVersions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vaultServiceClient) ViewFileAccessLogs(ctx context.Context, in *IdentifierUUID, opts ...grpc.CallOption) (*VaultAccessLogsList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VaultAccessLogsList)
	err := c.cc.Invoke(ctx, VaultService_ViewFileAccessLogs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vaultServiceClient) AddFolder(ctx context.Context, in *VaultFolderAddRequest, opts ...grpc.CallOption) (*IdentifierUUID, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IdentifierUUID)
	err := c.cc.Invoke(ctx, VaultService_AddFolder_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vaultServiceClient) MoveFolder(ctx context.Context, in *VaultFolderMoveFolderRequest, opts ...grpc.CallOption) (*IdentifierUUID, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IdentifierUUID)
	err := c.cc.Invoke(ctx, VaultService_MoveFolder_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vaultServiceClient) RenameFolder(ctx context.Context, in *VaultFolderRenameFolderRequest, opts ...grpc.CallOption) (*IdentifierUUID, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IdentifierUUID)
	err := c.cc.Invoke(ctx, VaultService_RenameFolder_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vaultServiceClient) DeleteFolder(ctx context.Context, in *IdentifierUUID, opts ...grpc.CallOption) (*IdentifierUUID, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IdentifierUUID)
	err := c.cc.Invoke(ctx, VaultService_DeleteFolder_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vaultServiceClient) ZipFolder(ctx context.Context, in *IdentifierUUID, opts ...grpc.CallOption) (*IdentifierUUID, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IdentifierUUID)
	err := c.cc.Invoke(ctx, VaultService_ZipFolder_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vaultServiceClient) AddFolderPermission(ctx context.Context, in *VaultPermissionAddRequest, opts ...grpc.CallOption) (*IdentifierUUID, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IdentifierUUID)
	err := c.cc.Invoke(ctx, VaultService_AddFolderPermission_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vaultServiceClient) ModifyFolderPermission(ctx context.Context, in *VaultPermissionModifyRequest, opts ...grpc.CallOption) (*IdentifierUUID, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IdentifierUUID)
	err := c.cc.Invoke(ctx, VaultService_ModifyFolderPermission_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vaultServiceClient) DeleteFolderPermission(ctx context.Context, in *IdentifierUUID, opts ...grpc.CallOption) (*IdentifierUUID, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IdentifierUUID)
	err := c.cc.Invoke(ctx, VaultService_DeleteFolderPermission_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vaultServiceClient) ViewFolderByID(ctx context.Context, in *IdentifierZeroable, opts ...grpc.CallOption) (*VaultFolder, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VaultFolder)
	err := c.cc.Invoke(ctx, VaultService_ViewFolderByID_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vaultServiceClient) ViewFolderByUUID(ctx context.Context, in *IdentifierUUID, opts ...grpc.CallOption) (*VaultFolder, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VaultFolder)
	err := c.cc.Invoke(ctx, VaultService_ViewFolderByUUID_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vaultServiceClient) ViewFolderDownloadStatus(ctx context.Context, in *IdentifierUUID, opts ...grpc.CallOption) (*VaultFolderDownload, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VaultFolderDownload)
	err := c.cc.Invoke(ctx, VaultService_ViewFolderDownloadStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vaultServiceClient) DownloadFolder(ctx context.Context, in *IdentifierUUID, opts ...grpc.CallOption) (*StandardFile, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StandardFile)
	err := c.cc.Invoke(ctx, VaultService_DownloadFolder_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vaultServiceClient) ViewAccessibleFilesInFolder(ctx context.Context, in *IdentifierUUID, opts ...grpc.CallOption) (*VaultFilesList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VaultFilesList)
	err := c.cc.Invoke(ctx, VaultService_ViewAccessibleFilesInFolder_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vaultServiceClient) ViewAccessibleFoldersInFolder(ctx context.Context, in *IdentifierUUID, opts ...grpc.CallOption) (*VaultFoldersList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VaultFoldersList)
	err := c.cc.Invoke(ctx, VaultService_ViewAccessibleFoldersInFolder_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vaultServiceClient) ViewAccessibleResourcesInFolder(ctx context.Context, in *IdentifierUUID, opts ...grpc.CallOption) (*VaultResourcesList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VaultResourcesList)
	err := c.cc.Invoke(ctx, VaultService_ViewAccessibleResourcesInFolder_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vaultServiceClient) ViewFolderPermission(ctx context.Context, in *IdentifierUUID, opts ...grpc.CallOption) (*VaultPermission, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VaultPermission)
	err := c.cc.Invoke(ctx, VaultService_ViewFolderPermission_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vaultServiceClient) DoesFolderExist(ctx context.Context, in *VaultDuplicateCheckReq, opts ...grpc.CallOption) (*BooleanResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BooleanResponse)
	err := c.cc.Invoke(ctx, VaultService_DoesFolderExist_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vaultServiceClient) ViewFolderAccessLogs(ctx context.Context, in *IdentifierUUID, opts ...grpc.CallOption) (*VaultAccessLogsList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VaultAccessLogsList)
	err := c.cc.Invoke(ctx, VaultService_ViewFolderAccessLogs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vaultServiceClient) ViewPassthroughRolesForFolder(ctx context.Context, in *IdentifierUUID, opts ...grpc.CallOption) (*RolesList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RolesList)
	err := c.cc.Invoke(ctx, VaultService_ViewPassthroughRolesForFolder_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vaultServiceClient) Search(ctx context.Context, in *VaultSearchReq, opts ...grpc.CallOption) (*VaultSearchResponsesList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VaultSearchResponsesList)
	err := c.cc.Invoke(ctx, VaultService_Search_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vaultServiceClient) SetupGiX(ctx context.Context, in *IdentifierUUID, opts ...grpc.CallOption) (*GiXAppRun, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GiXAppRun)
	err := c.cc.Invoke(ctx, VaultService_SetupGiX_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vaultServiceClient) GiXRelayDELETE(ctx context.Context, in *GiXRelayReqWithoutBody, opts ...grpc.CallOption) (*GiXRelayResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GiXRelayResponse)
	err := c.cc.Invoke(ctx, VaultService_GiXRelayDELETE_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vaultServiceClient) GiXRelayGET(ctx context.Context, in *GiXRelayReqWithoutBody, opts ...grpc.CallOption) (*GiXRelayResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GiXRelayResponse)
	err := c.cc.Invoke(ctx, VaultService_GiXRelayGET_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vaultServiceClient) GiXRelayHEAD(ctx context.Context, in *GiXRelayReqWithoutBody, opts ...grpc.CallOption) (*GiXRelayResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GiXRelayResponse)
	err := c.cc.Invoke(ctx, VaultService_GiXRelayHEAD_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vaultServiceClient) GiXRelayPATCH(ctx context.Context, in *GiXRelayReqWithBody, opts ...grpc.CallOption) (*GiXRelayResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GiXRelayResponse)
	err := c.cc.Invoke(ctx, VaultService_GiXRelayPATCH_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vaultServiceClient) GiXRelayPOST(ctx context.Context, in *GiXRelayReqWithBody, opts ...grpc.CallOption) (*GiXRelayResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GiXRelayResponse)
	err := c.cc.Invoke(ctx, VaultService_GiXRelayPOST_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vaultServiceClient) GiXRelayPUT(ctx context.Context, in *GiXRelayReqWithBody, opts ...grpc.CallOption) (*GiXRelayResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GiXRelayResponse)
	err := c.cc.Invoke(ctx, VaultService_GiXRelayPUT_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vaultServiceClient) GiXFilter(ctx context.Context, in *GiXAppRunFilterReq, opts ...grpc.CallOption) (*GiXAppRunsList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GiXAppRunsList)
	err := c.cc.Invoke(ctx, VaultService_GiXFilter_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vaultServiceClient) GiXCount(ctx context.Context, in *GiXAppRunCountReq, opts ...grpc.CallOption) (*CountResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CountResponse)
	err := c.cc.Invoke(ctx, VaultService_GiXCount_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vaultServiceClient) ReconfigureEnclave(ctx context.Context, in *IdentifierUUID, opts ...grpc.CallOption) (*IdentifierUUID, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IdentifierUUID)
	err := c.cc.Invoke(ctx, VaultService_ReconfigureEnclave_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vaultServiceClient) SetupEnclaveIngress(ctx context.Context, in *IdentifierUUID, opts ...grpc.CallOption) (*EnclaveIngress, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EnclaveIngress)
	err := c.cc.Invoke(ctx, VaultService_SetupEnclaveIngress_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vaultServiceClient) FilterEnclaveIngresses(ctx context.Context, in *EnclaveIngressFilterReq, opts ...grpc.CallOption) (*EnclaveIngressesList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EnclaveIngressesList)
	err := c.cc.Invoke(ctx, VaultService_FilterEnclaveIngresses_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vaultServiceClient) CountEnclaveIngresses(ctx context.Context, in *EnclaveIngressCountReq, opts ...grpc.CallOption) (*CountResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CountResponse)
	err := c.cc.Invoke(ctx, VaultService_CountEnclaveIngresses_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vaultServiceClient) VerifyEnclaveIngress(ctx context.Context, in *VerifyEnclaveIngressRequest, opts ...grpc.CallOption) (*VerifyEnclaveIngressResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VerifyEnclaveIngressResponse)
	err := c.cc.Invoke(ctx, VaultService_VerifyEnclaveIngress_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vaultServiceClient) AddEnclaveEnvironmentVariable(ctx context.Context, in *EnclaveEnvironmentVariableAddRequest, opts ...grpc.CallOption) (*EnclaveEnvironmentVariable, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EnclaveEnvironmentVariable)
	err := c.cc.Invoke(ctx, VaultService_AddEnclaveEnvironmentVariable_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vaultServiceClient) UpdateEnclaveEnvironmentVariable(ctx context.Context, in *EnclaveEnvironmentVariableUpdateRequest, opts ...grpc.CallOption) (*EnclaveEnvironmentVariable, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EnclaveEnvironmentVariable)
	err := c.cc.Invoke(ctx, VaultService_UpdateEnclaveEnvironmentVariable_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vaultServiceClient) DeleteEnclaveEnvironmentVariable(ctx context.Context, in *IdentifierUUID, opts ...grpc.CallOption) (*IdentifierResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IdentifierResponse)
	err := c.cc.Invoke(ctx, VaultService_DeleteEnclaveEnvironmentVariable_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vaultServiceClient) ViewEnclaveEnvironmentVariable(ctx context.Context, in *IdentifierUUID, opts ...grpc.CallOption) (*EnclaveEnvironmentVariable, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EnclaveEnvironmentVariable)
	err := c.cc.Invoke(ctx, VaultService_ViewEnclaveEnvironmentVariable_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vaultServiceClient) ViewAllEnclaveEnvironmentVariables(ctx context.Context, in *IdentifierUUID, opts ...grpc.CallOption) (*EnclaveEnvironmentVariablesList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EnclaveEnvironmentVariablesList)
	err := c.cc.Invoke(ctx, VaultService_ViewAllEnclaveEnvironmentVariables_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vaultServiceClient) AddEnclaveDomain(ctx context.Context, in *EnclaveDomainAddRequest, opts ...grpc.CallOption) (*EnclaveDomain, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EnclaveDomain)
	err := c.cc.Invoke(ctx, VaultService_AddEnclaveDomain_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vaultServiceClient) DeleteEnclaveDomain(ctx context.Context, in *IdentifierUUID, opts ...grpc.CallOption) (*IdentifierResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IdentifierResponse)
	err := c.cc.Invoke(ctx, VaultService_DeleteEnclaveDomain_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vaultServiceClient) ViewEnclaveDomain(ctx context.Context, in *IdentifierUUID, opts ...grpc.CallOption) (*EnclaveDomain, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EnclaveDomain)
	err := c.cc.Invoke(ctx, VaultService_ViewEnclaveDomain_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vaultServiceClient) ViewAllEnclaveDomains(ctx context.Context, in *IdentifierUUID, opts ...grpc.CallOption) (*EnclaveDomainsList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EnclaveDomainsList)
	err := c.cc.Invoke(ctx, VaultService_ViewAllEnclaveDomains_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vaultServiceClient) ViewDomainSuffix(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*EnclaveDomainSuffixResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EnclaveDomainSuffixResp)
	err := c.cc.Invoke(ctx, VaultService_ViewDomainSuffix_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vaultServiceClient) FilterEnclaveDomains(ctx context.Context, in *EnclaveDomainsFilterReq, opts ...grpc.CallOption) (*EnclaveDomainsList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EnclaveDomainsList)
	err := c.cc.Invoke(ctx, VaultService_FilterEnclaveDomains_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vaultServiceClient) AddEnclaveFrame(ctx context.Context, in *EnclaveFrameAddRequest, opts ...grpc.CallOption) (*EnclaveFrame, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EnclaveFrame)
	err := c.cc.Invoke(ctx, VaultService_AddEnclaveFrame_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vaultServiceClient) ViewEnclaveFrame(ctx context.Context, in *IdentifierUUID, opts ...grpc.CallOption) (*EnclaveFrame, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EnclaveFrame)
	err := c.cc.Invoke(ctx, VaultService_ViewEnclaveFrame_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vaultServiceClient) UpdateEnclaveFrame(ctx context.Context, in *EnclaveFrameUpdateRequest, opts ...grpc.CallOption) (*EnclaveFrame, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EnclaveFrame)
	err := c.cc.Invoke(ctx, VaultService_UpdateEnclaveFrame_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vaultServiceClient) DeleteEnclaveFrame(ctx context.Context, in *IdentifierUUID, opts ...grpc.CallOption) (*IdentifierResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IdentifierResponse)
	err := c.cc.Invoke(ctx, VaultService_DeleteEnclaveFrame_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vaultServiceClient) SetupEnclaveFrame(ctx context.Context, in *IdentifierUUID, opts ...grpc.CallOption) (*EnclaveFrameSetup, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EnclaveFrameSetup)
	err := c.cc.Invoke(ctx, VaultService_SetupEnclaveFrame_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vaultServiceClient) SetupAllEnclaveFrames(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*EnclaveFrameSetupList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EnclaveFrameSetupList)
	err := c.cc.Invoke(ctx, VaultService_SetupAllEnclaveFrames_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VaultService
